/** --------------------------------------------------------------------------------------------------------------------
* <copyright company="Aspose" file="models.cpp">
*   Copyright (c) 2024 Aspose.Words for Cloud
* </copyright>
* <summary>
*   Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the "Software"), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
* 
*  The above copyright notice and this permission notice shall be included in all
*  copies or substantial portions of the Software.
* 
*  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
*  SOFTWARE.
* </summary> 
-------------------------------------------------------------------------------------------------------------------- **/
#include "aspose_words_cloud.h"

// USE THIRD PARTY LIBS ONLY IN CPP FILES!!!
#include "../thirdparty/json.hpp"
#include "../thirdparty/utf8.h"

namespace aspose::words::cloud::models {
    static std::unordered_map< std::wstring, std::function< ModelBase*() > > *modelsFactory = new std::unordered_map< std::wstring, std::function< ModelBase* () > > {
        { L"ApiError, _", [] () { return dynamic_cast< ModelBase* >(new ApiError()); }},
        { L"AvailableFontsResponse, _", [] () { return dynamic_cast< ModelBase* >(new AvailableFontsResponse()); }},
        { L"Azw3SaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new Azw3SaveOptionsData()); }},
        { L"BmpSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new BmpSaveOptionsData()); }},
        { L"Bookmark, _", [] () { return dynamic_cast< ModelBase* >(new Bookmark()); }},
        { L"BookmarkData, _", [] () { return dynamic_cast< ModelBase* >(new BookmarkData()); }},
        { L"BookmarkInsert, _", [] () { return dynamic_cast< ModelBase* >(new BookmarkInsert()); }},
        { L"BookmarkResponse, _", [] () { return dynamic_cast< ModelBase* >(new BookmarkResponse()); }},
        { L"Bookmarks, _", [] () { return dynamic_cast< ModelBase* >(new Bookmarks()); }},
        { L"BookmarksOutlineLevelData, _", [] () { return dynamic_cast< ModelBase* >(new BookmarksOutlineLevelData()); }},
        { L"BookmarksResponse, _", [] () { return dynamic_cast< ModelBase* >(new BookmarksResponse()); }},
        { L"Border, _", [] () { return dynamic_cast< ModelBase* >(new Border()); }},
        { L"BorderResponse, _", [] () { return dynamic_cast< ModelBase* >(new BorderResponse()); }},
        { L"BordersCollection, _", [] () { return dynamic_cast< ModelBase* >(new BordersCollection()); }},
        { L"BordersResponse, _", [] () { return dynamic_cast< ModelBase* >(new BordersResponse()); }},
        { L"ClassificationResponse, _", [] () { return dynamic_cast< ModelBase* >(new ClassificationResponse()); }},
        { L"ClassificationResult, _", [] () { return dynamic_cast< ModelBase* >(new ClassificationResult()); }},
        { L"Comment, _", [] () { return dynamic_cast< ModelBase* >(new Comment()); }},
        { L"CommentInsert, _", [] () { return dynamic_cast< ModelBase* >(new CommentInsert()); }},
        { L"CommentLink, _", [] () { return dynamic_cast< ModelBase* >(new CommentLink()); }},
        { L"CommentResponse, _", [] () { return dynamic_cast< ModelBase* >(new CommentResponse()); }},
        { L"CommentsCollection, _", [] () { return dynamic_cast< ModelBase* >(new CommentsCollection()); }},
        { L"CommentsResponse, _", [] () { return dynamic_cast< ModelBase* >(new CommentsResponse()); }},
        { L"CommentUpdate, _", [] () { return dynamic_cast< ModelBase* >(new CommentUpdate()); }},
        { L"CompareData, _", [] () { return dynamic_cast< ModelBase* >(new CompareData()); }},
        { L"CompareOptions, _", [] () { return dynamic_cast< ModelBase* >(new CompareOptions()); }},
        { L"CompressOptions, _", [] () { return dynamic_cast< ModelBase* >(new CompressOptions()); }},
        { L"CompressResponse, _", [] () { return dynamic_cast< ModelBase* >(new CompressResponse()); }},
        { L"CsvDataLoadOptions, _", [] () { return dynamic_cast< ModelBase* >(new CsvDataLoadOptions()); }},
        { L"CustomXmlPart, _", [] () { return dynamic_cast< ModelBase* >(new CustomXmlPart()); }},
        { L"CustomXmlPartInsert, _", [] () { return dynamic_cast< ModelBase* >(new CustomXmlPartInsert()); }},
        { L"CustomXmlPartLink, _", [] () { return dynamic_cast< ModelBase* >(new CustomXmlPartLink()); }},
        { L"CustomXmlPartResponse, _", [] () { return dynamic_cast< ModelBase* >(new CustomXmlPartResponse()); }},
        { L"CustomXmlPartsCollection, _", [] () { return dynamic_cast< ModelBase* >(new CustomXmlPartsCollection()); }},
        { L"CustomXmlPartsResponse, _", [] () { return dynamic_cast< ModelBase* >(new CustomXmlPartsResponse()); }},
        { L"CustomXmlPartUpdate, _", [] () { return dynamic_cast< ModelBase* >(new CustomXmlPartUpdate()); }},
        { L"DocmSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new DocmSaveOptionsData()); }},
        { L"DocSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new DocSaveOptionsData()); }},
        { L"Document, _", [] () { return dynamic_cast< ModelBase* >(new Document()); }},
        { L"DocumentEntry, _", [] () { return dynamic_cast< ModelBase* >(new DocumentEntry()); }},
        { L"DocumentEntryList, _", [] () { return dynamic_cast< ModelBase* >(new DocumentEntryList()); }},
        { L"DocumentPosition, _", [] () { return dynamic_cast< ModelBase* >(new DocumentPosition()); }},
        { L"DocumentProperties, _", [] () { return dynamic_cast< ModelBase* >(new DocumentProperties()); }},
        { L"DocumentPropertiesResponse, _", [] () { return dynamic_cast< ModelBase* >(new DocumentPropertiesResponse()); }},
        { L"DocumentProperty, _", [] () { return dynamic_cast< ModelBase* >(new DocumentProperty()); }},
        { L"DocumentPropertyCreateOrUpdate, _", [] () { return dynamic_cast< ModelBase* >(new DocumentPropertyCreateOrUpdate()); }},
        { L"DocumentPropertyResponse, _", [] () { return dynamic_cast< ModelBase* >(new DocumentPropertyResponse()); }},
        { L"DocumentResponse, _", [] () { return dynamic_cast< ModelBase* >(new DocumentResponse()); }},
        { L"DocumentStatData, _", [] () { return dynamic_cast< ModelBase* >(new DocumentStatData()); }},
        { L"DocxSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new DocxSaveOptionsData()); }},
        { L"DotmSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new DotmSaveOptionsData()); }},
        { L"DotSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new DotSaveOptionsData()); }},
        { L"DotxSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new DotxSaveOptionsData()); }},
        { L"DownsampleOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new DownsampleOptionsData()); }},
        { L"DrawingObject, _", [] () { return dynamic_cast< ModelBase* >(new DrawingObject()); }},
        { L"DrawingObjectCollection, _", [] () { return dynamic_cast< ModelBase* >(new DrawingObjectCollection()); }},
        { L"DrawingObjectInsert, _", [] () { return dynamic_cast< ModelBase* >(new DrawingObjectInsert()); }},
        { L"DrawingObjectLink, _", [] () { return dynamic_cast< ModelBase* >(new DrawingObjectLink()); }},
        { L"DrawingObjectResponse, _", [] () { return dynamic_cast< ModelBase* >(new DrawingObjectResponse()); }},
        { L"DrawingObjectsResponse, _", [] () { return dynamic_cast< ModelBase* >(new DrawingObjectsResponse()); }},
        { L"DrawingObjectUpdate, _", [] () { return dynamic_cast< ModelBase* >(new DrawingObjectUpdate()); }},
        { L"EmfSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new EmfSaveOptionsData()); }},
        { L"EpsSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new EpsSaveOptionsData()); }},
        { L"EpubSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new EpubSaveOptionsData()); }},
        { L"Error, _", [] () { return dynamic_cast< ModelBase* >(new Error()); }},
        { L"ErrorDetails, _", [] () { return dynamic_cast< ModelBase* >(new ErrorDetails()); }},
        { L"Field, _", [] () { return dynamic_cast< ModelBase* >(new Field()); }},
        { L"FieldCollection, _", [] () { return dynamic_cast< ModelBase* >(new FieldCollection()); }},
        { L"FieldInsert, _", [] () { return dynamic_cast< ModelBase* >(new FieldInsert()); }},
        { L"FieldLink, _", [] () { return dynamic_cast< ModelBase* >(new FieldLink()); }},
        { L"FieldNames, _", [] () { return dynamic_cast< ModelBase* >(new FieldNames()); }},
        { L"FieldNamesResponse, _", [] () { return dynamic_cast< ModelBase* >(new FieldNamesResponse()); }},
        { L"FieldOptions, _", [] () { return dynamic_cast< ModelBase* >(new FieldOptions()); }},
        { L"FieldResponse, _", [] () { return dynamic_cast< ModelBase* >(new FieldResponse()); }},
        { L"FieldsResponse, _", [] () { return dynamic_cast< ModelBase* >(new FieldsResponse()); }},
        { L"FieldUpdate, _", [] () { return dynamic_cast< ModelBase* >(new FieldUpdate()); }},
        { L"FileLink, _", [] () { return dynamic_cast< ModelBase* >(new FileLink()); }},
        { L"FilesList, _", [] () { return dynamic_cast< ModelBase* >(new FilesList()); }},
        { L"FilesUploadResult, _", [] () { return dynamic_cast< ModelBase* >(new FilesUploadResult()); }},
        { L"FlatOpcMacroSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new FlatOpcMacroSaveOptionsData()); }},
        { L"FlatOpcSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new FlatOpcSaveOptionsData()); }},
        { L"FlatOpcTemplateMacroSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new FlatOpcTemplateMacroSaveOptionsData()); }},
        { L"FlatOpcTemplateSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new FlatOpcTemplateSaveOptionsData()); }},
        { L"Font, _", [] () { return dynamic_cast< ModelBase* >(new Font()); }},
        { L"FontInfo, _", [] () { return dynamic_cast< ModelBase* >(new FontInfo()); }},
        { L"FontResponse, _", [] () { return dynamic_cast< ModelBase* >(new FontResponse()); }},
        { L"Footnote, _", [] () { return dynamic_cast< ModelBase* >(new Footnote()); }},
        { L"FootnoteCollection, _", [] () { return dynamic_cast< ModelBase* >(new FootnoteCollection()); }},
        { L"FootnoteInsert, _", [] () { return dynamic_cast< ModelBase* >(new FootnoteInsert()); }},
        { L"FootnoteLink, _", [] () { return dynamic_cast< ModelBase* >(new FootnoteLink()); }},
        { L"FootnoteResponse, _", [] () { return dynamic_cast< ModelBase* >(new FootnoteResponse()); }},
        { L"FootnotesResponse, _", [] () { return dynamic_cast< ModelBase* >(new FootnotesResponse()); }},
        { L"FootnotesStatData, _", [] () { return dynamic_cast< ModelBase* >(new FootnotesStatData()); }},
        { L"FootnoteUpdate, _", [] () { return dynamic_cast< ModelBase* >(new FootnoteUpdate()); }},
        { L"FormFieldCheckbox, _", [] () { return dynamic_cast< ModelBase* >(new FormFieldCheckbox()); }},
        { L"FormFieldCollection, _", [] () { return dynamic_cast< ModelBase* >(new FormFieldCollection()); }},
        { L"FormFieldDropDown, _", [] () { return dynamic_cast< ModelBase* >(new FormFieldDropDown()); }},
        { L"FormFieldResponse, _", [] () { return dynamic_cast< ModelBase* >(new FormFieldResponse()); }},
        { L"FormFieldsResponse, _", [] () { return dynamic_cast< ModelBase* >(new FormFieldsResponse()); }},
        { L"FormFieldTextInput, _", [] () { return dynamic_cast< ModelBase* >(new FormFieldTextInput()); }},
        { L"GifSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new GifSaveOptionsData()); }},
        { L"HeaderFooter, _", [] () { return dynamic_cast< ModelBase* >(new HeaderFooter()); }},
        { L"HeaderFooterLink, _", [] () { return dynamic_cast< ModelBase* >(new HeaderFooterLink()); }},
        { L"HeaderFooterLinkCollection, _", [] () { return dynamic_cast< ModelBase* >(new HeaderFooterLinkCollection()); }},
        { L"HeaderFooterResponse, _", [] () { return dynamic_cast< ModelBase* >(new HeaderFooterResponse()); }},
        { L"HeaderFootersResponse, _", [] () { return dynamic_cast< ModelBase* >(new HeaderFootersResponse()); }},
        { L"HtmlFixedSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new HtmlFixedSaveOptionsData()); }},
        { L"HtmlSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new HtmlSaveOptionsData()); }},
        { L"Hyperlink, _", [] () { return dynamic_cast< ModelBase* >(new Hyperlink()); }},
        { L"HyperlinkResponse, _", [] () { return dynamic_cast< ModelBase* >(new HyperlinkResponse()); }},
        { L"Hyperlinks, _", [] () { return dynamic_cast< ModelBase* >(new Hyperlinks()); }},
        { L"HyperlinksResponse, _", [] () { return dynamic_cast< ModelBase* >(new HyperlinksResponse()); }},
        { L"ImageEntry, _", [] () { return dynamic_cast< ModelBase* >(new ImageEntry()); }},
        { L"ImageEntryList, _", [] () { return dynamic_cast< ModelBase* >(new ImageEntryList()); }},
        { L"InfoAdditionalItem, _", [] () { return dynamic_cast< ModelBase* >(new InfoAdditionalItem()); }},
        { L"InfoResponse, _", [] () { return dynamic_cast< ModelBase* >(new InfoResponse()); }},
        { L"JpegSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new JpegSaveOptionsData()); }},
        { L"JsonDataLoadOptions, _", [] () { return dynamic_cast< ModelBase* >(new JsonDataLoadOptions()); }},
        { L"Link, _", [] () { return dynamic_cast< ModelBase* >(new Link()); }},
        { L"LinkElement, _", [] () { return dynamic_cast< ModelBase* >(new LinkElement()); }},
        { L"ListFormat, _", [] () { return dynamic_cast< ModelBase* >(new ListFormat()); }},
        { L"ListFormatUpdate, _", [] () { return dynamic_cast< ModelBase* >(new ListFormatUpdate()); }},
        { L"ListInfo, _", [] () { return dynamic_cast< ModelBase* >(new ListInfo()); }},
        { L"ListInsert, _", [] () { return dynamic_cast< ModelBase* >(new ListInsert()); }},
        { L"ListLevel, _", [] () { return dynamic_cast< ModelBase* >(new ListLevel()); }},
        { L"ListLevels, _", [] () { return dynamic_cast< ModelBase* >(new ListLevels()); }},
        { L"ListLevelUpdate, _", [] () { return dynamic_cast< ModelBase* >(new ListLevelUpdate()); }},
        { L"ListResponse, _", [] () { return dynamic_cast< ModelBase* >(new ListResponse()); }},
        { L"Lists, _", [] () { return dynamic_cast< ModelBase* >(new Lists()); }},
        { L"ListsResponse, _", [] () { return dynamic_cast< ModelBase* >(new ListsResponse()); }},
        { L"ListUpdate, _", [] () { return dynamic_cast< ModelBase* >(new ListUpdate()); }},
        { L"LoadWebDocumentData, _", [] () { return dynamic_cast< ModelBase* >(new LoadWebDocumentData()); }},
        { L"MarkdownSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new MarkdownSaveOptionsData()); }},
        { L"MetafileRenderingOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new MetafileRenderingOptionsData()); }},
        { L"MhtmlSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new MhtmlSaveOptionsData()); }},
        { L"ModificationOperationResult, _", [] () { return dynamic_cast< ModelBase* >(new ModificationOperationResult()); }},
        { L"NodeLink, _", [] () { return dynamic_cast< ModelBase* >(new NodeLink()); }},
        { L"OdtSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new OdtSaveOptionsData()); }},
        { L"OfficeMathLink, _", [] () { return dynamic_cast< ModelBase* >(new OfficeMathLink()); }},
        { L"OfficeMathObject, _", [] () { return dynamic_cast< ModelBase* >(new OfficeMathObject()); }},
        { L"OfficeMathObjectResponse, _", [] () { return dynamic_cast< ModelBase* >(new OfficeMathObjectResponse()); }},
        { L"OfficeMathObjectsCollection, _", [] () { return dynamic_cast< ModelBase* >(new OfficeMathObjectsCollection()); }},
        { L"OfficeMathObjectsResponse, _", [] () { return dynamic_cast< ModelBase* >(new OfficeMathObjectsResponse()); }},
        { L"OpenXpsSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new OpenXpsSaveOptionsData()); }},
        { L"OptimizationOptions, _", [] () { return dynamic_cast< ModelBase* >(new OptimizationOptions()); }},
        { L"OttSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new OttSaveOptionsData()); }},
        { L"OutlineOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new OutlineOptionsData()); }},
        { L"PageNumber, _", [] () { return dynamic_cast< ModelBase* >(new PageNumber()); }},
        { L"PageSetup, _", [] () { return dynamic_cast< ModelBase* >(new PageSetup()); }},
        { L"PageStatData, _", [] () { return dynamic_cast< ModelBase* >(new PageStatData()); }},
        { L"Paragraph, _", [] () { return dynamic_cast< ModelBase* >(new Paragraph()); }},
        { L"ParagraphFormat, _", [] () { return dynamic_cast< ModelBase* >(new ParagraphFormat()); }},
        { L"ParagraphFormatResponse, _", [] () { return dynamic_cast< ModelBase* >(new ParagraphFormatResponse()); }},
        { L"ParagraphFormatUpdate, _", [] () { return dynamic_cast< ModelBase* >(new ParagraphFormatUpdate()); }},
        { L"ParagraphInsert, _", [] () { return dynamic_cast< ModelBase* >(new ParagraphInsert()); }},
        { L"ParagraphLink, _", [] () { return dynamic_cast< ModelBase* >(new ParagraphLink()); }},
        { L"ParagraphLinkCollection, _", [] () { return dynamic_cast< ModelBase* >(new ParagraphLinkCollection()); }},
        { L"ParagraphLinkCollectionResponse, _", [] () { return dynamic_cast< ModelBase* >(new ParagraphLinkCollectionResponse()); }},
        { L"ParagraphListFormatResponse, _", [] () { return dynamic_cast< ModelBase* >(new ParagraphListFormatResponse()); }},
        { L"ParagraphResponse, _", [] () { return dynamic_cast< ModelBase* >(new ParagraphResponse()); }},
        { L"PclSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new PclSaveOptionsData()); }},
        { L"PdfDigitalSignatureDetailsData, _", [] () { return dynamic_cast< ModelBase* >(new PdfDigitalSignatureDetailsData()); }},
        { L"PdfEncryptionDetailsData, _", [] () { return dynamic_cast< ModelBase* >(new PdfEncryptionDetailsData()); }},
        { L"PdfPermissions, _", [] () { return nullptr; }},
        { L"PdfSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new PdfSaveOptionsData()); }},
        { L"PngSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new PngSaveOptionsData()); }},
        { L"PositionAfterNode, _", [] () { return dynamic_cast< ModelBase* >(new PositionAfterNode()); }},
        { L"PositionBeforeNode, _", [] () { return dynamic_cast< ModelBase* >(new PositionBeforeNode()); }},
        { L"PositionInsideNode, _", [] () { return dynamic_cast< ModelBase* >(new PositionInsideNode()); }},
        { L"PreferredWidth, _", [] () { return dynamic_cast< ModelBase* >(new PreferredWidth()); }},
        { L"ProtectionData, _", [] () { return dynamic_cast< ModelBase* >(new ProtectionData()); }},
        { L"ProtectionDataResponse, _", [] () { return dynamic_cast< ModelBase* >(new ProtectionDataResponse()); }},
        { L"ProtectionRequest, _", [] () { return dynamic_cast< ModelBase* >(new ProtectionRequest()); }},
        { L"ProtectionRequestV2, _", [] () { return dynamic_cast< ModelBase* >(new ProtectionRequestV2()); }},
        { L"PsSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new PsSaveOptionsData()); }},
        { L"PublicKeyResponse, _", [] () { return dynamic_cast< ModelBase* >(new PublicKeyResponse()); }},
        { L"RangeDocument, _", [] () { return dynamic_cast< ModelBase* >(new RangeDocument()); }},
        { L"RangeTextResponse, _", [] () { return dynamic_cast< ModelBase* >(new RangeTextResponse()); }},
        { L"ReplaceRange, _", [] () { return dynamic_cast< ModelBase* >(new ReplaceRange()); }},
        { L"ReplaceTextParameters, _", [] () { return dynamic_cast< ModelBase* >(new ReplaceTextParameters()); }},
        { L"ReplaceTextResponse, _", [] () { return dynamic_cast< ModelBase* >(new ReplaceTextResponse()); }},
        { L"ReportBuildOptions, _", [] () { return nullptr; }},
        { L"ReportEngineSettings, _", [] () { return dynamic_cast< ModelBase* >(new ReportEngineSettings()); }},
        { L"RevisionsModificationResponse, _", [] () { return dynamic_cast< ModelBase* >(new RevisionsModificationResponse()); }},
        { L"RtfSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new RtfSaveOptionsData()); }},
        { L"Run, _", [] () { return dynamic_cast< ModelBase* >(new Run()); }},
        { L"RunInsert, _", [] () { return dynamic_cast< ModelBase* >(new RunInsert()); }},
        { L"RunLink, _", [] () { return dynamic_cast< ModelBase* >(new RunLink()); }},
        { L"RunResponse, _", [] () { return dynamic_cast< ModelBase* >(new RunResponse()); }},
        { L"Runs, _", [] () { return dynamic_cast< ModelBase* >(new Runs()); }},
        { L"RunsResponse, _", [] () { return dynamic_cast< ModelBase* >(new RunsResponse()); }},
        { L"RunUpdate, _", [] () { return dynamic_cast< ModelBase* >(new RunUpdate()); }},
        { L"SaveResponse, _", [] () { return dynamic_cast< ModelBase* >(new SaveResponse()); }},
        { L"SaveResult, _", [] () { return dynamic_cast< ModelBase* >(new SaveResult()); }},
        { L"SearchResponse, _", [] () { return dynamic_cast< ModelBase* >(new SearchResponse()); }},
        { L"SearchResult, _", [] () { return dynamic_cast< ModelBase* >(new SearchResult()); }},
        { L"SearchResultsCollection, _", [] () { return dynamic_cast< ModelBase* >(new SearchResultsCollection()); }},
        { L"Section, _", [] () { return dynamic_cast< ModelBase* >(new Section()); }},
        { L"SectionLink, _", [] () { return dynamic_cast< ModelBase* >(new SectionLink()); }},
        { L"SectionLinkCollection, _", [] () { return dynamic_cast< ModelBase* >(new SectionLinkCollection()); }},
        { L"SectionLinkCollectionResponse, _", [] () { return dynamic_cast< ModelBase* >(new SectionLinkCollectionResponse()); }},
        { L"SectionPageSetupResponse, _", [] () { return dynamic_cast< ModelBase* >(new SectionPageSetupResponse()); }},
        { L"SectionResponse, _", [] () { return dynamic_cast< ModelBase* >(new SectionResponse()); }},
        { L"Shading, _", [] () { return dynamic_cast< ModelBase* >(new Shading()); }},
        { L"SplitDocumentResponse, _", [] () { return dynamic_cast< ModelBase* >(new SplitDocumentResponse()); }},
        { L"SplitDocumentResult, _", [] () { return dynamic_cast< ModelBase* >(new SplitDocumentResult()); }},
        { L"StatDataResponse, _", [] () { return dynamic_cast< ModelBase* >(new StatDataResponse()); }},
        { L"StorageFile, _", [] () { return dynamic_cast< ModelBase* >(new StorageFile()); }},
        { L"StoryChildNodes, _", [] () { return dynamic_cast< ModelBase* >(new StoryChildNodes()); }},
        { L"StructuredDocumentTag, _", [] () { return dynamic_cast< ModelBase* >(new StructuredDocumentTag()); }},
        { L"StructuredDocumentTagCollection, _", [] () { return dynamic_cast< ModelBase* >(new StructuredDocumentTagCollection()); }},
        { L"StructuredDocumentTagInsert, _", [] () { return dynamic_cast< ModelBase* >(new StructuredDocumentTagInsert()); }},
        { L"StructuredDocumentTagListItem, _", [] () { return dynamic_cast< ModelBase* >(new StructuredDocumentTagListItem()); }},
        { L"StructuredDocumentTagResponse, _", [] () { return dynamic_cast< ModelBase* >(new StructuredDocumentTagResponse()); }},
        { L"StructuredDocumentTagsResponse, _", [] () { return dynamic_cast< ModelBase* >(new StructuredDocumentTagsResponse()); }},
        { L"StructuredDocumentTagUpdate, _", [] () { return dynamic_cast< ModelBase* >(new StructuredDocumentTagUpdate()); }},
        { L"Style, _", [] () { return dynamic_cast< ModelBase* >(new Style()); }},
        { L"StyleApply, _", [] () { return dynamic_cast< ModelBase* >(new StyleApply()); }},
        { L"StyleCopy, _", [] () { return dynamic_cast< ModelBase* >(new StyleCopy()); }},
        { L"StyleInsert, _", [] () { return dynamic_cast< ModelBase* >(new StyleInsert()); }},
        { L"StyleResponse, _", [] () { return dynamic_cast< ModelBase* >(new StyleResponse()); }},
        { L"StylesResponse, _", [] () { return dynamic_cast< ModelBase* >(new StylesResponse()); }},
        { L"StyleUpdate, _", [] () { return dynamic_cast< ModelBase* >(new StyleUpdate()); }},
        { L"SvgSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new SvgSaveOptionsData()); }},
        { L"Table, _", [] () { return dynamic_cast< ModelBase* >(new Table()); }},
        { L"TableCell, _", [] () { return dynamic_cast< ModelBase* >(new TableCell()); }},
        { L"TableCellFormat, _", [] () { return dynamic_cast< ModelBase* >(new TableCellFormat()); }},
        { L"TableCellFormatResponse, _", [] () { return dynamic_cast< ModelBase* >(new TableCellFormatResponse()); }},
        { L"TableCellInsert, _", [] () { return dynamic_cast< ModelBase* >(new TableCellInsert()); }},
        { L"TableCellResponse, _", [] () { return dynamic_cast< ModelBase* >(new TableCellResponse()); }},
        { L"TableInsert, _", [] () { return dynamic_cast< ModelBase* >(new TableInsert()); }},
        { L"TableLink, _", [] () { return dynamic_cast< ModelBase* >(new TableLink()); }},
        { L"TableLinkCollection, _", [] () { return dynamic_cast< ModelBase* >(new TableLinkCollection()); }},
        { L"TableLinkCollectionResponse, _", [] () { return dynamic_cast< ModelBase* >(new TableLinkCollectionResponse()); }},
        { L"TableProperties, _", [] () { return dynamic_cast< ModelBase* >(new TableProperties()); }},
        { L"TablePropertiesResponse, _", [] () { return dynamic_cast< ModelBase* >(new TablePropertiesResponse()); }},
        { L"TableResponse, _", [] () { return dynamic_cast< ModelBase* >(new TableResponse()); }},
        { L"TableRow, _", [] () { return dynamic_cast< ModelBase* >(new TableRow()); }},
        { L"TableRowFormat, _", [] () { return dynamic_cast< ModelBase* >(new TableRowFormat()); }},
        { L"TableRowFormatResponse, _", [] () { return dynamic_cast< ModelBase* >(new TableRowFormatResponse()); }},
        { L"TableRowInsert, _", [] () { return dynamic_cast< ModelBase* >(new TableRowInsert()); }},
        { L"TableRowResponse, _", [] () { return dynamic_cast< ModelBase* >(new TableRowResponse()); }},
        { L"TabStop, _", [] () { return dynamic_cast< ModelBase* >(new TabStop()); }},
        { L"TabStopInsert, _", [] () { return dynamic_cast< ModelBase* >(new TabStopInsert()); }},
        { L"TabStopsResponse, _", [] () { return dynamic_cast< ModelBase* >(new TabStopsResponse()); }},
        { L"TextSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new TextSaveOptionsData()); }},
        { L"TiffSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new TiffSaveOptionsData()); }},
        { L"TimeZoneInfoData, _", [] () { return dynamic_cast< ModelBase* >(new TimeZoneInfoData()); }},
        { L"TranslateNodeIdResponse, _", [] () { return dynamic_cast< ModelBase* >(new TranslateNodeIdResponse()); }},
        { L"UserInformation, _", [] () { return dynamic_cast< ModelBase* >(new UserInformation()); }},
        { L"WatermarkDataImage, _", [] () { return dynamic_cast< ModelBase* >(new WatermarkDataImage()); }},
        { L"WatermarkDataText, _", [] () { return dynamic_cast< ModelBase* >(new WatermarkDataText()); }},
        { L"WatermarkText, _", [] () { return dynamic_cast< ModelBase* >(new WatermarkText()); }},
        { L"WordMLSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new WordMLSaveOptionsData()); }},
        { L"WordsApiErrorResponse, _", [] () { return dynamic_cast< ModelBase* >(new WordsApiErrorResponse()); }},
        { L"WordsApiLink, _", [] () { return dynamic_cast< ModelBase* >(new WordsApiLink()); }},
        { L"WordsResponse, _", [] () { return dynamic_cast< ModelBase* >(new WordsResponse()); }},
        { L"XamlFixedSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new XamlFixedSaveOptionsData()); }},
        { L"XamlFlowPackSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new XamlFlowPackSaveOptionsData()); }},
        { L"XamlFlowSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new XamlFlowSaveOptionsData()); }},
        { L"XmlColor, _", [] () { return dynamic_cast< ModelBase* >(new XmlColor()); }},
        { L"XmlDataLoadOptions, _", [] () { return dynamic_cast< ModelBase* >(new XmlDataLoadOptions()); }},
        { L"XpsSaveOptionsData, _", [] () { return dynamic_cast< ModelBase* >(new XpsSaveOptionsData()); }}
    };

    ModelBase* createModelInstance(const std::wstring& type)
    {
        if (modelsFactory->find(type) != modelsFactory->end())
        {
            return modelsFactory->at(type)();
        }
        else
        {
            throw aspose::words::cloud::ApiException(400, L"Invalid model type");
        }
    }

    inline std::wstring convertUtf8(const std::string& value)
    {
        std::wstring result;
        ::utf8::utf8to16(value.begin(), value.end(), back_inserter(result));
        return result;
    }

    inline std::string convertUtf16(const std::wstring& value)
    {
        std::string result;
        ::utf8::utf16to8(value.begin(), value.end(), back_inserter(result));
        return result;
    }

    template <typename T> std::shared_ptr< T > createModelInstance(const std::wstring& type, ::nlohmann::json& json)
    {
        ModelBase* resultModel = nullptr;
        if (json.contains("$type"))
        {
            resultModel = createModelInstance(convertUtf8(json["$type"].get< std::string >()));
        }
        else
        {
            resultModel = createModelInstance(type);
        }

        resultModel->fromJson(&json);
        return std::shared_ptr< T >(dynamic_cast< T* >(resultModel));
    }

    FileReference::FileReference() :
        m_Source(FileSource::Storage),
        m_Reference(nullptr),
        m_Content(nullptr),
        m_Password(nullptr),
        m_EncryptedPassword(nullptr)
    { }

    FileReference::FileReference(const std::shared_ptr< std::wstring > remoteStoragePath, const std::shared_ptr< std::wstring > password) :
        m_Source(FileSource::Storage),
        m_Reference(remoteStoragePath),
        m_Content(nullptr),
        m_Password(password),
        m_EncryptedPassword(nullptr)
    { }

    FileReference::FileReference(const std::shared_ptr< std::istream > localFileContent, const std::shared_ptr< std::wstring > password) :
        m_Source(FileSource::Request),
        m_Reference(std::make_shared<std::wstring>(convertUtf8(aspose::words::cloud::ApiClient::createRandomGuid()))),
        m_Content(localFileContent),
        m_Password(password),
        m_EncryptedPassword(nullptr)
    { }

    void FileReference::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        json["Reference"] = convertUtf16(*(this->m_Reference));
        json["Source"] = (m_Source == FileSource::Storage) ? "Storage" : "Request";

        if (this->m_Password != nullptr)
        {
            json["Password"] = convertUtf16(*(this->m_Password));
        }

        if (this->m_EncryptedPassword != nullptr)
        {
            json["EncryptedPassword"] = convertUtf16(*(this->m_EncryptedPassword));
        }
    }

    void FileReference::fromJson(const void* jsonIfc)
    {

    }

    FileSource FileReference::getSource() const
    {
        return this->m_Source;
    }

    std::shared_ptr< std::wstring > FileReference::getReference() const
    {
        return this->m_Reference;
    }

    std::shared_ptr< std::istream > FileReference::getContent() const
    {
        return this->m_Content;
    }

    void FileReference::getFileReferences(std::vector< FileReference* >& result)
    {
        result.push_back(this);
    }

    void FileReference::validate()
    {
    }

    void FileReference::encryptPassword(ApiClient* apiClient)
    {
        if (this->m_Password != nullptr)
        {
            this->m_EncryptedPassword = std::make_shared<std::wstring>(apiClient->encryptString(*this->m_Password));
            this->m_Password = nullptr;
        }
    }

    inline std::string pdfPermissionsToString(PdfPermissions value)
    {
        if (value == PdfPermissions::DISALLOW_ALL) return "DisallowAll";
        if (value == PdfPermissions::PRINTING) return "Printing";
        if (value == PdfPermissions::MODIFY_CONTENTS) return "ModifyContents";
        if (value == PdfPermissions::CONTENT_COPY) return "ContentCopy";
        if (value == PdfPermissions::MODIFY_ANNOTATIONS) return "ModifyAnnotations";
        if (value == PdfPermissions::FILL_IN) return "FillIn";
        if (value == PdfPermissions::CONTENT_COPY_FOR_ACCESSIBILITY) return "ContentCopyForAccessibility";
        if (value == PdfPermissions::DOCUMENT_ASSEMBLY) return "DocumentAssembly";
        if (value == PdfPermissions::HIGH_RESOLUTION_PRINTING) return "HighResolutionPrinting";
        if (value == PdfPermissions::ALLOW_ALL) return "AllowAll";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline PdfPermissions pdfPermissionsFromString(const std::string& value)
    {
        if (value == "DisallowAll") return PdfPermissions::DISALLOW_ALL;
        if (value == "Printing") return PdfPermissions::PRINTING;
        if (value == "ModifyContents") return PdfPermissions::MODIFY_CONTENTS;
        if (value == "ContentCopy") return PdfPermissions::CONTENT_COPY;
        if (value == "ModifyAnnotations") return PdfPermissions::MODIFY_ANNOTATIONS;
        if (value == "FillIn") return PdfPermissions::FILL_IN;
        if (value == "ContentCopyForAccessibility") return PdfPermissions::CONTENT_COPY_FOR_ACCESSIBILITY;
        if (value == "DocumentAssembly") return PdfPermissions::DOCUMENT_ASSEMBLY;
        if (value == "HighResolutionPrinting") return PdfPermissions::HIGH_RESOLUTION_PRINTING;
        if (value == "AllowAll") return PdfPermissions::ALLOW_ALL;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }


    inline std::string reportBuildOptionsToString(ReportBuildOptions value)
    {
        if (value == ReportBuildOptions::NONE) return "None";
        if (value == ReportBuildOptions::ALLOW_MISSING_MEMBERS) return "AllowMissingMembers";
        if (value == ReportBuildOptions::REMOVE_EMPTY_PARAGRAPHS) return "RemoveEmptyParagraphs";
        if (value == ReportBuildOptions::INLINE_ERROR_MESSAGES) return "InlineErrorMessages";
        if (value == ReportBuildOptions::USE_LEGACY_HEADER_FOOTER_VISITING) return "UseLegacyHeaderFooterVisiting";
        if (value == ReportBuildOptions::RESPECT_JPEG_EXIF_ORIENTATION) return "RespectJpegExifOrientation";
        if (value == ReportBuildOptions::UPDATE_FIELDS_SYNTAX_AWARE) return "UpdateFieldsSyntaxAware";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline ReportBuildOptions reportBuildOptionsFromString(const std::string& value)
    {
        if (value == "None") return ReportBuildOptions::NONE;
        if (value == "AllowMissingMembers") return ReportBuildOptions::ALLOW_MISSING_MEMBERS;
        if (value == "RemoveEmptyParagraphs") return ReportBuildOptions::REMOVE_EMPTY_PARAGRAPHS;
        if (value == "InlineErrorMessages") return ReportBuildOptions::INLINE_ERROR_MESSAGES;
        if (value == "UseLegacyHeaderFooterVisiting") return ReportBuildOptions::USE_LEGACY_HEADER_FOOTER_VISITING;
        if (value == "RespectJpegExifOrientation") return ReportBuildOptions::RESPECT_JPEG_EXIF_ORIENTATION;
        if (value == "UpdateFieldsSyntaxAware") return ReportBuildOptions::UPDATE_FIELDS_SYNTAX_AWARE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }


    /*
     * ApiError implementation
     */
    void ApiError::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Code) {
            json["Code"] = convertUtf16(*(this->m_Code));
        }
        if (this->m_DateTime) {
            json["DateTime"] = convertUtf16(*(this->m_DateTime));
        }
        if (this->m_Description) {
            json["Description"] = convertUtf16(*(this->m_Description));
        }
        if (this->m_InnerError) {
            this->m_InnerError->toJson(&json["InnerError"]);
        }
        if (this->m_Message) {
            json["Message"] = convertUtf16(*(this->m_Message));
        }
    }

    void ApiError::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Code") && !json["Code"].is_null()) {
            this->m_Code = std::make_shared< std::wstring >(
                convertUtf8( json["Code"].get< std::string >() )
            );
        }
        if (json.contains("DateTime") && !json["DateTime"].is_null()) {
            this->m_DateTime = std::make_shared< std::wstring >(
                convertUtf8( json["DateTime"].get< std::string >() )
            );
        }
        if (json.contains("Description") && !json["Description"].is_null()) {
            this->m_Description = std::make_shared< std::wstring >(
                convertUtf8( json["Description"].get< std::string >() )
            );
        }
        if (json.contains("InnerError") && !json["InnerError"].is_null()) {
            this->m_InnerError = createModelInstance< aspose::words::cloud::models::ApiError >(L"ApiError, _", json["InnerError"]);
        }
        if (json.contains("Message") && !json["Message"].is_null()) {
            this->m_Message = std::make_shared< std::wstring >(
                convertUtf8( json["Message"].get< std::string >() )
            );
        }
    }

    void ApiError::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ApiError::validate()
    {

        if (this->m_InnerError != nullptr)
        {
            this->m_InnerError->validate();
        }


    }

    std::shared_ptr< std::wstring > ApiError::getCode() const
    {
        return this->m_Code;
    }

    void ApiError::setCode(std::shared_ptr< std::wstring > value)
    {
        this->m_Code = value;
    }


    std::shared_ptr< std::wstring > ApiError::getDateTime() const
    {
        return this->m_DateTime;
    }

    void ApiError::setDateTime(std::shared_ptr< std::wstring > value)
    {
        this->m_DateTime = value;
    }


    std::shared_ptr< std::wstring > ApiError::getDescription() const
    {
        return this->m_Description;
    }

    void ApiError::setDescription(std::shared_ptr< std::wstring > value)
    {
        this->m_Description = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ApiError > ApiError::getInnerError() const
    {
        return this->m_InnerError;
    }

    void ApiError::setInnerError(std::shared_ptr< aspose::words::cloud::models::ApiError > value)
    {
        this->m_InnerError = value;
    }


    std::shared_ptr< std::wstring > ApiError::getMessage() const
    {
        return this->m_Message;
    }

    void ApiError::setMessage(std::shared_ptr< std::wstring > value)
    {
        this->m_Message = value;
    }



    /*
     * AvailableFontsResponse implementation
     */
    void AvailableFontsResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_AdditionalFonts) {
            json["AdditionalFonts"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_AdditionalFonts)) {
                element->toJson(&json["AdditionalFonts"].emplace_back());
            }
        }
        if (this->m_CustomFonts) {
            json["CustomFonts"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_CustomFonts)) {
                element->toJson(&json["CustomFonts"].emplace_back());
            }
        }
        if (this->m_SystemFonts) {
            json["SystemFonts"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_SystemFonts)) {
                element->toJson(&json["SystemFonts"].emplace_back());
            }
        }
    }

    void AvailableFontsResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("AdditionalFonts") && !json["AdditionalFonts"].is_null()) {
            this->m_AdditionalFonts = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::FontInfo>> >();
            for (auto& element : json["AdditionalFonts"]) {
                this->m_AdditionalFonts->emplace_back(createModelInstance< aspose::words::cloud::models::FontInfo >(L"FontInfo, _", element));
            }
        }
        if (json.contains("CustomFonts") && !json["CustomFonts"].is_null()) {
            this->m_CustomFonts = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::FontInfo>> >();
            for (auto& element : json["CustomFonts"]) {
                this->m_CustomFonts->emplace_back(createModelInstance< aspose::words::cloud::models::FontInfo >(L"FontInfo, _", element));
            }
        }
        if (json.contains("SystemFonts") && !json["SystemFonts"].is_null()) {
            this->m_SystemFonts = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::FontInfo>> >();
            for (auto& element : json["SystemFonts"]) {
                this->m_SystemFonts->emplace_back(createModelInstance< aspose::words::cloud::models::FontInfo >(L"FontInfo, _", element));
            }
        }
    }

    void AvailableFontsResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void AvailableFontsResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_AdditionalFonts != nullptr)
        {
            for (auto& elementAdditionalFonts : *(this->m_AdditionalFonts))
            {
                if (elementAdditionalFonts != nullptr)
                {
                    elementAdditionalFonts->validate();
                }
            }
        }



        if (this->m_CustomFonts != nullptr)
        {
            for (auto& elementCustomFonts : *(this->m_CustomFonts))
            {
                if (elementCustomFonts != nullptr)
                {
                    elementCustomFonts->validate();
                }
            }
        }



        if (this->m_SystemFonts != nullptr)
        {
            for (auto& elementSystemFonts : *(this->m_SystemFonts))
            {
                if (elementSystemFonts != nullptr)
                {
                    elementSystemFonts->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::FontInfo>> > AvailableFontsResponse::getAdditionalFonts() const
    {
        return this->m_AdditionalFonts;
    }

    void AvailableFontsResponse::setAdditionalFonts(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::FontInfo>> > value)
    {
        this->m_AdditionalFonts = value;
    }


    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::FontInfo>> > AvailableFontsResponse::getCustomFonts() const
    {
        return this->m_CustomFonts;
    }

    void AvailableFontsResponse::setCustomFonts(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::FontInfo>> > value)
    {
        this->m_CustomFonts = value;
    }


    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::FontInfo>> > AvailableFontsResponse::getSystemFonts() const
    {
        return this->m_SystemFonts;
    }

    void AvailableFontsResponse::setSystemFonts(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::FontInfo>> > value)
    {
        this->m_SystemFonts = value;
    }



    /*
     * Azw3SaveOptionsData implementation
     */
    void Azw3SaveOptionsData::toJson(void* jsonIfc) const
    {
        HtmlSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_NavigationMapLevel) {
            json["NavigationMapLevel"] = *(this->m_NavigationMapLevel);
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void Azw3SaveOptionsData::fromJson(const void* jsonIfc)
    {
        HtmlSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("NavigationMapLevel") && !json["NavigationMapLevel"].is_null()) {
            this->m_NavigationMapLevel = std::make_shared< int32_t >(
                json["NavigationMapLevel"].get< int32_t >()
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void Azw3SaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Azw3SaveOptionsData::validate()
    {
        HtmlSaveOptionsData::validate();
    }

    std::shared_ptr< int32_t > Azw3SaveOptionsData::getNavigationMapLevel() const
    {
        return this->m_NavigationMapLevel;
    }

    void Azw3SaveOptionsData::setNavigationMapLevel(std::shared_ptr< int32_t > value)
    {
        this->m_NavigationMapLevel = value;
    }


    std::shared_ptr< std::wstring > Azw3SaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * BaseEntry implementation
     */
    void BaseEntry::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_FileReference) {
            this->m_FileReference->toJson(&json["FileReference"]);
        }
    }

    void BaseEntry::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("FileReference") && !json["FileReference"].is_null()) {
            this->m_FileReference = createModelInstance< aspose::words::cloud::models::FileReference >(L"FileReference, _", json["FileReference"]);
        }
    }

    void BaseEntry::getFileReferences(std::vector< FileReference* >& result)
    {
        if (getFileReference() != nullptr)
        {
            getFileReference()->getFileReferences(result);
        }

    }

    void BaseEntry::validate()
    {
        if (this->m_FileReference == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property FileReference in BaseEntry is required.");
        }

        this->m_FileReference->validate();


        if (this->m_FileReference != nullptr)
        {
            this->m_FileReference->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::FileReference > BaseEntry::getFileReference() const
    {
        return this->m_FileReference;
    }

    void BaseEntry::setFileReference(std::shared_ptr< aspose::words::cloud::models::FileReference > value)
    {
        this->m_FileReference = value;
    }



    /*
     * BaseEntryList implementation
     */
    void BaseEntryList::toJson(void* jsonIfc) const
    {
    }

    void BaseEntryList::fromJson(const void* jsonIfc)
    {
    }

    void BaseEntryList::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void BaseEntryList::validate()
    {
    }




    /*
     * BmpSaveOptionsData implementation
     */
    void BmpSaveOptionsData::toJson(void* jsonIfc) const
    {
        ImageSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void BmpSaveOptionsData::fromJson(const void* jsonIfc)
    {
        ImageSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void BmpSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void BmpSaveOptionsData::validate()
    {
        ImageSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > BmpSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * Bookmark implementation
     */
    void Bookmark::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Name) {
            json["Name"] = convertUtf16(*(this->m_Name));
        }
        if (this->m_Text) {
            json["Text"] = convertUtf16(*(this->m_Text));
        }
    }

    void Bookmark::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Name") && !json["Name"].is_null()) {
            this->m_Name = std::make_shared< std::wstring >(
                convertUtf8( json["Name"].get< std::string >() )
            );
        }
        if (json.contains("Text") && !json["Text"].is_null()) {
            this->m_Text = std::make_shared< std::wstring >(
                convertUtf8( json["Text"].get< std::string >() )
            );
        }
    }

    void Bookmark::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Bookmark::validate()
    {
        LinkElement::validate();
    }

    std::shared_ptr< std::wstring > Bookmark::getName() const
    {
        return this->m_Name;
    }

    void Bookmark::setName(std::shared_ptr< std::wstring > value)
    {
        this->m_Name = value;
    }


    std::shared_ptr< std::wstring > Bookmark::getText() const
    {
        return this->m_Text;
    }

    void Bookmark::setText(std::shared_ptr< std::wstring > value)
    {
        this->m_Text = value;
    }



    /*
     * BookmarkData implementation
     */
    void BookmarkData::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Name) {
            json["Name"] = convertUtf16(*(this->m_Name));
        }
        if (this->m_Text) {
            json["Text"] = convertUtf16(*(this->m_Text));
        }
    }

    void BookmarkData::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Name") && !json["Name"].is_null()) {
            this->m_Name = std::make_shared< std::wstring >(
                convertUtf8( json["Name"].get< std::string >() )
            );
        }
        if (json.contains("Text") && !json["Text"].is_null()) {
            this->m_Text = std::make_shared< std::wstring >(
                convertUtf8( json["Text"].get< std::string >() )
            );
        }
    }

    void BookmarkData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void BookmarkData::validate()
    {
    }

    std::shared_ptr< std::wstring > BookmarkData::getName() const
    {
        return this->m_Name;
    }

    void BookmarkData::setName(std::shared_ptr< std::wstring > value)
    {
        this->m_Name = value;
    }


    std::shared_ptr< std::wstring > BookmarkData::getText() const
    {
        return this->m_Text;
    }

    void BookmarkData::setText(std::shared_ptr< std::wstring > value)
    {
        this->m_Text = value;
    }



    /*
     * BookmarkInsert implementation
     */
    void BookmarkInsert::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Name) {
            json["Name"] = convertUtf16(*(this->m_Name));
        }
        if (this->m_Text) {
            json["Text"] = convertUtf16(*(this->m_Text));
        }
        if (this->m_StartRange) {
            this->m_StartRange->toJson(&json["StartRange"]);
        }
        if (this->m_EndRange) {
            this->m_EndRange->toJson(&json["EndRange"]);
        }
    }

    void BookmarkInsert::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Name") && !json["Name"].is_null()) {
            this->m_Name = std::make_shared< std::wstring >(
                convertUtf8( json["Name"].get< std::string >() )
            );
        }
        if (json.contains("Text") && !json["Text"].is_null()) {
            this->m_Text = std::make_shared< std::wstring >(
                convertUtf8( json["Text"].get< std::string >() )
            );
        }
        if (json.contains("StartRange") && !json["StartRange"].is_null()) {
            this->m_StartRange = createModelInstance< aspose::words::cloud::models::Position >(L"Position, _", json["StartRange"]);
        }
        if (json.contains("EndRange") && !json["EndRange"].is_null()) {
            this->m_EndRange = createModelInstance< aspose::words::cloud::models::Position >(L"Position, _", json["EndRange"]);
        }
    }

    void BookmarkInsert::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void BookmarkInsert::validate()
    {
        if (this->m_Name == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Name in BookmarkInsert is required.");
        }

        if (this->m_Text == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Text in BookmarkInsert is required.");
        }

        if (this->m_StartRange == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property StartRange in BookmarkInsert is required.");
        }

        this->m_StartRange->validate();

        if (this->m_EndRange == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property EndRange in BookmarkInsert is required.");
        }

        this->m_EndRange->validate();


        if (this->m_StartRange != nullptr)
        {
            this->m_StartRange->validate();
        }



        if (this->m_EndRange != nullptr)
        {
            this->m_EndRange->validate();
        }

    }

    std::shared_ptr< std::wstring > BookmarkInsert::getName() const
    {
        return this->m_Name;
    }

    void BookmarkInsert::setName(std::shared_ptr< std::wstring > value)
    {
        this->m_Name = value;
    }


    std::shared_ptr< std::wstring > BookmarkInsert::getText() const
    {
        return this->m_Text;
    }

    void BookmarkInsert::setText(std::shared_ptr< std::wstring > value)
    {
        this->m_Text = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Position > BookmarkInsert::getStartRange() const
    {
        return this->m_StartRange;
    }

    void BookmarkInsert::setStartRange(std::shared_ptr< aspose::words::cloud::models::Position > value)
    {
        this->m_StartRange = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Position > BookmarkInsert::getEndRange() const
    {
        return this->m_EndRange;
    }

    void BookmarkInsert::setEndRange(std::shared_ptr< aspose::words::cloud::models::Position > value)
    {
        this->m_EndRange = value;
    }



    /*
     * BookmarkResponse implementation
     */
    void BookmarkResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Bookmark) {
            this->m_Bookmark->toJson(&json["Bookmark"]);
        }
    }

    void BookmarkResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Bookmark") && !json["Bookmark"].is_null()) {
            this->m_Bookmark = createModelInstance< aspose::words::cloud::models::Bookmark >(L"Bookmark, _", json["Bookmark"]);
        }
    }

    void BookmarkResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void BookmarkResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Bookmark != nullptr)
        {
            this->m_Bookmark->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Bookmark > BookmarkResponse::getBookmark() const
    {
        return this->m_Bookmark;
    }

    void BookmarkResponse::setBookmark(std::shared_ptr< aspose::words::cloud::models::Bookmark > value)
    {
        this->m_Bookmark = value;
    }



    /*
     * Bookmarks implementation
     */
    void Bookmarks::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_BookmarkList) {
            json["BookmarkList"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_BookmarkList)) {
                element->toJson(&json["BookmarkList"].emplace_back());
            }
        }
    }

    void Bookmarks::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("BookmarkList") && !json["BookmarkList"].is_null()) {
            this->m_BookmarkList = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::Bookmark>> >();
            for (auto& element : json["BookmarkList"]) {
                this->m_BookmarkList->emplace_back(createModelInstance< aspose::words::cloud::models::Bookmark >(L"Bookmark, _", element));
            }
        }
    }

    void Bookmarks::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Bookmarks::validate()
    {
        LinkElement::validate();

        if (this->m_BookmarkList != nullptr)
        {
            for (auto& elementBookmarkList : *(this->m_BookmarkList))
            {
                if (elementBookmarkList != nullptr)
                {
                    elementBookmarkList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Bookmark>> > Bookmarks::getBookmarkList() const
    {
        return this->m_BookmarkList;
    }

    void Bookmarks::setBookmarkList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Bookmark>> > value)
    {
        this->m_BookmarkList = value;
    }



    /*
     * BookmarksOutlineLevelData implementation
     */
    void BookmarksOutlineLevelData::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_BookmarksOutlineLevel) {
            json["BookmarksOutlineLevel"] = *(this->m_BookmarksOutlineLevel);
        }
        if (this->m_Name) {
            json["Name"] = convertUtf16(*(this->m_Name));
        }
    }

    void BookmarksOutlineLevelData::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("BookmarksOutlineLevel") && !json["BookmarksOutlineLevel"].is_null()) {
            this->m_BookmarksOutlineLevel = std::make_shared< int32_t >(
                json["BookmarksOutlineLevel"].get< int32_t >()
            );
        }
        if (json.contains("Name") && !json["Name"].is_null()) {
            this->m_Name = std::make_shared< std::wstring >(
                convertUtf8( json["Name"].get< std::string >() )
            );
        }
    }

    void BookmarksOutlineLevelData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void BookmarksOutlineLevelData::validate()
    {
        if (this->m_BookmarksOutlineLevel == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property BookmarksOutlineLevel in BookmarksOutlineLevelData is required.");
        }

    }

    std::shared_ptr< int32_t > BookmarksOutlineLevelData::getBookmarksOutlineLevel() const
    {
        return this->m_BookmarksOutlineLevel;
    }

    void BookmarksOutlineLevelData::setBookmarksOutlineLevel(std::shared_ptr< int32_t > value)
    {
        this->m_BookmarksOutlineLevel = value;
    }


    std::shared_ptr< std::wstring > BookmarksOutlineLevelData::getName() const
    {
        return this->m_Name;
    }

    void BookmarksOutlineLevelData::setName(std::shared_ptr< std::wstring > value)
    {
        this->m_Name = value;
    }



    /*
     * BookmarksResponse implementation
     */
    void BookmarksResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Bookmarks) {
            this->m_Bookmarks->toJson(&json["Bookmarks"]);
        }
    }

    void BookmarksResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Bookmarks") && !json["Bookmarks"].is_null()) {
            this->m_Bookmarks = createModelInstance< aspose::words::cloud::models::Bookmarks >(L"Bookmarks, _", json["Bookmarks"]);
        }
    }

    void BookmarksResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void BookmarksResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Bookmarks != nullptr)
        {
            this->m_Bookmarks->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Bookmarks > BookmarksResponse::getBookmarks() const
    {
        return this->m_Bookmarks;
    }

    void BookmarksResponse::setBookmarks(std::shared_ptr< aspose::words::cloud::models::Bookmarks > value)
    {
        this->m_Bookmarks = value;
    }



    /*
     * Border implementation
     */
    inline std::string borderBorderTypeToString(aspose::words::cloud::models::Border::BorderType value)
    {
        if (value == aspose::words::cloud::models::Border::BorderType::BOTTOM) return "Bottom";
        if (value == aspose::words::cloud::models::Border::BorderType::LEFT) return "Left";
        if (value == aspose::words::cloud::models::Border::BorderType::RIGHT) return "Right";
        if (value == aspose::words::cloud::models::Border::BorderType::TOP) return "Top";
        if (value == aspose::words::cloud::models::Border::BorderType::HORIZONTAL) return "Horizontal";
        if (value == aspose::words::cloud::models::Border::BorderType::VERTICAL) return "Vertical";
        if (value == aspose::words::cloud::models::Border::BorderType::DIAGONAL_DOWN) return "DiagonalDown";
        if (value == aspose::words::cloud::models::Border::BorderType::DIAGONAL_UP) return "DiagonalUp";
        if (value == aspose::words::cloud::models::Border::BorderType::NONE) return "None";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::Border::BorderType borderBorderTypeFromString(const std::string& value)
    {
        if (value == "Bottom") return aspose::words::cloud::models::Border::BorderType::BOTTOM;
        if (value == "Left") return aspose::words::cloud::models::Border::BorderType::LEFT;
        if (value == "Right") return aspose::words::cloud::models::Border::BorderType::RIGHT;
        if (value == "Top") return aspose::words::cloud::models::Border::BorderType::TOP;
        if (value == "Horizontal") return aspose::words::cloud::models::Border::BorderType::HORIZONTAL;
        if (value == "Vertical") return aspose::words::cloud::models::Border::BorderType::VERTICAL;
        if (value == "DiagonalDown") return aspose::words::cloud::models::Border::BorderType::DIAGONAL_DOWN;
        if (value == "DiagonalUp") return aspose::words::cloud::models::Border::BorderType::DIAGONAL_UP;
        if (value == "None") return aspose::words::cloud::models::Border::BorderType::NONE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string borderLineStyleToString(aspose::words::cloud::models::Border::LineStyle value)
    {
        if (value == aspose::words::cloud::models::Border::LineStyle::NONE) return "None";
        if (value == aspose::words::cloud::models::Border::LineStyle::SINGLE) return "Single";
        if (value == aspose::words::cloud::models::Border::LineStyle::THICK) return "Thick";
        if (value == aspose::words::cloud::models::Border::LineStyle::DOUBLE) return "Double";
        if (value == aspose::words::cloud::models::Border::LineStyle::HAIRLINE) return "Hairline";
        if (value == aspose::words::cloud::models::Border::LineStyle::DOT) return "Dot";
        if (value == aspose::words::cloud::models::Border::LineStyle::DASH_LARGE_GAP) return "DashLargeGap";
        if (value == aspose::words::cloud::models::Border::LineStyle::DOT_DASH) return "DotDash";
        if (value == aspose::words::cloud::models::Border::LineStyle::DOT_DOT_DASH) return "DotDotDash";
        if (value == aspose::words::cloud::models::Border::LineStyle::TRIPLE) return "Triple";
        if (value == aspose::words::cloud::models::Border::LineStyle::THIN_THICK_SMALL_GAP) return "ThinThickSmallGap";
        if (value == aspose::words::cloud::models::Border::LineStyle::THICK_THIN_SMALL_GAP) return "ThickThinSmallGap";
        if (value == aspose::words::cloud::models::Border::LineStyle::THIN_THICK_THIN_SMALL_GAP) return "ThinThickThinSmallGap";
        if (value == aspose::words::cloud::models::Border::LineStyle::THIN_THICK_MEDIUM_GAP) return "ThinThickMediumGap";
        if (value == aspose::words::cloud::models::Border::LineStyle::THICK_THIN_MEDIUM_GAP) return "ThickThinMediumGap";
        if (value == aspose::words::cloud::models::Border::LineStyle::THIN_THICK_THIN_MEDIUM_GAP) return "ThinThickThinMediumGap";
        if (value == aspose::words::cloud::models::Border::LineStyle::THIN_THICK_LARGE_GAP) return "ThinThickLargeGap";
        if (value == aspose::words::cloud::models::Border::LineStyle::THICK_THIN_LARGE_GAP) return "ThickThinLargeGap";
        if (value == aspose::words::cloud::models::Border::LineStyle::THIN_THICK_THIN_LARGE_GAP) return "ThinThickThinLargeGap";
        if (value == aspose::words::cloud::models::Border::LineStyle::WAVE) return "Wave";
        if (value == aspose::words::cloud::models::Border::LineStyle::DOUBLE_WAVE) return "DoubleWave";
        if (value == aspose::words::cloud::models::Border::LineStyle::DASH_SMALL_GAP) return "DashSmallGap";
        if (value == aspose::words::cloud::models::Border::LineStyle::DASH_DOT_STROKER) return "DashDotStroker";
        if (value == aspose::words::cloud::models::Border::LineStyle::EMBOSS3_D) return "Emboss3D";
        if (value == aspose::words::cloud::models::Border::LineStyle::ENGRAVE3_D) return "Engrave3D";
        if (value == aspose::words::cloud::models::Border::LineStyle::OUTSET) return "Outset";
        if (value == aspose::words::cloud::models::Border::LineStyle::INSET) return "Inset";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::Border::LineStyle borderLineStyleFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::Border::LineStyle::NONE;
        if (value == "Single") return aspose::words::cloud::models::Border::LineStyle::SINGLE;
        if (value == "Thick") return aspose::words::cloud::models::Border::LineStyle::THICK;
        if (value == "Double") return aspose::words::cloud::models::Border::LineStyle::DOUBLE;
        if (value == "Hairline") return aspose::words::cloud::models::Border::LineStyle::HAIRLINE;
        if (value == "Dot") return aspose::words::cloud::models::Border::LineStyle::DOT;
        if (value == "DashLargeGap") return aspose::words::cloud::models::Border::LineStyle::DASH_LARGE_GAP;
        if (value == "DotDash") return aspose::words::cloud::models::Border::LineStyle::DOT_DASH;
        if (value == "DotDotDash") return aspose::words::cloud::models::Border::LineStyle::DOT_DOT_DASH;
        if (value == "Triple") return aspose::words::cloud::models::Border::LineStyle::TRIPLE;
        if (value == "ThinThickSmallGap") return aspose::words::cloud::models::Border::LineStyle::THIN_THICK_SMALL_GAP;
        if (value == "ThickThinSmallGap") return aspose::words::cloud::models::Border::LineStyle::THICK_THIN_SMALL_GAP;
        if (value == "ThinThickThinSmallGap") return aspose::words::cloud::models::Border::LineStyle::THIN_THICK_THIN_SMALL_GAP;
        if (value == "ThinThickMediumGap") return aspose::words::cloud::models::Border::LineStyle::THIN_THICK_MEDIUM_GAP;
        if (value == "ThickThinMediumGap") return aspose::words::cloud::models::Border::LineStyle::THICK_THIN_MEDIUM_GAP;
        if (value == "ThinThickThinMediumGap") return aspose::words::cloud::models::Border::LineStyle::THIN_THICK_THIN_MEDIUM_GAP;
        if (value == "ThinThickLargeGap") return aspose::words::cloud::models::Border::LineStyle::THIN_THICK_LARGE_GAP;
        if (value == "ThickThinLargeGap") return aspose::words::cloud::models::Border::LineStyle::THICK_THIN_LARGE_GAP;
        if (value == "ThinThickThinLargeGap") return aspose::words::cloud::models::Border::LineStyle::THIN_THICK_THIN_LARGE_GAP;
        if (value == "Wave") return aspose::words::cloud::models::Border::LineStyle::WAVE;
        if (value == "DoubleWave") return aspose::words::cloud::models::Border::LineStyle::DOUBLE_WAVE;
        if (value == "DashSmallGap") return aspose::words::cloud::models::Border::LineStyle::DASH_SMALL_GAP;
        if (value == "DashDotStroker") return aspose::words::cloud::models::Border::LineStyle::DASH_DOT_STROKER;
        if (value == "Emboss3D") return aspose::words::cloud::models::Border::LineStyle::EMBOSS3_D;
        if (value == "Engrave3D") return aspose::words::cloud::models::Border::LineStyle::ENGRAVE3_D;
        if (value == "Outset") return aspose::words::cloud::models::Border::LineStyle::OUTSET;
        if (value == "Inset") return aspose::words::cloud::models::Border::LineStyle::INSET;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void Border::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_BorderType) {
            json["BorderType"] = borderBorderTypeToString(*(this->m_BorderType));
        }
        if (this->m_Color) {
            this->m_Color->toJson(&json["Color"]);
        }
        if (this->m_DistanceFromText) {
            json["DistanceFromText"] = *(this->m_DistanceFromText);
        }
        if (this->m_LineStyle) {
            json["LineStyle"] = borderLineStyleToString(*(this->m_LineStyle));
        }
        if (this->m_LineWidth) {
            json["LineWidth"] = *(this->m_LineWidth);
        }
        if (this->m_Shadow) {
            json["Shadow"] = *(this->m_Shadow);
        }
    }

    void Border::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("BorderType") && !json["BorderType"].is_null()) {
            this->m_BorderType = std::make_shared< aspose::words::cloud::models::Border::BorderType >(
                borderBorderTypeFromString(json["BorderType"].get< std::string >())
            );
        }
        if (json.contains("Color") && !json["Color"].is_null()) {
            this->m_Color = createModelInstance< aspose::words::cloud::models::XmlColor >(L"XmlColor, _", json["Color"]);
        }
        if (json.contains("DistanceFromText") && !json["DistanceFromText"].is_null()) {
            this->m_DistanceFromText = std::make_shared< double >(
                json["DistanceFromText"].get< double >()
            );
        }
        if (json.contains("LineStyle") && !json["LineStyle"].is_null()) {
            this->m_LineStyle = std::make_shared< aspose::words::cloud::models::Border::LineStyle >(
                borderLineStyleFromString(json["LineStyle"].get< std::string >())
            );
        }
        if (json.contains("LineWidth") && !json["LineWidth"].is_null()) {
            this->m_LineWidth = std::make_shared< double >(
                json["LineWidth"].get< double >()
            );
        }
        if (json.contains("Shadow") && !json["Shadow"].is_null()) {
            this->m_Shadow = std::make_shared< bool >(
                json["Shadow"].get< bool >()
            );
        }
    }

    void Border::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Border::validate()
    {
        LinkElement::validate();

        if (this->m_Color != nullptr)
        {
            this->m_Color->validate();
        }





    }

    std::shared_ptr< aspose::words::cloud::models::Border::BorderType > Border::getBorderType() const
    {
        return this->m_BorderType;
    }

    void Border::setBorderType(std::shared_ptr< aspose::words::cloud::models::Border::BorderType > value)
    {
        this->m_BorderType = value;
    }


    std::shared_ptr< aspose::words::cloud::models::XmlColor > Border::getColor() const
    {
        return this->m_Color;
    }

    void Border::setColor(std::shared_ptr< aspose::words::cloud::models::XmlColor > value)
    {
        this->m_Color = value;
    }


    std::shared_ptr< double > Border::getDistanceFromText() const
    {
        return this->m_DistanceFromText;
    }

    void Border::setDistanceFromText(std::shared_ptr< double > value)
    {
        this->m_DistanceFromText = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Border::LineStyle > Border::getLineStyle() const
    {
        return this->m_LineStyle;
    }

    void Border::setLineStyle(std::shared_ptr< aspose::words::cloud::models::Border::LineStyle > value)
    {
        this->m_LineStyle = value;
    }


    std::shared_ptr< double > Border::getLineWidth() const
    {
        return this->m_LineWidth;
    }

    void Border::setLineWidth(std::shared_ptr< double > value)
    {
        this->m_LineWidth = value;
    }


    std::shared_ptr< bool > Border::getShadow() const
    {
        return this->m_Shadow;
    }

    void Border::setShadow(std::shared_ptr< bool > value)
    {
        this->m_Shadow = value;
    }



    /*
     * BorderResponse implementation
     */
    void BorderResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Border) {
            this->m_Border->toJson(&json["Border"]);
        }
    }

    void BorderResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Border") && !json["Border"].is_null()) {
            this->m_Border = createModelInstance< aspose::words::cloud::models::Border >(L"Border, _", json["Border"]);
        }
    }

    void BorderResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void BorderResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Border != nullptr)
        {
            this->m_Border->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Border > BorderResponse::getBorder() const
    {
        return this->m_Border;
    }

    void BorderResponse::setBorder(std::shared_ptr< aspose::words::cloud::models::Border > value)
    {
        this->m_Border = value;
    }



    /*
     * BordersCollection implementation
     */
    void BordersCollection::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_List) {
            json["List"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_List)) {
                element->toJson(&json["List"].emplace_back());
            }
        }
    }

    void BordersCollection::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("List") && !json["List"].is_null()) {
            this->m_List = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::Border>> >();
            for (auto& element : json["List"]) {
                this->m_List->emplace_back(createModelInstance< aspose::words::cloud::models::Border >(L"Border, _", element));
            }
        }
    }

    void BordersCollection::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void BordersCollection::validate()
    {
        LinkElement::validate();

        if (this->m_List != nullptr)
        {
            for (auto& elementList : *(this->m_List))
            {
                if (elementList != nullptr)
                {
                    elementList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Border>> > BordersCollection::getList() const
    {
        return this->m_List;
    }

    void BordersCollection::setList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Border>> > value)
    {
        this->m_List = value;
    }



    /*
     * BordersResponse implementation
     */
    void BordersResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Borders) {
            this->m_Borders->toJson(&json["Borders"]);
        }
    }

    void BordersResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Borders") && !json["Borders"].is_null()) {
            this->m_Borders = createModelInstance< aspose::words::cloud::models::BordersCollection >(L"BordersCollection, _", json["Borders"]);
        }
    }

    void BordersResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void BordersResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Borders != nullptr)
        {
            this->m_Borders->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::BordersCollection > BordersResponse::getBorders() const
    {
        return this->m_Borders;
    }

    void BordersResponse::setBorders(std::shared_ptr< aspose::words::cloud::models::BordersCollection > value)
    {
        this->m_Borders = value;
    }



    /*
     * ClassificationResponse implementation
     */
    void ClassificationResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_BestClassName) {
            json["BestClassName"] = convertUtf16(*(this->m_BestClassName));
        }
        if (this->m_BestClassProbability) {
            json["BestClassProbability"] = *(this->m_BestClassProbability);
        }
        if (this->m_BestResults) {
            json["BestResults"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_BestResults)) {
                element->toJson(&json["BestResults"].emplace_back());
            }
        }
    }

    void ClassificationResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("BestClassName") && !json["BestClassName"].is_null()) {
            this->m_BestClassName = std::make_shared< std::wstring >(
                convertUtf8( json["BestClassName"].get< std::string >() )
            );
        }
        if (json.contains("BestClassProbability") && !json["BestClassProbability"].is_null()) {
            this->m_BestClassProbability = std::make_shared< double >(
                json["BestClassProbability"].get< double >()
            );
        }
        if (json.contains("BestResults") && !json["BestResults"].is_null()) {
            this->m_BestResults = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::ClassificationResult>> >();
            for (auto& element : json["BestResults"]) {
                this->m_BestResults->emplace_back(createModelInstance< aspose::words::cloud::models::ClassificationResult >(L"ClassificationResult, _", element));
            }
        }
    }

    void ClassificationResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ClassificationResponse::validate()
    {
        WordsResponse::validate();
        if (this->m_BestClassProbability == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property BestClassProbability in ClassificationResponse is required.");
        }


        if (this->m_BestResults != nullptr)
        {
            for (auto& elementBestResults : *(this->m_BestResults))
            {
                if (elementBestResults != nullptr)
                {
                    elementBestResults->validate();
                }
            }
        }

    }

    std::shared_ptr< std::wstring > ClassificationResponse::getBestClassName() const
    {
        return this->m_BestClassName;
    }

    void ClassificationResponse::setBestClassName(std::shared_ptr< std::wstring > value)
    {
        this->m_BestClassName = value;
    }


    std::shared_ptr< double > ClassificationResponse::getBestClassProbability() const
    {
        return this->m_BestClassProbability;
    }

    void ClassificationResponse::setBestClassProbability(std::shared_ptr< double > value)
    {
        this->m_BestClassProbability = value;
    }


    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::ClassificationResult>> > ClassificationResponse::getBestResults() const
    {
        return this->m_BestResults;
    }

    void ClassificationResponse::setBestResults(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::ClassificationResult>> > value)
    {
        this->m_BestResults = value;
    }



    /*
     * ClassificationResult implementation
     */
    void ClassificationResult::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ClassName) {
            json["ClassName"] = convertUtf16(*(this->m_ClassName));
        }
        if (this->m_ClassProbability) {
            json["ClassProbability"] = *(this->m_ClassProbability);
        }
    }

    void ClassificationResult::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ClassName") && !json["ClassName"].is_null()) {
            this->m_ClassName = std::make_shared< std::wstring >(
                convertUtf8( json["ClassName"].get< std::string >() )
            );
        }
        if (json.contains("ClassProbability") && !json["ClassProbability"].is_null()) {
            this->m_ClassProbability = std::make_shared< double >(
                json["ClassProbability"].get< double >()
            );
        }
    }

    void ClassificationResult::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ClassificationResult::validate()
    {
        if (this->m_ClassProbability == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property ClassProbability in ClassificationResult is required.");
        }

    }

    std::shared_ptr< std::wstring > ClassificationResult::getClassName() const
    {
        return this->m_ClassName;
    }

    void ClassificationResult::setClassName(std::shared_ptr< std::wstring > value)
    {
        this->m_ClassName = value;
    }


    std::shared_ptr< double > ClassificationResult::getClassProbability() const
    {
        return this->m_ClassProbability;
    }

    void ClassificationResult::setClassProbability(std::shared_ptr< double > value)
    {
        this->m_ClassProbability = value;
    }



    /*
     * Comment implementation
     */
    void Comment::toJson(void* jsonIfc) const
    {
        CommentLink::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_RangeStart) {
            this->m_RangeStart->toJson(&json["RangeStart"]);
        }
        if (this->m_RangeEnd) {
            this->m_RangeEnd->toJson(&json["RangeEnd"]);
        }
        if (this->m_Author) {
            json["Author"] = convertUtf16(*(this->m_Author));
        }
        if (this->m_Initial) {
            json["Initial"] = convertUtf16(*(this->m_Initial));
        }
        if (this->m_DateTime) {
            json["DateTime"] = convertUtf16(*(this->m_DateTime));
        }
        if (this->m_Text) {
            json["Text"] = convertUtf16(*(this->m_Text));
        }
        if (this->m_Content) {
            this->m_Content->toJson(&json["Content"]);
        }
    }

    void Comment::fromJson(const void* jsonIfc)
    {
        CommentLink::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("RangeStart") && !json["RangeStart"].is_null()) {
            this->m_RangeStart = createModelInstance< aspose::words::cloud::models::DocumentPosition >(L"DocumentPosition, _", json["RangeStart"]);
        }
        if (json.contains("RangeEnd") && !json["RangeEnd"].is_null()) {
            this->m_RangeEnd = createModelInstance< aspose::words::cloud::models::DocumentPosition >(L"DocumentPosition, _", json["RangeEnd"]);
        }
        if (json.contains("Author") && !json["Author"].is_null()) {
            this->m_Author = std::make_shared< std::wstring >(
                convertUtf8( json["Author"].get< std::string >() )
            );
        }
        if (json.contains("Initial") && !json["Initial"].is_null()) {
            this->m_Initial = std::make_shared< std::wstring >(
                convertUtf8( json["Initial"].get< std::string >() )
            );
        }
        if (json.contains("DateTime") && !json["DateTime"].is_null()) {
            this->m_DateTime = std::make_shared< std::wstring >(
                convertUtf8( json["DateTime"].get< std::string >() )
            );
        }
        if (json.contains("Text") && !json["Text"].is_null()) {
            this->m_Text = std::make_shared< std::wstring >(
                convertUtf8( json["Text"].get< std::string >() )
            );
        }
        if (json.contains("Content") && !json["Content"].is_null()) {
            this->m_Content = createModelInstance< aspose::words::cloud::models::StoryChildNodes >(L"StoryChildNodes, _", json["Content"]);
        }
    }

    void Comment::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Comment::validate()
    {
        CommentLink::validate();

        if (this->m_RangeStart != nullptr)
        {
            this->m_RangeStart->validate();
        }



        if (this->m_RangeEnd != nullptr)
        {
            this->m_RangeEnd->validate();
        }







        if (this->m_Content != nullptr)
        {
            this->m_Content->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::DocumentPosition > Comment::getRangeStart() const
    {
        return this->m_RangeStart;
    }

    void Comment::setRangeStart(std::shared_ptr< aspose::words::cloud::models::DocumentPosition > value)
    {
        this->m_RangeStart = value;
    }


    std::shared_ptr< aspose::words::cloud::models::DocumentPosition > Comment::getRangeEnd() const
    {
        return this->m_RangeEnd;
    }

    void Comment::setRangeEnd(std::shared_ptr< aspose::words::cloud::models::DocumentPosition > value)
    {
        this->m_RangeEnd = value;
    }


    std::shared_ptr< std::wstring > Comment::getAuthor() const
    {
        return this->m_Author;
    }

    void Comment::setAuthor(std::shared_ptr< std::wstring > value)
    {
        this->m_Author = value;
    }


    std::shared_ptr< std::wstring > Comment::getInitial() const
    {
        return this->m_Initial;
    }

    void Comment::setInitial(std::shared_ptr< std::wstring > value)
    {
        this->m_Initial = value;
    }


    std::shared_ptr< std::wstring > Comment::getDateTime() const
    {
        return this->m_DateTime;
    }

    void Comment::setDateTime(std::shared_ptr< std::wstring > value)
    {
        this->m_DateTime = value;
    }


    std::shared_ptr< std::wstring > Comment::getText() const
    {
        return this->m_Text;
    }

    void Comment::setText(std::shared_ptr< std::wstring > value)
    {
        this->m_Text = value;
    }


    std::shared_ptr< aspose::words::cloud::models::StoryChildNodes > Comment::getContent() const
    {
        return this->m_Content;
    }

    void Comment::setContent(std::shared_ptr< aspose::words::cloud::models::StoryChildNodes > value)
    {
        this->m_Content = value;
    }



    /*
     * CommentBase implementation
     */
    void CommentBase::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_RangeStart) {
            this->m_RangeStart->toJson(&json["RangeStart"]);
        }
        if (this->m_RangeEnd) {
            this->m_RangeEnd->toJson(&json["RangeEnd"]);
        }
        if (this->m_Author) {
            json["Author"] = convertUtf16(*(this->m_Author));
        }
        if (this->m_Initial) {
            json["Initial"] = convertUtf16(*(this->m_Initial));
        }
        if (this->m_DateTime) {
            json["DateTime"] = convertUtf16(*(this->m_DateTime));
        }
        if (this->m_Text) {
            json["Text"] = convertUtf16(*(this->m_Text));
        }
    }

    void CommentBase::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("RangeStart") && !json["RangeStart"].is_null()) {
            this->m_RangeStart = createModelInstance< aspose::words::cloud::models::PositionInsideNode >(L"PositionInsideNode, _", json["RangeStart"]);
        }
        if (json.contains("RangeEnd") && !json["RangeEnd"].is_null()) {
            this->m_RangeEnd = createModelInstance< aspose::words::cloud::models::PositionInsideNode >(L"PositionInsideNode, _", json["RangeEnd"]);
        }
        if (json.contains("Author") && !json["Author"].is_null()) {
            this->m_Author = std::make_shared< std::wstring >(
                convertUtf8( json["Author"].get< std::string >() )
            );
        }
        if (json.contains("Initial") && !json["Initial"].is_null()) {
            this->m_Initial = std::make_shared< std::wstring >(
                convertUtf8( json["Initial"].get< std::string >() )
            );
        }
        if (json.contains("DateTime") && !json["DateTime"].is_null()) {
            this->m_DateTime = std::make_shared< std::wstring >(
                convertUtf8( json["DateTime"].get< std::string >() )
            );
        }
        if (json.contains("Text") && !json["Text"].is_null()) {
            this->m_Text = std::make_shared< std::wstring >(
                convertUtf8( json["Text"].get< std::string >() )
            );
        }
    }

    void CommentBase::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CommentBase::validate()
    {
        if (this->m_RangeStart == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property RangeStart in CommentBase is required.");
        }

        this->m_RangeStart->validate();

        if (this->m_RangeEnd == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property RangeEnd in CommentBase is required.");
        }

        this->m_RangeEnd->validate();

        if (this->m_Author == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Author in CommentBase is required.");
        }

        if (this->m_Initial == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Initial in CommentBase is required.");
        }

        if (this->m_Text == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Text in CommentBase is required.");
        }


        if (this->m_RangeStart != nullptr)
        {
            this->m_RangeStart->validate();
        }



        if (this->m_RangeEnd != nullptr)
        {
            this->m_RangeEnd->validate();
        }





    }

    std::shared_ptr< aspose::words::cloud::models::PositionInsideNode > CommentBase::getRangeStart() const
    {
        return this->m_RangeStart;
    }

    void CommentBase::setRangeStart(std::shared_ptr< aspose::words::cloud::models::PositionInsideNode > value)
    {
        this->m_RangeStart = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PositionInsideNode > CommentBase::getRangeEnd() const
    {
        return this->m_RangeEnd;
    }

    void CommentBase::setRangeEnd(std::shared_ptr< aspose::words::cloud::models::PositionInsideNode > value)
    {
        this->m_RangeEnd = value;
    }


    std::shared_ptr< std::wstring > CommentBase::getAuthor() const
    {
        return this->m_Author;
    }

    void CommentBase::setAuthor(std::shared_ptr< std::wstring > value)
    {
        this->m_Author = value;
    }


    std::shared_ptr< std::wstring > CommentBase::getInitial() const
    {
        return this->m_Initial;
    }

    void CommentBase::setInitial(std::shared_ptr< std::wstring > value)
    {
        this->m_Initial = value;
    }


    std::shared_ptr< std::wstring > CommentBase::getDateTime() const
    {
        return this->m_DateTime;
    }

    void CommentBase::setDateTime(std::shared_ptr< std::wstring > value)
    {
        this->m_DateTime = value;
    }


    std::shared_ptr< std::wstring > CommentBase::getText() const
    {
        return this->m_Text;
    }

    void CommentBase::setText(std::shared_ptr< std::wstring > value)
    {
        this->m_Text = value;
    }



    /*
     * CommentInsert implementation
     */
    void CommentInsert::toJson(void* jsonIfc) const
    {
        CommentBase::toJson(jsonIfc);
    }

    void CommentInsert::fromJson(const void* jsonIfc)
    {
        CommentBase::fromJson(jsonIfc);
    }

    void CommentInsert::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CommentInsert::validate()
    {
        CommentBase::validate();
    }




    /*
     * CommentLink implementation
     */
    void CommentLink::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
    }

    void CommentLink::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
    }

    void CommentLink::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CommentLink::validate()
    {
        LinkElement::validate();
    }




    /*
     * CommentResponse implementation
     */
    void CommentResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Comment) {
            this->m_Comment->toJson(&json["Comment"]);
        }
    }

    void CommentResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Comment") && !json["Comment"].is_null()) {
            this->m_Comment = createModelInstance< aspose::words::cloud::models::Comment >(L"Comment, _", json["Comment"]);
        }
    }

    void CommentResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CommentResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Comment != nullptr)
        {
            this->m_Comment->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Comment > CommentResponse::getComment() const
    {
        return this->m_Comment;
    }

    void CommentResponse::setComment(std::shared_ptr< aspose::words::cloud::models::Comment > value)
    {
        this->m_Comment = value;
    }



    /*
     * CommentsCollection implementation
     */
    void CommentsCollection::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_CommentList) {
            json["CommentList"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_CommentList)) {
                element->toJson(&json["CommentList"].emplace_back());
            }
        }
    }

    void CommentsCollection::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("CommentList") && !json["CommentList"].is_null()) {
            this->m_CommentList = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::Comment>> >();
            for (auto& element : json["CommentList"]) {
                this->m_CommentList->emplace_back(createModelInstance< aspose::words::cloud::models::Comment >(L"Comment, _", element));
            }
        }
    }

    void CommentsCollection::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CommentsCollection::validate()
    {
        LinkElement::validate();

        if (this->m_CommentList != nullptr)
        {
            for (auto& elementCommentList : *(this->m_CommentList))
            {
                if (elementCommentList != nullptr)
                {
                    elementCommentList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Comment>> > CommentsCollection::getCommentList() const
    {
        return this->m_CommentList;
    }

    void CommentsCollection::setCommentList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Comment>> > value)
    {
        this->m_CommentList = value;
    }



    /*
     * CommentsResponse implementation
     */
    void CommentsResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Comments) {
            this->m_Comments->toJson(&json["Comments"]);
        }
    }

    void CommentsResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Comments") && !json["Comments"].is_null()) {
            this->m_Comments = createModelInstance< aspose::words::cloud::models::CommentsCollection >(L"CommentsCollection, _", json["Comments"]);
        }
    }

    void CommentsResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CommentsResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Comments != nullptr)
        {
            this->m_Comments->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::CommentsCollection > CommentsResponse::getComments() const
    {
        return this->m_Comments;
    }

    void CommentsResponse::setComments(std::shared_ptr< aspose::words::cloud::models::CommentsCollection > value)
    {
        this->m_Comments = value;
    }



    /*
     * CommentUpdate implementation
     */
    void CommentUpdate::toJson(void* jsonIfc) const
    {
        CommentBase::toJson(jsonIfc);
    }

    void CommentUpdate::fromJson(const void* jsonIfc)
    {
        CommentBase::fromJson(jsonIfc);
    }

    void CommentUpdate::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CommentUpdate::validate()
    {
        CommentBase::validate();
    }




    /*
     * CompareData implementation
     */
    void CompareData::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Author) {
            json["Author"] = convertUtf16(*(this->m_Author));
        }
        if (this->m_CompareOptions) {
            this->m_CompareOptions->toJson(&json["CompareOptions"]);
        }
        if (this->m_ComparingWithDocument) {
            json["ComparingWithDocument"] = convertUtf16(*(this->m_ComparingWithDocument));
        }
        if (this->m_DateTime) {
            json["DateTime"] = convertUtf16(*(this->m_DateTime));
        }
        if (this->m_FileReference) {
            this->m_FileReference->toJson(&json["FileReference"]);
        }
        if (this->m_ResultDocumentFormat) {
            json["ResultDocumentFormat"] = convertUtf16(*(this->m_ResultDocumentFormat));
        }
    }

    void CompareData::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Author") && !json["Author"].is_null()) {
            this->m_Author = std::make_shared< std::wstring >(
                convertUtf8( json["Author"].get< std::string >() )
            );
        }
        if (json.contains("CompareOptions") && !json["CompareOptions"].is_null()) {
            this->m_CompareOptions = createModelInstance< aspose::words::cloud::models::CompareOptions >(L"CompareOptions, _", json["CompareOptions"]);
        }
        if (json.contains("ComparingWithDocument") && !json["ComparingWithDocument"].is_null()) {
            this->m_ComparingWithDocument = std::make_shared< std::wstring >(
                convertUtf8( json["ComparingWithDocument"].get< std::string >() )
            );
        }
        if (json.contains("DateTime") && !json["DateTime"].is_null()) {
            this->m_DateTime = std::make_shared< std::wstring >(
                convertUtf8( json["DateTime"].get< std::string >() )
            );
        }
        if (json.contains("FileReference") && !json["FileReference"].is_null()) {
            this->m_FileReference = createModelInstance< aspose::words::cloud::models::FileReference >(L"FileReference, _", json["FileReference"]);
        }
        if (json.contains("ResultDocumentFormat") && !json["ResultDocumentFormat"].is_null()) {
            this->m_ResultDocumentFormat = std::make_shared< std::wstring >(
                convertUtf8( json["ResultDocumentFormat"].get< std::string >() )
            );
        }
    }

    void CompareData::getFileReferences(std::vector< FileReference* >& result)
    {
        if (getFileReference() != nullptr)
        {
            getFileReference()->getFileReferences(result);
        }


    }

    void CompareData::validate()
    {
        if (this->m_Author == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Author in CompareData is required.");
        }

        if (this->m_FileReference == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property FileReference in CompareData is required.");
        }

        this->m_FileReference->validate();


        if (this->m_CompareOptions != nullptr)
        {
            this->m_CompareOptions->validate();
        }





        if (this->m_FileReference != nullptr)
        {
            this->m_FileReference->validate();
        }


    }

    std::shared_ptr< std::wstring > CompareData::getAuthor() const
    {
        return this->m_Author;
    }

    void CompareData::setAuthor(std::shared_ptr< std::wstring > value)
    {
        this->m_Author = value;
    }


    std::shared_ptr< aspose::words::cloud::models::CompareOptions > CompareData::getCompareOptions() const
    {
        return this->m_CompareOptions;
    }

    void CompareData::setCompareOptions(std::shared_ptr< aspose::words::cloud::models::CompareOptions > value)
    {
        this->m_CompareOptions = value;
    }


    std::shared_ptr< std::wstring > CompareData::getComparingWithDocument() const
    {
        return this->m_ComparingWithDocument;
    }

    void CompareData::setComparingWithDocument(std::shared_ptr< std::wstring > value)
    {
        this->m_ComparingWithDocument = value;
    }


    std::shared_ptr< std::wstring > CompareData::getDateTime() const
    {
        return this->m_DateTime;
    }

    void CompareData::setDateTime(std::shared_ptr< std::wstring > value)
    {
        this->m_DateTime = value;
    }


    std::shared_ptr< aspose::words::cloud::models::FileReference > CompareData::getFileReference() const
    {
        return this->m_FileReference;
    }

    void CompareData::setFileReference(std::shared_ptr< aspose::words::cloud::models::FileReference > value)
    {
        this->m_FileReference = value;
    }


    std::shared_ptr< std::wstring > CompareData::getResultDocumentFormat() const
    {
        return this->m_ResultDocumentFormat;
    }

    void CompareData::setResultDocumentFormat(std::shared_ptr< std::wstring > value)
    {
        this->m_ResultDocumentFormat = value;
    }



    /*
     * CompareOptions implementation
     */
    inline std::string compareOptionsTargetToString(aspose::words::cloud::models::CompareOptions::Target value)
    {
        if (value == aspose::words::cloud::models::CompareOptions::Target::CURRENT) return "Current";
        if (value == aspose::words::cloud::models::CompareOptions::Target::NEW) return "New";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::CompareOptions::Target compareOptionsTargetFromString(const std::string& value)
    {
        if (value == "Current") return aspose::words::cloud::models::CompareOptions::Target::CURRENT;
        if (value == "New") return aspose::words::cloud::models::CompareOptions::Target::NEW;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void CompareOptions::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_AcceptAllRevisionsBeforeComparison) {
            json["AcceptAllRevisionsBeforeComparison"] = *(this->m_AcceptAllRevisionsBeforeComparison);
        }
        if (this->m_IgnoreCaseChanges) {
            json["IgnoreCaseChanges"] = *(this->m_IgnoreCaseChanges);
        }
        if (this->m_IgnoreComments) {
            json["IgnoreComments"] = *(this->m_IgnoreComments);
        }
        if (this->m_IgnoreFields) {
            json["IgnoreFields"] = *(this->m_IgnoreFields);
        }
        if (this->m_IgnoreFootnotes) {
            json["IgnoreFootnotes"] = *(this->m_IgnoreFootnotes);
        }
        if (this->m_IgnoreFormatting) {
            json["IgnoreFormatting"] = *(this->m_IgnoreFormatting);
        }
        if (this->m_IgnoreHeadersAndFooters) {
            json["IgnoreHeadersAndFooters"] = *(this->m_IgnoreHeadersAndFooters);
        }
        if (this->m_IgnoreTables) {
            json["IgnoreTables"] = *(this->m_IgnoreTables);
        }
        if (this->m_IgnoreTextboxes) {
            json["IgnoreTextboxes"] = *(this->m_IgnoreTextboxes);
        }
        if (this->m_Target) {
            json["Target"] = compareOptionsTargetToString(*(this->m_Target));
        }
    }

    void CompareOptions::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("AcceptAllRevisionsBeforeComparison") && !json["AcceptAllRevisionsBeforeComparison"].is_null()) {
            this->m_AcceptAllRevisionsBeforeComparison = std::make_shared< bool >(
                json["AcceptAllRevisionsBeforeComparison"].get< bool >()
            );
        }
        if (json.contains("IgnoreCaseChanges") && !json["IgnoreCaseChanges"].is_null()) {
            this->m_IgnoreCaseChanges = std::make_shared< bool >(
                json["IgnoreCaseChanges"].get< bool >()
            );
        }
        if (json.contains("IgnoreComments") && !json["IgnoreComments"].is_null()) {
            this->m_IgnoreComments = std::make_shared< bool >(
                json["IgnoreComments"].get< bool >()
            );
        }
        if (json.contains("IgnoreFields") && !json["IgnoreFields"].is_null()) {
            this->m_IgnoreFields = std::make_shared< bool >(
                json["IgnoreFields"].get< bool >()
            );
        }
        if (json.contains("IgnoreFootnotes") && !json["IgnoreFootnotes"].is_null()) {
            this->m_IgnoreFootnotes = std::make_shared< bool >(
                json["IgnoreFootnotes"].get< bool >()
            );
        }
        if (json.contains("IgnoreFormatting") && !json["IgnoreFormatting"].is_null()) {
            this->m_IgnoreFormatting = std::make_shared< bool >(
                json["IgnoreFormatting"].get< bool >()
            );
        }
        if (json.contains("IgnoreHeadersAndFooters") && !json["IgnoreHeadersAndFooters"].is_null()) {
            this->m_IgnoreHeadersAndFooters = std::make_shared< bool >(
                json["IgnoreHeadersAndFooters"].get< bool >()
            );
        }
        if (json.contains("IgnoreTables") && !json["IgnoreTables"].is_null()) {
            this->m_IgnoreTables = std::make_shared< bool >(
                json["IgnoreTables"].get< bool >()
            );
        }
        if (json.contains("IgnoreTextboxes") && !json["IgnoreTextboxes"].is_null()) {
            this->m_IgnoreTextboxes = std::make_shared< bool >(
                json["IgnoreTextboxes"].get< bool >()
            );
        }
        if (json.contains("Target") && !json["Target"].is_null()) {
            this->m_Target = std::make_shared< aspose::words::cloud::models::CompareOptions::Target >(
                compareOptionsTargetFromString(json["Target"].get< std::string >())
            );
        }
    }

    void CompareOptions::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CompareOptions::validate()
    {
    }

    std::shared_ptr< bool > CompareOptions::getAcceptAllRevisionsBeforeComparison() const
    {
        return this->m_AcceptAllRevisionsBeforeComparison;
    }

    void CompareOptions::setAcceptAllRevisionsBeforeComparison(std::shared_ptr< bool > value)
    {
        this->m_AcceptAllRevisionsBeforeComparison = value;
    }


    std::shared_ptr< bool > CompareOptions::getIgnoreCaseChanges() const
    {
        return this->m_IgnoreCaseChanges;
    }

    void CompareOptions::setIgnoreCaseChanges(std::shared_ptr< bool > value)
    {
        this->m_IgnoreCaseChanges = value;
    }


    std::shared_ptr< bool > CompareOptions::getIgnoreComments() const
    {
        return this->m_IgnoreComments;
    }

    void CompareOptions::setIgnoreComments(std::shared_ptr< bool > value)
    {
        this->m_IgnoreComments = value;
    }


    std::shared_ptr< bool > CompareOptions::getIgnoreFields() const
    {
        return this->m_IgnoreFields;
    }

    void CompareOptions::setIgnoreFields(std::shared_ptr< bool > value)
    {
        this->m_IgnoreFields = value;
    }


    std::shared_ptr< bool > CompareOptions::getIgnoreFootnotes() const
    {
        return this->m_IgnoreFootnotes;
    }

    void CompareOptions::setIgnoreFootnotes(std::shared_ptr< bool > value)
    {
        this->m_IgnoreFootnotes = value;
    }


    std::shared_ptr< bool > CompareOptions::getIgnoreFormatting() const
    {
        return this->m_IgnoreFormatting;
    }

    void CompareOptions::setIgnoreFormatting(std::shared_ptr< bool > value)
    {
        this->m_IgnoreFormatting = value;
    }


    std::shared_ptr< bool > CompareOptions::getIgnoreHeadersAndFooters() const
    {
        return this->m_IgnoreHeadersAndFooters;
    }

    void CompareOptions::setIgnoreHeadersAndFooters(std::shared_ptr< bool > value)
    {
        this->m_IgnoreHeadersAndFooters = value;
    }


    std::shared_ptr< bool > CompareOptions::getIgnoreTables() const
    {
        return this->m_IgnoreTables;
    }

    void CompareOptions::setIgnoreTables(std::shared_ptr< bool > value)
    {
        this->m_IgnoreTables = value;
    }


    std::shared_ptr< bool > CompareOptions::getIgnoreTextboxes() const
    {
        return this->m_IgnoreTextboxes;
    }

    void CompareOptions::setIgnoreTextboxes(std::shared_ptr< bool > value)
    {
        this->m_IgnoreTextboxes = value;
    }


    std::shared_ptr< aspose::words::cloud::models::CompareOptions::Target > CompareOptions::getTarget() const
    {
        return this->m_Target;
    }

    void CompareOptions::setTarget(std::shared_ptr< aspose::words::cloud::models::CompareOptions::Target > value)
    {
        this->m_Target = value;
    }



    /*
     * CompressOptions implementation
     */
    void CompressOptions::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ImagesQuality) {
            json["ImagesQuality"] = *(this->m_ImagesQuality);
        }
        if (this->m_ImagesReduceSizeFactor) {
            json["ImagesReduceSizeFactor"] = *(this->m_ImagesReduceSizeFactor);
        }
    }

    void CompressOptions::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ImagesQuality") && !json["ImagesQuality"].is_null()) {
            this->m_ImagesQuality = std::make_shared< int32_t >(
                json["ImagesQuality"].get< int32_t >()
            );
        }
        if (json.contains("ImagesReduceSizeFactor") && !json["ImagesReduceSizeFactor"].is_null()) {
            this->m_ImagesReduceSizeFactor = std::make_shared< int32_t >(
                json["ImagesReduceSizeFactor"].get< int32_t >()
            );
        }
    }

    void CompressOptions::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CompressOptions::validate()
    {
    }

    std::shared_ptr< int32_t > CompressOptions::getImagesQuality() const
    {
        return this->m_ImagesQuality;
    }

    void CompressOptions::setImagesQuality(std::shared_ptr< int32_t > value)
    {
        this->m_ImagesQuality = value;
    }


    std::shared_ptr< int32_t > CompressOptions::getImagesReduceSizeFactor() const
    {
        return this->m_ImagesReduceSizeFactor;
    }

    void CompressOptions::setImagesReduceSizeFactor(std::shared_ptr< int32_t > value)
    {
        this->m_ImagesReduceSizeFactor = value;
    }



    /*
     * CompressResponse implementation
     */
    void CompressResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Document) {
            this->m_Document->toJson(&json["Document"]);
        }
    }

    void CompressResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Document") && !json["Document"].is_null()) {
            this->m_Document = createModelInstance< aspose::words::cloud::models::Document >(L"Document, _", json["Document"]);
        }
    }

    void CompressResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CompressResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Document != nullptr)
        {
            this->m_Document->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Document > CompressResponse::getDocument() const
    {
        return this->m_Document;
    }

    void CompressResponse::setDocument(std::shared_ptr< aspose::words::cloud::models::Document > value)
    {
        this->m_Document = value;
    }



    /*
     * CsvDataLoadOptions implementation
     */
    void CsvDataLoadOptions::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_CommentChar) {
            json["CommentChar"] = convertUtf16(*(this->m_CommentChar));
        }
        if (this->m_Delimiter) {
            json["Delimiter"] = convertUtf16(*(this->m_Delimiter));
        }
        if (this->m_HasHeaders) {
            json["HasHeaders"] = *(this->m_HasHeaders);
        }
        if (this->m_QuoteChar) {
            json["QuoteChar"] = convertUtf16(*(this->m_QuoteChar));
        }
    }

    void CsvDataLoadOptions::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("CommentChar") && !json["CommentChar"].is_null()) {
            this->m_CommentChar = std::make_shared< std::wstring >(
                convertUtf8( json["CommentChar"].get< std::string >() )
            );
        }
        if (json.contains("Delimiter") && !json["Delimiter"].is_null()) {
            this->m_Delimiter = std::make_shared< std::wstring >(
                convertUtf8( json["Delimiter"].get< std::string >() )
            );
        }
        if (json.contains("HasHeaders") && !json["HasHeaders"].is_null()) {
            this->m_HasHeaders = std::make_shared< bool >(
                json["HasHeaders"].get< bool >()
            );
        }
        if (json.contains("QuoteChar") && !json["QuoteChar"].is_null()) {
            this->m_QuoteChar = std::make_shared< std::wstring >(
                convertUtf8( json["QuoteChar"].get< std::string >() )
            );
        }
    }

    void CsvDataLoadOptions::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CsvDataLoadOptions::validate()
    {
        if (this->m_CommentChar == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property CommentChar in CsvDataLoadOptions is required.");
        }

        if (this->m_Delimiter == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Delimiter in CsvDataLoadOptions is required.");
        }

        if (this->m_HasHeaders == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property HasHeaders in CsvDataLoadOptions is required.");
        }

        if (this->m_QuoteChar == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property QuoteChar in CsvDataLoadOptions is required.");
        }

    }

    std::shared_ptr< std::wstring > CsvDataLoadOptions::getCommentChar() const
    {
        return this->m_CommentChar;
    }

    void CsvDataLoadOptions::setCommentChar(std::shared_ptr< std::wstring > value)
    {
        this->m_CommentChar = value;
    }


    std::shared_ptr< std::wstring > CsvDataLoadOptions::getDelimiter() const
    {
        return this->m_Delimiter;
    }

    void CsvDataLoadOptions::setDelimiter(std::shared_ptr< std::wstring > value)
    {
        this->m_Delimiter = value;
    }


    std::shared_ptr< bool > CsvDataLoadOptions::getHasHeaders() const
    {
        return this->m_HasHeaders;
    }

    void CsvDataLoadOptions::setHasHeaders(std::shared_ptr< bool > value)
    {
        this->m_HasHeaders = value;
    }


    std::shared_ptr< std::wstring > CsvDataLoadOptions::getQuoteChar() const
    {
        return this->m_QuoteChar;
    }

    void CsvDataLoadOptions::setQuoteChar(std::shared_ptr< std::wstring > value)
    {
        this->m_QuoteChar = value;
    }



    /*
     * CustomXmlPart implementation
     */
    void CustomXmlPart::toJson(void* jsonIfc) const
    {
        CustomXmlPartLink::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Id) {
            json["Id"] = convertUtf16(*(this->m_Id));
        }
        if (this->m_Data) {
            json["Data"] = convertUtf16(*(this->m_Data));
        }
    }

    void CustomXmlPart::fromJson(const void* jsonIfc)
    {
        CustomXmlPartLink::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Id") && !json["Id"].is_null()) {
            this->m_Id = std::make_shared< std::wstring >(
                convertUtf8( json["Id"].get< std::string >() )
            );
        }
        if (json.contains("Data") && !json["Data"].is_null()) {
            this->m_Data = std::make_shared< std::wstring >(
                convertUtf8( json["Data"].get< std::string >() )
            );
        }
    }

    void CustomXmlPart::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CustomXmlPart::validate()
    {
        CustomXmlPartLink::validate();
        if (this->m_Data == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Data in CustomXmlPart is required.");
        }

    }

    std::shared_ptr< std::wstring > CustomXmlPart::getId() const
    {
        return this->m_Id;
    }

    void CustomXmlPart::setId(std::shared_ptr< std::wstring > value)
    {
        this->m_Id = value;
    }


    std::shared_ptr< std::wstring > CustomXmlPart::getData() const
    {
        return this->m_Data;
    }

    void CustomXmlPart::setData(std::shared_ptr< std::wstring > value)
    {
        this->m_Data = value;
    }



    /*
     * CustomXmlPartInsert implementation
     */
    void CustomXmlPartInsert::toJson(void* jsonIfc) const
    {
        CustomXmlPart::toJson(jsonIfc);
    }

    void CustomXmlPartInsert::fromJson(const void* jsonIfc)
    {
        CustomXmlPart::fromJson(jsonIfc);
    }

    void CustomXmlPartInsert::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CustomXmlPartInsert::validate()
    {
        CustomXmlPart::validate();
    }




    /*
     * CustomXmlPartLink implementation
     */
    void CustomXmlPartLink::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
    }

    void CustomXmlPartLink::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
    }

    void CustomXmlPartLink::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CustomXmlPartLink::validate()
    {
        LinkElement::validate();
    }




    /*
     * CustomXmlPartResponse implementation
     */
    void CustomXmlPartResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_CustomXmlPart) {
            this->m_CustomXmlPart->toJson(&json["CustomXmlPart"]);
        }
    }

    void CustomXmlPartResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("CustomXmlPart") && !json["CustomXmlPart"].is_null()) {
            this->m_CustomXmlPart = createModelInstance< aspose::words::cloud::models::CustomXmlPart >(L"CustomXmlPart, _", json["CustomXmlPart"]);
        }
    }

    void CustomXmlPartResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CustomXmlPartResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_CustomXmlPart != nullptr)
        {
            this->m_CustomXmlPart->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::CustomXmlPart > CustomXmlPartResponse::getCustomXmlPart() const
    {
        return this->m_CustomXmlPart;
    }

    void CustomXmlPartResponse::setCustomXmlPart(std::shared_ptr< aspose::words::cloud::models::CustomXmlPart > value)
    {
        this->m_CustomXmlPart = value;
    }



    /*
     * CustomXmlPartsCollection implementation
     */
    void CustomXmlPartsCollection::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_CustomXmlPartsList) {
            json["CustomXmlPartsList"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_CustomXmlPartsList)) {
                element->toJson(&json["CustomXmlPartsList"].emplace_back());
            }
        }
    }

    void CustomXmlPartsCollection::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("CustomXmlPartsList") && !json["CustomXmlPartsList"].is_null()) {
            this->m_CustomXmlPartsList = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::CustomXmlPart>> >();
            for (auto& element : json["CustomXmlPartsList"]) {
                this->m_CustomXmlPartsList->emplace_back(createModelInstance< aspose::words::cloud::models::CustomXmlPart >(L"CustomXmlPart, _", element));
            }
        }
    }

    void CustomXmlPartsCollection::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CustomXmlPartsCollection::validate()
    {
        LinkElement::validate();

        if (this->m_CustomXmlPartsList != nullptr)
        {
            for (auto& elementCustomXmlPartsList : *(this->m_CustomXmlPartsList))
            {
                if (elementCustomXmlPartsList != nullptr)
                {
                    elementCustomXmlPartsList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::CustomXmlPart>> > CustomXmlPartsCollection::getCustomXmlPartsList() const
    {
        return this->m_CustomXmlPartsList;
    }

    void CustomXmlPartsCollection::setCustomXmlPartsList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::CustomXmlPart>> > value)
    {
        this->m_CustomXmlPartsList = value;
    }



    /*
     * CustomXmlPartsResponse implementation
     */
    void CustomXmlPartsResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_CustomXmlParts) {
            this->m_CustomXmlParts->toJson(&json["CustomXmlParts"]);
        }
    }

    void CustomXmlPartsResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("CustomXmlParts") && !json["CustomXmlParts"].is_null()) {
            this->m_CustomXmlParts = createModelInstance< aspose::words::cloud::models::CustomXmlPartsCollection >(L"CustomXmlPartsCollection, _", json["CustomXmlParts"]);
        }
    }

    void CustomXmlPartsResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CustomXmlPartsResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_CustomXmlParts != nullptr)
        {
            this->m_CustomXmlParts->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::CustomXmlPartsCollection > CustomXmlPartsResponse::getCustomXmlParts() const
    {
        return this->m_CustomXmlParts;
    }

    void CustomXmlPartsResponse::setCustomXmlParts(std::shared_ptr< aspose::words::cloud::models::CustomXmlPartsCollection > value)
    {
        this->m_CustomXmlParts = value;
    }



    /*
     * CustomXmlPartUpdate implementation
     */
    void CustomXmlPartUpdate::toJson(void* jsonIfc) const
    {
        CustomXmlPart::toJson(jsonIfc);
    }

    void CustomXmlPartUpdate::fromJson(const void* jsonIfc)
    {
        CustomXmlPart::fromJson(jsonIfc);
    }

    void CustomXmlPartUpdate::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void CustomXmlPartUpdate::validate()
    {
        CustomXmlPart::validate();
    }




    /*
     * DocmSaveOptionsData implementation
     */
    void DocmSaveOptionsData::toJson(void* jsonIfc) const
    {
        OoxmlSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void DocmSaveOptionsData::fromJson(const void* jsonIfc)
    {
        OoxmlSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void DocmSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DocmSaveOptionsData::validate()
    {
        OoxmlSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > DocmSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * DocSaveOptionsData implementation
     */
    void DocSaveOptionsData::toJson(void* jsonIfc) const
    {
        SaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_AlwaysCompressMetafiles) {
            json["AlwaysCompressMetafiles"] = *(this->m_AlwaysCompressMetafiles);
        }
        if (this->m_Password) {
            json["Password"] = convertUtf16(*(this->m_Password));
        }
        if (this->m_SavePictureBullet) {
            json["SavePictureBullet"] = *(this->m_SavePictureBullet);
        }
        if (this->m_SaveRoutingSlip) {
            json["SaveRoutingSlip"] = *(this->m_SaveRoutingSlip);
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void DocSaveOptionsData::fromJson(const void* jsonIfc)
    {
        SaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("AlwaysCompressMetafiles") && !json["AlwaysCompressMetafiles"].is_null()) {
            this->m_AlwaysCompressMetafiles = std::make_shared< bool >(
                json["AlwaysCompressMetafiles"].get< bool >()
            );
        }
        if (json.contains("Password") && !json["Password"].is_null()) {
            this->m_Password = std::make_shared< std::wstring >(
                convertUtf8( json["Password"].get< std::string >() )
            );
        }
        if (json.contains("SavePictureBullet") && !json["SavePictureBullet"].is_null()) {
            this->m_SavePictureBullet = std::make_shared< bool >(
                json["SavePictureBullet"].get< bool >()
            );
        }
        if (json.contains("SaveRoutingSlip") && !json["SaveRoutingSlip"].is_null()) {
            this->m_SaveRoutingSlip = std::make_shared< bool >(
                json["SaveRoutingSlip"].get< bool >()
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void DocSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DocSaveOptionsData::validate()
    {
        SaveOptionsData::validate();
    }

    std::shared_ptr< bool > DocSaveOptionsData::getAlwaysCompressMetafiles() const
    {
        return this->m_AlwaysCompressMetafiles;
    }

    void DocSaveOptionsData::setAlwaysCompressMetafiles(std::shared_ptr< bool > value)
    {
        this->m_AlwaysCompressMetafiles = value;
    }


    std::shared_ptr< std::wstring > DocSaveOptionsData::getPassword() const
    {
        return this->m_Password;
    }

    void DocSaveOptionsData::setPassword(std::shared_ptr< std::wstring > value)
    {
        this->m_Password = value;
    }


    std::shared_ptr< bool > DocSaveOptionsData::getSavePictureBullet() const
    {
        return this->m_SavePictureBullet;
    }

    void DocSaveOptionsData::setSavePictureBullet(std::shared_ptr< bool > value)
    {
        this->m_SavePictureBullet = value;
    }


    std::shared_ptr< bool > DocSaveOptionsData::getSaveRoutingSlip() const
    {
        return this->m_SaveRoutingSlip;
    }

    void DocSaveOptionsData::setSaveRoutingSlip(std::shared_ptr< bool > value)
    {
        this->m_SaveRoutingSlip = value;
    }


    std::shared_ptr< std::wstring > DocSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * Document implementation
     */
    inline std::string documentSourceFormatToString(aspose::words::cloud::models::Document::SourceFormat value)
    {
        if (value == aspose::words::cloud::models::Document::SourceFormat::UNKNOWN) return "Unknown";
        if (value == aspose::words::cloud::models::Document::SourceFormat::DOC) return "Doc";
        if (value == aspose::words::cloud::models::Document::SourceFormat::DOT) return "Dot";
        if (value == aspose::words::cloud::models::Document::SourceFormat::DOC_PRE_WORD60) return "DocPreWord60";
        if (value == aspose::words::cloud::models::Document::SourceFormat::DOCX) return "Docx";
        if (value == aspose::words::cloud::models::Document::SourceFormat::DOCM) return "Docm";
        if (value == aspose::words::cloud::models::Document::SourceFormat::DOTX) return "Dotx";
        if (value == aspose::words::cloud::models::Document::SourceFormat::DOTM) return "Dotm";
        if (value == aspose::words::cloud::models::Document::SourceFormat::FLAT_OPC) return "FlatOpc";
        if (value == aspose::words::cloud::models::Document::SourceFormat::RTF) return "Rtf";
        if (value == aspose::words::cloud::models::Document::SourceFormat::WORD_ML) return "WordML";
        if (value == aspose::words::cloud::models::Document::SourceFormat::HTML) return "Html";
        if (value == aspose::words::cloud::models::Document::SourceFormat::MHTML) return "Mhtml";
        if (value == aspose::words::cloud::models::Document::SourceFormat::EPUB) return "Epub";
        if (value == aspose::words::cloud::models::Document::SourceFormat::TEXT) return "Text";
        if (value == aspose::words::cloud::models::Document::SourceFormat::ODT) return "Odt";
        if (value == aspose::words::cloud::models::Document::SourceFormat::OTT) return "Ott";
        if (value == aspose::words::cloud::models::Document::SourceFormat::PDF) return "Pdf";
        if (value == aspose::words::cloud::models::Document::SourceFormat::XPS) return "Xps";
        if (value == aspose::words::cloud::models::Document::SourceFormat::TIFF) return "Tiff";
        if (value == aspose::words::cloud::models::Document::SourceFormat::SVG) return "Svg";
        if (value == aspose::words::cloud::models::Document::SourceFormat::AZW3) return "Azw3";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::Document::SourceFormat documentSourceFormatFromString(const std::string& value)
    {
        if (value == "Unknown") return aspose::words::cloud::models::Document::SourceFormat::UNKNOWN;
        if (value == "Doc") return aspose::words::cloud::models::Document::SourceFormat::DOC;
        if (value == "Dot") return aspose::words::cloud::models::Document::SourceFormat::DOT;
        if (value == "DocPreWord60") return aspose::words::cloud::models::Document::SourceFormat::DOC_PRE_WORD60;
        if (value == "Docx") return aspose::words::cloud::models::Document::SourceFormat::DOCX;
        if (value == "Docm") return aspose::words::cloud::models::Document::SourceFormat::DOCM;
        if (value == "Dotx") return aspose::words::cloud::models::Document::SourceFormat::DOTX;
        if (value == "Dotm") return aspose::words::cloud::models::Document::SourceFormat::DOTM;
        if (value == "FlatOpc") return aspose::words::cloud::models::Document::SourceFormat::FLAT_OPC;
        if (value == "Rtf") return aspose::words::cloud::models::Document::SourceFormat::RTF;
        if (value == "WordML") return aspose::words::cloud::models::Document::SourceFormat::WORD_ML;
        if (value == "Html") return aspose::words::cloud::models::Document::SourceFormat::HTML;
        if (value == "Mhtml") return aspose::words::cloud::models::Document::SourceFormat::MHTML;
        if (value == "Epub") return aspose::words::cloud::models::Document::SourceFormat::EPUB;
        if (value == "Text") return aspose::words::cloud::models::Document::SourceFormat::TEXT;
        if (value == "Odt") return aspose::words::cloud::models::Document::SourceFormat::ODT;
        if (value == "Ott") return aspose::words::cloud::models::Document::SourceFormat::OTT;
        if (value == "Pdf") return aspose::words::cloud::models::Document::SourceFormat::PDF;
        if (value == "Xps") return aspose::words::cloud::models::Document::SourceFormat::XPS;
        if (value == "Tiff") return aspose::words::cloud::models::Document::SourceFormat::TIFF;
        if (value == "Svg") return aspose::words::cloud::models::Document::SourceFormat::SVG;
        if (value == "Azw3") return aspose::words::cloud::models::Document::SourceFormat::AZW3;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void Document::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Links) {
            json["Links"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_Links)) {
                element->toJson(&json["Links"].emplace_back());
            }
        }
        if (this->m_DocumentProperties) {
            this->m_DocumentProperties->toJson(&json["DocumentProperties"]);
        }
        if (this->m_FileName) {
            json["FileName"] = convertUtf16(*(this->m_FileName));
        }
        if (this->m_IsEncrypted) {
            json["IsEncrypted"] = *(this->m_IsEncrypted);
        }
        if (this->m_IsSigned) {
            json["IsSigned"] = *(this->m_IsSigned);
        }
        if (this->m_SourceFormat) {
            json["SourceFormat"] = documentSourceFormatToString(*(this->m_SourceFormat));
        }
    }

    void Document::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Links") && !json["Links"].is_null()) {
            this->m_Links = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::Link>> >();
            for (auto& element : json["Links"]) {
                this->m_Links->emplace_back(createModelInstance< aspose::words::cloud::models::Link >(L"Link, _", element));
            }
        }
        if (json.contains("DocumentProperties") && !json["DocumentProperties"].is_null()) {
            this->m_DocumentProperties = createModelInstance< aspose::words::cloud::models::DocumentProperties >(L"DocumentProperties, _", json["DocumentProperties"]);
        }
        if (json.contains("FileName") && !json["FileName"].is_null()) {
            this->m_FileName = std::make_shared< std::wstring >(
                convertUtf8( json["FileName"].get< std::string >() )
            );
        }
        if (json.contains("IsEncrypted") && !json["IsEncrypted"].is_null()) {
            this->m_IsEncrypted = std::make_shared< bool >(
                json["IsEncrypted"].get< bool >()
            );
        }
        if (json.contains("IsSigned") && !json["IsSigned"].is_null()) {
            this->m_IsSigned = std::make_shared< bool >(
                json["IsSigned"].get< bool >()
            );
        }
        if (json.contains("SourceFormat") && !json["SourceFormat"].is_null()) {
            this->m_SourceFormat = std::make_shared< aspose::words::cloud::models::Document::SourceFormat >(
                documentSourceFormatFromString(json["SourceFormat"].get< std::string >())
            );
        }
    }

    void Document::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Document::validate()
    {
        if (this->m_IsEncrypted == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property IsEncrypted in Document is required.");
        }

        if (this->m_IsSigned == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property IsSigned in Document is required.");
        }

        if (this->m_SourceFormat == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property SourceFormat in Document is required.");
        }


        if (this->m_Links != nullptr)
        {
            for (auto& elementLinks : *(this->m_Links))
            {
                if (elementLinks != nullptr)
                {
                    elementLinks->validate();
                }
            }
        }



        if (this->m_DocumentProperties != nullptr)
        {
            this->m_DocumentProperties->validate();
        }





    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Link>> > Document::getLinks() const
    {
        return this->m_Links;
    }

    void Document::setLinks(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Link>> > value)
    {
        this->m_Links = value;
    }


    std::shared_ptr< aspose::words::cloud::models::DocumentProperties > Document::getDocumentProperties() const
    {
        return this->m_DocumentProperties;
    }

    void Document::setDocumentProperties(std::shared_ptr< aspose::words::cloud::models::DocumentProperties > value)
    {
        this->m_DocumentProperties = value;
    }


    std::shared_ptr< std::wstring > Document::getFileName() const
    {
        return this->m_FileName;
    }

    void Document::setFileName(std::shared_ptr< std::wstring > value)
    {
        this->m_FileName = value;
    }


    std::shared_ptr< bool > Document::getIsEncrypted() const
    {
        return this->m_IsEncrypted;
    }

    void Document::setIsEncrypted(std::shared_ptr< bool > value)
    {
        this->m_IsEncrypted = value;
    }


    std::shared_ptr< bool > Document::getIsSigned() const
    {
        return this->m_IsSigned;
    }

    void Document::setIsSigned(std::shared_ptr< bool > value)
    {
        this->m_IsSigned = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Document::SourceFormat > Document::getSourceFormat() const
    {
        return this->m_SourceFormat;
    }

    void Document::setSourceFormat(std::shared_ptr< aspose::words::cloud::models::Document::SourceFormat > value)
    {
        this->m_SourceFormat = value;
    }



    /*
     * DocumentEntry implementation
     */
    inline std::string documentEntryImportFormatModeToString(aspose::words::cloud::models::DocumentEntry::ImportFormatMode value)
    {
        if (value == aspose::words::cloud::models::DocumentEntry::ImportFormatMode::USE_DESTINATION_STYLES) return "UseDestinationStyles";
        if (value == aspose::words::cloud::models::DocumentEntry::ImportFormatMode::KEEP_SOURCE_FORMATTING) return "KeepSourceFormatting";
        if (value == aspose::words::cloud::models::DocumentEntry::ImportFormatMode::KEEP_DIFFERENT_STYLES) return "KeepDifferentStyles";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::DocumentEntry::ImportFormatMode documentEntryImportFormatModeFromString(const std::string& value)
    {
        if (value == "UseDestinationStyles") return aspose::words::cloud::models::DocumentEntry::ImportFormatMode::USE_DESTINATION_STYLES;
        if (value == "KeepSourceFormatting") return aspose::words::cloud::models::DocumentEntry::ImportFormatMode::KEEP_SOURCE_FORMATTING;
        if (value == "KeepDifferentStyles") return aspose::words::cloud::models::DocumentEntry::ImportFormatMode::KEEP_DIFFERENT_STYLES;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void DocumentEntry::toJson(void* jsonIfc) const
    {
        BaseEntry::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_EncryptedPassword) {
            json["EncryptedPassword"] = convertUtf16(*(this->m_EncryptedPassword));
        }
        if (this->m_ImportFormatMode) {
            json["ImportFormatMode"] = documentEntryImportFormatModeToString(*(this->m_ImportFormatMode));
        }
    }

    void DocumentEntry::fromJson(const void* jsonIfc)
    {
        BaseEntry::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("EncryptedPassword") && !json["EncryptedPassword"].is_null()) {
            this->m_EncryptedPassword = std::make_shared< std::wstring >(
                convertUtf8( json["EncryptedPassword"].get< std::string >() )
            );
        }
        if (json.contains("ImportFormatMode") && !json["ImportFormatMode"].is_null()) {
            this->m_ImportFormatMode = std::make_shared< aspose::words::cloud::models::DocumentEntry::ImportFormatMode >(
                documentEntryImportFormatModeFromString(json["ImportFormatMode"].get< std::string >())
            );
        }
    }

    void DocumentEntry::getFileReferences(std::vector< FileReference* >& result)
    {
        BaseEntry::getFileReferences(result);
    }

    void DocumentEntry::validate()
    {
        BaseEntry::validate();
        if (this->m_ImportFormatMode == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property ImportFormatMode in DocumentEntry is required.");
        }

    }

    std::shared_ptr< std::wstring > DocumentEntry::getEncryptedPassword() const
    {
        return this->m_EncryptedPassword;
    }

    void DocumentEntry::setEncryptedPassword(std::shared_ptr< std::wstring > value)
    {
        this->m_EncryptedPassword = value;
    }


    std::shared_ptr< aspose::words::cloud::models::DocumentEntry::ImportFormatMode > DocumentEntry::getImportFormatMode() const
    {
        return this->m_ImportFormatMode;
    }

    void DocumentEntry::setImportFormatMode(std::shared_ptr< aspose::words::cloud::models::DocumentEntry::ImportFormatMode > value)
    {
        this->m_ImportFormatMode = value;
    }



    /*
     * DocumentEntryList implementation
     */
    void DocumentEntryList::toJson(void* jsonIfc) const
    {
        BaseEntryList::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ApplyBaseDocumentHeadersAndFootersToAppendingDocuments) {
            json["ApplyBaseDocumentHeadersAndFootersToAppendingDocuments"] = *(this->m_ApplyBaseDocumentHeadersAndFootersToAppendingDocuments);
        }
        if (this->m_DocumentEntries) {
            json["DocumentEntries"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_DocumentEntries)) {
                element->toJson(&json["DocumentEntries"].emplace_back());
            }
        }
    }

    void DocumentEntryList::fromJson(const void* jsonIfc)
    {
        BaseEntryList::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ApplyBaseDocumentHeadersAndFootersToAppendingDocuments") && !json["ApplyBaseDocumentHeadersAndFootersToAppendingDocuments"].is_null()) {
            this->m_ApplyBaseDocumentHeadersAndFootersToAppendingDocuments = std::make_shared< bool >(
                json["ApplyBaseDocumentHeadersAndFootersToAppendingDocuments"].get< bool >()
            );
        }
        if (json.contains("DocumentEntries") && !json["DocumentEntries"].is_null()) {
            this->m_DocumentEntries = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::DocumentEntry>> >();
            for (auto& element : json["DocumentEntries"]) {
                this->m_DocumentEntries->emplace_back(createModelInstance< aspose::words::cloud::models::DocumentEntry >(L"DocumentEntry, _", element));
            }
        }
    }

    void DocumentEntryList::getFileReferences(std::vector< FileReference* >& result)
    {
        BaseEntryList::getFileReferences(result);
        if (getDocumentEntries() != nullptr)
        {
            for (auto& element : *getDocumentEntries())
            {
                element->getFileReferences(result);
            }
        }

    }

    void DocumentEntryList::validate()
    {
        BaseEntryList::validate();
        if (this->m_DocumentEntries == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property DocumentEntries in DocumentEntryList is required.");
        }

        for (auto& elementDocumentEntries : *(this->m_DocumentEntries))
        {
            if (elementDocumentEntries != nullptr)
            {
                elementDocumentEntries->validate();
            }
        }


        if (this->m_DocumentEntries != nullptr)
        {
            for (auto& elementDocumentEntries : *(this->m_DocumentEntries))
            {
                if (elementDocumentEntries != nullptr)
                {
                    elementDocumentEntries->validate();
                }
            }
        }

    }

    std::shared_ptr< bool > DocumentEntryList::getApplyBaseDocumentHeadersAndFootersToAppendingDocuments() const
    {
        return this->m_ApplyBaseDocumentHeadersAndFootersToAppendingDocuments;
    }

    void DocumentEntryList::setApplyBaseDocumentHeadersAndFootersToAppendingDocuments(std::shared_ptr< bool > value)
    {
        this->m_ApplyBaseDocumentHeadersAndFootersToAppendingDocuments = value;
    }


    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::DocumentEntry>> > DocumentEntryList::getDocumentEntries() const
    {
        return this->m_DocumentEntries;
    }

    void DocumentEntryList::setDocumentEntries(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::DocumentEntry>> > value)
    {
        this->m_DocumentEntries = value;
    }



    /*
     * DocumentPosition implementation
     */
    void DocumentPosition::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Node) {
            this->m_Node->toJson(&json["Node"]);
        }
        if (this->m_Offset) {
            json["Offset"] = *(this->m_Offset);
        }
    }

    void DocumentPosition::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Node") && !json["Node"].is_null()) {
            this->m_Node = createModelInstance< aspose::words::cloud::models::NodeLink >(L"NodeLink, _", json["Node"]);
        }
        if (json.contains("Offset") && !json["Offset"].is_null()) {
            this->m_Offset = std::make_shared< int32_t >(
                json["Offset"].get< int32_t >()
            );
        }
    }

    void DocumentPosition::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DocumentPosition::validate()
    {

        if (this->m_Node != nullptr)
        {
            this->m_Node->validate();
        }


    }

    std::shared_ptr< aspose::words::cloud::models::NodeLink > DocumentPosition::getNode() const
    {
        return this->m_Node;
    }

    void DocumentPosition::setNode(std::shared_ptr< aspose::words::cloud::models::NodeLink > value)
    {
        this->m_Node = value;
    }


    std::shared_ptr< int32_t > DocumentPosition::getOffset() const
    {
        return this->m_Offset;
    }

    void DocumentPosition::setOffset(std::shared_ptr< int32_t > value)
    {
        this->m_Offset = value;
    }



    /*
     * DocumentProperties implementation
     */
    void DocumentProperties::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_List) {
            json["List"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_List)) {
                element->toJson(&json["List"].emplace_back());
            }
        }
    }

    void DocumentProperties::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("List") && !json["List"].is_null()) {
            this->m_List = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::DocumentProperty>> >();
            for (auto& element : json["List"]) {
                this->m_List->emplace_back(createModelInstance< aspose::words::cloud::models::DocumentProperty >(L"DocumentProperty, _", element));
            }
        }
    }

    void DocumentProperties::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DocumentProperties::validate()
    {
        LinkElement::validate();

        if (this->m_List != nullptr)
        {
            for (auto& elementList : *(this->m_List))
            {
                if (elementList != nullptr)
                {
                    elementList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::DocumentProperty>> > DocumentProperties::getList() const
    {
        return this->m_List;
    }

    void DocumentProperties::setList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::DocumentProperty>> > value)
    {
        this->m_List = value;
    }



    /*
     * DocumentPropertiesResponse implementation
     */
    void DocumentPropertiesResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_DocumentProperties) {
            this->m_DocumentProperties->toJson(&json["DocumentProperties"]);
        }
    }

    void DocumentPropertiesResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("DocumentProperties") && !json["DocumentProperties"].is_null()) {
            this->m_DocumentProperties = createModelInstance< aspose::words::cloud::models::DocumentProperties >(L"DocumentProperties, _", json["DocumentProperties"]);
        }
    }

    void DocumentPropertiesResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DocumentPropertiesResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_DocumentProperties != nullptr)
        {
            this->m_DocumentProperties->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::DocumentProperties > DocumentPropertiesResponse::getDocumentProperties() const
    {
        return this->m_DocumentProperties;
    }

    void DocumentPropertiesResponse::setDocumentProperties(std::shared_ptr< aspose::words::cloud::models::DocumentProperties > value)
    {
        this->m_DocumentProperties = value;
    }



    /*
     * DocumentProperty implementation
     */
    void DocumentProperty::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Name) {
            json["Name"] = convertUtf16(*(this->m_Name));
        }
        if (this->m_Value) {
            json["Value"] = convertUtf16(*(this->m_Value));
        }
        if (this->m_BuiltIn) {
            json["BuiltIn"] = *(this->m_BuiltIn);
        }
    }

    void DocumentProperty::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Name") && !json["Name"].is_null()) {
            this->m_Name = std::make_shared< std::wstring >(
                convertUtf8( json["Name"].get< std::string >() )
            );
        }
        if (json.contains("Value") && !json["Value"].is_null()) {
            this->m_Value = std::make_shared< std::wstring >(
                convertUtf8( json["Value"].get< std::string >() )
            );
        }
        if (json.contains("BuiltIn") && !json["BuiltIn"].is_null()) {
            this->m_BuiltIn = std::make_shared< bool >(
                json["BuiltIn"].get< bool >()
            );
        }
    }

    void DocumentProperty::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DocumentProperty::validate()
    {
        LinkElement::validate();
        if (this->m_BuiltIn == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property BuiltIn in DocumentProperty is required.");
        }

    }

    std::shared_ptr< std::wstring > DocumentProperty::getName() const
    {
        return this->m_Name;
    }

    void DocumentProperty::setName(std::shared_ptr< std::wstring > value)
    {
        this->m_Name = value;
    }


    std::shared_ptr< std::wstring > DocumentProperty::getValue() const
    {
        return this->m_Value;
    }

    void DocumentProperty::setValue(std::shared_ptr< std::wstring > value)
    {
        this->m_Value = value;
    }


    std::shared_ptr< bool > DocumentProperty::getBuiltIn() const
    {
        return this->m_BuiltIn;
    }

    void DocumentProperty::setBuiltIn(std::shared_ptr< bool > value)
    {
        this->m_BuiltIn = value;
    }



    /*
     * DocumentPropertyCreateOrUpdate implementation
     */
    void DocumentPropertyCreateOrUpdate::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Value) {
            json["Value"] = convertUtf16(*(this->m_Value));
        }
    }

    void DocumentPropertyCreateOrUpdate::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Value") && !json["Value"].is_null()) {
            this->m_Value = std::make_shared< std::wstring >(
                convertUtf8( json["Value"].get< std::string >() )
            );
        }
    }

    void DocumentPropertyCreateOrUpdate::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DocumentPropertyCreateOrUpdate::validate()
    {
        if (this->m_Value == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Value in DocumentPropertyCreateOrUpdate is required.");
        }

    }

    std::shared_ptr< std::wstring > DocumentPropertyCreateOrUpdate::getValue() const
    {
        return this->m_Value;
    }

    void DocumentPropertyCreateOrUpdate::setValue(std::shared_ptr< std::wstring > value)
    {
        this->m_Value = value;
    }



    /*
     * DocumentPropertyResponse implementation
     */
    void DocumentPropertyResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_DocumentProperty) {
            this->m_DocumentProperty->toJson(&json["DocumentProperty"]);
        }
    }

    void DocumentPropertyResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("DocumentProperty") && !json["DocumentProperty"].is_null()) {
            this->m_DocumentProperty = createModelInstance< aspose::words::cloud::models::DocumentProperty >(L"DocumentProperty, _", json["DocumentProperty"]);
        }
    }

    void DocumentPropertyResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DocumentPropertyResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_DocumentProperty != nullptr)
        {
            this->m_DocumentProperty->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::DocumentProperty > DocumentPropertyResponse::getDocumentProperty() const
    {
        return this->m_DocumentProperty;
    }

    void DocumentPropertyResponse::setDocumentProperty(std::shared_ptr< aspose::words::cloud::models::DocumentProperty > value)
    {
        this->m_DocumentProperty = value;
    }



    /*
     * DocumentResponse implementation
     */
    void DocumentResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Document) {
            this->m_Document->toJson(&json["Document"]);
        }
    }

    void DocumentResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Document") && !json["Document"].is_null()) {
            this->m_Document = createModelInstance< aspose::words::cloud::models::Document >(L"Document, _", json["Document"]);
        }
    }

    void DocumentResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DocumentResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Document != nullptr)
        {
            this->m_Document->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Document > DocumentResponse::getDocument() const
    {
        return this->m_Document;
    }

    void DocumentResponse::setDocument(std::shared_ptr< aspose::words::cloud::models::Document > value)
    {
        this->m_Document = value;
    }



    /*
     * DocumentStatData implementation
     */
    void DocumentStatData::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_FootnotesStatData) {
            this->m_FootnotesStatData->toJson(&json["FootnotesStatData"]);
        }
        if (this->m_PageCount) {
            json["PageCount"] = *(this->m_PageCount);
        }
        if (this->m_ParagraphCount) {
            json["ParagraphCount"] = *(this->m_ParagraphCount);
        }
        if (this->m_WordCount) {
            json["WordCount"] = *(this->m_WordCount);
        }
        if (this->m_PageStatData) {
            json["PageStatData"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_PageStatData)) {
                element->toJson(&json["PageStatData"].emplace_back());
            }
        }
    }

    void DocumentStatData::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("FootnotesStatData") && !json["FootnotesStatData"].is_null()) {
            this->m_FootnotesStatData = createModelInstance< aspose::words::cloud::models::FootnotesStatData >(L"FootnotesStatData, _", json["FootnotesStatData"]);
        }
        if (json.contains("PageCount") && !json["PageCount"].is_null()) {
            this->m_PageCount = std::make_shared< int32_t >(
                json["PageCount"].get< int32_t >()
            );
        }
        if (json.contains("ParagraphCount") && !json["ParagraphCount"].is_null()) {
            this->m_ParagraphCount = std::make_shared< int32_t >(
                json["ParagraphCount"].get< int32_t >()
            );
        }
        if (json.contains("WordCount") && !json["WordCount"].is_null()) {
            this->m_WordCount = std::make_shared< int32_t >(
                json["WordCount"].get< int32_t >()
            );
        }
        if (json.contains("PageStatData") && !json["PageStatData"].is_null()) {
            this->m_PageStatData = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::PageStatData>> >();
            for (auto& element : json["PageStatData"]) {
                this->m_PageStatData->emplace_back(createModelInstance< aspose::words::cloud::models::PageStatData >(L"PageStatData, _", element));
            }
        }
    }

    void DocumentStatData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DocumentStatData::validate()
    {
        if (this->m_PageCount == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property PageCount in DocumentStatData is required.");
        }

        if (this->m_ParagraphCount == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property ParagraphCount in DocumentStatData is required.");
        }

        if (this->m_WordCount == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property WordCount in DocumentStatData is required.");
        }


        if (this->m_FootnotesStatData != nullptr)
        {
            this->m_FootnotesStatData->validate();
        }






        if (this->m_PageStatData != nullptr)
        {
            for (auto& elementPageStatData : *(this->m_PageStatData))
            {
                if (elementPageStatData != nullptr)
                {
                    elementPageStatData->validate();
                }
            }
        }

    }

    std::shared_ptr< aspose::words::cloud::models::FootnotesStatData > DocumentStatData::getFootnotesStatData() const
    {
        return this->m_FootnotesStatData;
    }

    void DocumentStatData::setFootnotesStatData(std::shared_ptr< aspose::words::cloud::models::FootnotesStatData > value)
    {
        this->m_FootnotesStatData = value;
    }


    std::shared_ptr< int32_t > DocumentStatData::getPageCount() const
    {
        return this->m_PageCount;
    }

    void DocumentStatData::setPageCount(std::shared_ptr< int32_t > value)
    {
        this->m_PageCount = value;
    }


    std::shared_ptr< int32_t > DocumentStatData::getParagraphCount() const
    {
        return this->m_ParagraphCount;
    }

    void DocumentStatData::setParagraphCount(std::shared_ptr< int32_t > value)
    {
        this->m_ParagraphCount = value;
    }


    std::shared_ptr< int32_t > DocumentStatData::getWordCount() const
    {
        return this->m_WordCount;
    }

    void DocumentStatData::setWordCount(std::shared_ptr< int32_t > value)
    {
        this->m_WordCount = value;
    }


    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::PageStatData>> > DocumentStatData::getPageStatData() const
    {
        return this->m_PageStatData;
    }

    void DocumentStatData::setPageStatData(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::PageStatData>> > value)
    {
        this->m_PageStatData = value;
    }



    /*
     * DocxSaveOptionsData implementation
     */
    void DocxSaveOptionsData::toJson(void* jsonIfc) const
    {
        OoxmlSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void DocxSaveOptionsData::fromJson(const void* jsonIfc)
    {
        OoxmlSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void DocxSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DocxSaveOptionsData::validate()
    {
        OoxmlSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > DocxSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * DotmSaveOptionsData implementation
     */
    void DotmSaveOptionsData::toJson(void* jsonIfc) const
    {
        OoxmlSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void DotmSaveOptionsData::fromJson(const void* jsonIfc)
    {
        OoxmlSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void DotmSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DotmSaveOptionsData::validate()
    {
        OoxmlSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > DotmSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * DotSaveOptionsData implementation
     */
    void DotSaveOptionsData::toJson(void* jsonIfc) const
    {
        DocSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void DotSaveOptionsData::fromJson(const void* jsonIfc)
    {
        DocSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void DotSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DotSaveOptionsData::validate()
    {
        DocSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > DotSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * DotxSaveOptionsData implementation
     */
    void DotxSaveOptionsData::toJson(void* jsonIfc) const
    {
        OoxmlSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void DotxSaveOptionsData::fromJson(const void* jsonIfc)
    {
        OoxmlSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void DotxSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DotxSaveOptionsData::validate()
    {
        OoxmlSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > DotxSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * DownsampleOptionsData implementation
     */
    void DownsampleOptionsData::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_DownsampleImages) {
            json["DownsampleImages"] = *(this->m_DownsampleImages);
        }
        if (this->m_Resolution) {
            json["Resolution"] = *(this->m_Resolution);
        }
        if (this->m_ResolutionThreshold) {
            json["ResolutionThreshold"] = *(this->m_ResolutionThreshold);
        }
    }

    void DownsampleOptionsData::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("DownsampleImages") && !json["DownsampleImages"].is_null()) {
            this->m_DownsampleImages = std::make_shared< bool >(
                json["DownsampleImages"].get< bool >()
            );
        }
        if (json.contains("Resolution") && !json["Resolution"].is_null()) {
            this->m_Resolution = std::make_shared< int32_t >(
                json["Resolution"].get< int32_t >()
            );
        }
        if (json.contains("ResolutionThreshold") && !json["ResolutionThreshold"].is_null()) {
            this->m_ResolutionThreshold = std::make_shared< int32_t >(
                json["ResolutionThreshold"].get< int32_t >()
            );
        }
    }

    void DownsampleOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DownsampleOptionsData::validate()
    {
    }

    std::shared_ptr< bool > DownsampleOptionsData::getDownsampleImages() const
    {
        return this->m_DownsampleImages;
    }

    void DownsampleOptionsData::setDownsampleImages(std::shared_ptr< bool > value)
    {
        this->m_DownsampleImages = value;
    }


    std::shared_ptr< int32_t > DownsampleOptionsData::getResolution() const
    {
        return this->m_Resolution;
    }

    void DownsampleOptionsData::setResolution(std::shared_ptr< int32_t > value)
    {
        this->m_Resolution = value;
    }


    std::shared_ptr< int32_t > DownsampleOptionsData::getResolutionThreshold() const
    {
        return this->m_ResolutionThreshold;
    }

    void DownsampleOptionsData::setResolutionThreshold(std::shared_ptr< int32_t > value)
    {
        this->m_ResolutionThreshold = value;
    }



    /*
     * DrawingObject implementation
     */
    inline std::string drawingObjectRelativeHorizontalPositionToString(aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition value)
    {
        if (value == aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::MARGIN) return "Margin";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::PAGE) return "Page";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::COLUMN) return "Column";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::DEFAULT) return "Default";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::CHARACTER) return "Character";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::LEFT_MARGIN) return "LeftMargin";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::RIGHT_MARGIN) return "RightMargin";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::INSIDE_MARGIN) return "InsideMargin";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::OUTSIDE_MARGIN) return "OutsideMargin";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition drawingObjectRelativeHorizontalPositionFromString(const std::string& value)
    {
        if (value == "Margin") return aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::MARGIN;
        if (value == "Page") return aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::PAGE;
        if (value == "Column") return aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::COLUMN;
        if (value == "Default") return aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::DEFAULT;
        if (value == "Character") return aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::CHARACTER;
        if (value == "LeftMargin") return aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::LEFT_MARGIN;
        if (value == "RightMargin") return aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::RIGHT_MARGIN;
        if (value == "InsideMargin") return aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::INSIDE_MARGIN;
        if (value == "OutsideMargin") return aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition::OUTSIDE_MARGIN;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string drawingObjectRelativeVerticalPositionToString(aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition value)
    {
        if (value == aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::MARGIN) return "Margin";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::TABLE_DEFAULT) return "TableDefault";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::PAGE) return "Page";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::PARAGRAPH) return "Paragraph";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::TEXT_FRAME_DEFAULT) return "TextFrameDefault";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::LINE) return "Line";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::TOP_MARGIN) return "TopMargin";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::BOTTOM_MARGIN) return "BottomMargin";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::INSIDE_MARGIN) return "InsideMargin";
        if (value == aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::OUTSIDE_MARGIN) return "OutsideMargin";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition drawingObjectRelativeVerticalPositionFromString(const std::string& value)
    {
        if (value == "Margin") return aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::MARGIN;
        if (value == "TableDefault") return aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::TABLE_DEFAULT;
        if (value == "Page") return aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::PAGE;
        if (value == "Paragraph") return aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::PARAGRAPH;
        if (value == "TextFrameDefault") return aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::TEXT_FRAME_DEFAULT;
        if (value == "Line") return aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::LINE;
        if (value == "TopMargin") return aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::TOP_MARGIN;
        if (value == "BottomMargin") return aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::BOTTOM_MARGIN;
        if (value == "InsideMargin") return aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::INSIDE_MARGIN;
        if (value == "OutsideMargin") return aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition::OUTSIDE_MARGIN;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string drawingObjectWrapTypeToString(aspose::words::cloud::models::DrawingObject::WrapType value)
    {
        if (value == aspose::words::cloud::models::DrawingObject::WrapType::INLINE) return "Inline";
        if (value == aspose::words::cloud::models::DrawingObject::WrapType::TOP_BOTTOM) return "TopBottom";
        if (value == aspose::words::cloud::models::DrawingObject::WrapType::SQUARE) return "Square";
        if (value == aspose::words::cloud::models::DrawingObject::WrapType::NONE) return "None";
        if (value == aspose::words::cloud::models::DrawingObject::WrapType::TIGHT) return "Tight";
        if (value == aspose::words::cloud::models::DrawingObject::WrapType::THROUGH) return "Through";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::DrawingObject::WrapType drawingObjectWrapTypeFromString(const std::string& value)
    {
        if (value == "Inline") return aspose::words::cloud::models::DrawingObject::WrapType::INLINE;
        if (value == "TopBottom") return aspose::words::cloud::models::DrawingObject::WrapType::TOP_BOTTOM;
        if (value == "Square") return aspose::words::cloud::models::DrawingObject::WrapType::SQUARE;
        if (value == "None") return aspose::words::cloud::models::DrawingObject::WrapType::NONE;
        if (value == "Tight") return aspose::words::cloud::models::DrawingObject::WrapType::TIGHT;
        if (value == "Through") return aspose::words::cloud::models::DrawingObject::WrapType::THROUGH;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void DrawingObject::toJson(void* jsonIfc) const
    {
        DrawingObjectLink::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_RenderLinks) {
            json["RenderLinks"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_RenderLinks)) {
                element->toJson(&json["RenderLinks"].emplace_back());
            }
        }
        if (this->m_Width) {
            json["Width"] = *(this->m_Width);
        }
        if (this->m_Height) {
            json["Height"] = *(this->m_Height);
        }
        if (this->m_OleDataLink) {
            this->m_OleDataLink->toJson(&json["OleDataLink"]);
        }
        if (this->m_ImageDataLink) {
            this->m_ImageDataLink->toJson(&json["ImageDataLink"]);
        }
        if (this->m_RelativeHorizontalPosition) {
            json["RelativeHorizontalPosition"] = drawingObjectRelativeHorizontalPositionToString(*(this->m_RelativeHorizontalPosition));
        }
        if (this->m_Left) {
            json["Left"] = *(this->m_Left);
        }
        if (this->m_RelativeVerticalPosition) {
            json["RelativeVerticalPosition"] = drawingObjectRelativeVerticalPositionToString(*(this->m_RelativeVerticalPosition));
        }
        if (this->m_Top) {
            json["Top"] = *(this->m_Top);
        }
        if (this->m_WrapType) {
            json["WrapType"] = drawingObjectWrapTypeToString(*(this->m_WrapType));
        }
    }

    void DrawingObject::fromJson(const void* jsonIfc)
    {
        DrawingObjectLink::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("RenderLinks") && !json["RenderLinks"].is_null()) {
            this->m_RenderLinks = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::WordsApiLink>> >();
            for (auto& element : json["RenderLinks"]) {
                this->m_RenderLinks->emplace_back(createModelInstance< aspose::words::cloud::models::WordsApiLink >(L"WordsApiLink, _", element));
            }
        }
        if (json.contains("Width") && !json["Width"].is_null()) {
            this->m_Width = std::make_shared< double >(
                json["Width"].get< double >()
            );
        }
        if (json.contains("Height") && !json["Height"].is_null()) {
            this->m_Height = std::make_shared< double >(
                json["Height"].get< double >()
            );
        }
        if (json.contains("OleDataLink") && !json["OleDataLink"].is_null()) {
            this->m_OleDataLink = createModelInstance< aspose::words::cloud::models::WordsApiLink >(L"WordsApiLink, _", json["OleDataLink"]);
        }
        if (json.contains("ImageDataLink") && !json["ImageDataLink"].is_null()) {
            this->m_ImageDataLink = createModelInstance< aspose::words::cloud::models::WordsApiLink >(L"WordsApiLink, _", json["ImageDataLink"]);
        }
        if (json.contains("RelativeHorizontalPosition") && !json["RelativeHorizontalPosition"].is_null()) {
            this->m_RelativeHorizontalPosition = std::make_shared< aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition >(
                drawingObjectRelativeHorizontalPositionFromString(json["RelativeHorizontalPosition"].get< std::string >())
            );
        }
        if (json.contains("Left") && !json["Left"].is_null()) {
            this->m_Left = std::make_shared< double >(
                json["Left"].get< double >()
            );
        }
        if (json.contains("RelativeVerticalPosition") && !json["RelativeVerticalPosition"].is_null()) {
            this->m_RelativeVerticalPosition = std::make_shared< aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition >(
                drawingObjectRelativeVerticalPositionFromString(json["RelativeVerticalPosition"].get< std::string >())
            );
        }
        if (json.contains("Top") && !json["Top"].is_null()) {
            this->m_Top = std::make_shared< double >(
                json["Top"].get< double >()
            );
        }
        if (json.contains("WrapType") && !json["WrapType"].is_null()) {
            this->m_WrapType = std::make_shared< aspose::words::cloud::models::DrawingObject::WrapType >(
                drawingObjectWrapTypeFromString(json["WrapType"].get< std::string >())
            );
        }
    }

    void DrawingObject::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DrawingObject::validate()
    {
        DrawingObjectLink::validate();

        if (this->m_RenderLinks != nullptr)
        {
            for (auto& elementRenderLinks : *(this->m_RenderLinks))
            {
                if (elementRenderLinks != nullptr)
                {
                    elementRenderLinks->validate();
                }
            }
        }





        if (this->m_OleDataLink != nullptr)
        {
            this->m_OleDataLink->validate();
        }



        if (this->m_ImageDataLink != nullptr)
        {
            this->m_ImageDataLink->validate();
        }






    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::WordsApiLink>> > DrawingObject::getRenderLinks() const
    {
        return this->m_RenderLinks;
    }

    void DrawingObject::setRenderLinks(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::WordsApiLink>> > value)
    {
        this->m_RenderLinks = value;
    }


    std::shared_ptr< double > DrawingObject::getWidth() const
    {
        return this->m_Width;
    }

    void DrawingObject::setWidth(std::shared_ptr< double > value)
    {
        this->m_Width = value;
    }


    std::shared_ptr< double > DrawingObject::getHeight() const
    {
        return this->m_Height;
    }

    void DrawingObject::setHeight(std::shared_ptr< double > value)
    {
        this->m_Height = value;
    }


    std::shared_ptr< aspose::words::cloud::models::WordsApiLink > DrawingObject::getOleDataLink() const
    {
        return this->m_OleDataLink;
    }

    void DrawingObject::setOleDataLink(std::shared_ptr< aspose::words::cloud::models::WordsApiLink > value)
    {
        this->m_OleDataLink = value;
    }


    std::shared_ptr< aspose::words::cloud::models::WordsApiLink > DrawingObject::getImageDataLink() const
    {
        return this->m_ImageDataLink;
    }

    void DrawingObject::setImageDataLink(std::shared_ptr< aspose::words::cloud::models::WordsApiLink > value)
    {
        this->m_ImageDataLink = value;
    }


    std::shared_ptr< aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition > DrawingObject::getRelativeHorizontalPosition() const
    {
        return this->m_RelativeHorizontalPosition;
    }

    void DrawingObject::setRelativeHorizontalPosition(std::shared_ptr< aspose::words::cloud::models::DrawingObject::RelativeHorizontalPosition > value)
    {
        this->m_RelativeHorizontalPosition = value;
    }


    std::shared_ptr< double > DrawingObject::getLeft() const
    {
        return this->m_Left;
    }

    void DrawingObject::setLeft(std::shared_ptr< double > value)
    {
        this->m_Left = value;
    }


    std::shared_ptr< aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition > DrawingObject::getRelativeVerticalPosition() const
    {
        return this->m_RelativeVerticalPosition;
    }

    void DrawingObject::setRelativeVerticalPosition(std::shared_ptr< aspose::words::cloud::models::DrawingObject::RelativeVerticalPosition > value)
    {
        this->m_RelativeVerticalPosition = value;
    }


    std::shared_ptr< double > DrawingObject::getTop() const
    {
        return this->m_Top;
    }

    void DrawingObject::setTop(std::shared_ptr< double > value)
    {
        this->m_Top = value;
    }


    std::shared_ptr< aspose::words::cloud::models::DrawingObject::WrapType > DrawingObject::getWrapType() const
    {
        return this->m_WrapType;
    }

    void DrawingObject::setWrapType(std::shared_ptr< aspose::words::cloud::models::DrawingObject::WrapType > value)
    {
        this->m_WrapType = value;
    }



    /*
     * DrawingObjectCollection implementation
     */
    void DrawingObjectCollection::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_List) {
            json["List"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_List)) {
                element->toJson(&json["List"].emplace_back());
            }
        }
    }

    void DrawingObjectCollection::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("List") && !json["List"].is_null()) {
            this->m_List = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::LinkElement>> >();
            for (auto& element : json["List"]) {
                this->m_List->emplace_back(createModelInstance< aspose::words::cloud::models::LinkElement >(L"LinkElement, _", element));
            }
        }
    }

    void DrawingObjectCollection::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DrawingObjectCollection::validate()
    {
        LinkElement::validate();

        if (this->m_List != nullptr)
        {
            for (auto& elementList : *(this->m_List))
            {
                if (elementList != nullptr)
                {
                    elementList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::LinkElement>> > DrawingObjectCollection::getList() const
    {
        return this->m_List;
    }

    void DrawingObjectCollection::setList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::LinkElement>> > value)
    {
        this->m_List = value;
    }



    /*
     * DrawingObjectInsert implementation
     */
    inline std::string drawingObjectInsertRelativeHorizontalPositionToString(aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition value)
    {
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::MARGIN) return "Margin";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::PAGE) return "Page";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::COLUMN) return "Column";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::DEFAULT) return "Default";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::CHARACTER) return "Character";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::LEFT_MARGIN) return "LeftMargin";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::RIGHT_MARGIN) return "RightMargin";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::INSIDE_MARGIN) return "InsideMargin";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::OUTSIDE_MARGIN) return "OutsideMargin";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition drawingObjectInsertRelativeHorizontalPositionFromString(const std::string& value)
    {
        if (value == "Margin") return aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::MARGIN;
        if (value == "Page") return aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::PAGE;
        if (value == "Column") return aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::COLUMN;
        if (value == "Default") return aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::DEFAULT;
        if (value == "Character") return aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::CHARACTER;
        if (value == "LeftMargin") return aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::LEFT_MARGIN;
        if (value == "RightMargin") return aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::RIGHT_MARGIN;
        if (value == "InsideMargin") return aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::INSIDE_MARGIN;
        if (value == "OutsideMargin") return aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition::OUTSIDE_MARGIN;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string drawingObjectInsertRelativeVerticalPositionToString(aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition value)
    {
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::MARGIN) return "Margin";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::TABLE_DEFAULT) return "TableDefault";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::PAGE) return "Page";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::PARAGRAPH) return "Paragraph";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::TEXT_FRAME_DEFAULT) return "TextFrameDefault";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::LINE) return "Line";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::TOP_MARGIN) return "TopMargin";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::BOTTOM_MARGIN) return "BottomMargin";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::INSIDE_MARGIN) return "InsideMargin";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::OUTSIDE_MARGIN) return "OutsideMargin";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition drawingObjectInsertRelativeVerticalPositionFromString(const std::string& value)
    {
        if (value == "Margin") return aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::MARGIN;
        if (value == "TableDefault") return aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::TABLE_DEFAULT;
        if (value == "Page") return aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::PAGE;
        if (value == "Paragraph") return aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::PARAGRAPH;
        if (value == "TextFrameDefault") return aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::TEXT_FRAME_DEFAULT;
        if (value == "Line") return aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::LINE;
        if (value == "TopMargin") return aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::TOP_MARGIN;
        if (value == "BottomMargin") return aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::BOTTOM_MARGIN;
        if (value == "InsideMargin") return aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::INSIDE_MARGIN;
        if (value == "OutsideMargin") return aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition::OUTSIDE_MARGIN;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string drawingObjectInsertWrapTypeToString(aspose::words::cloud::models::DrawingObjectInsert::WrapType value)
    {
        if (value == aspose::words::cloud::models::DrawingObjectInsert::WrapType::INLINE) return "Inline";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::WrapType::TOP_BOTTOM) return "TopBottom";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::WrapType::SQUARE) return "Square";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::WrapType::NONE) return "None";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::WrapType::TIGHT) return "Tight";
        if (value == aspose::words::cloud::models::DrawingObjectInsert::WrapType::THROUGH) return "Through";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::DrawingObjectInsert::WrapType drawingObjectInsertWrapTypeFromString(const std::string& value)
    {
        if (value == "Inline") return aspose::words::cloud::models::DrawingObjectInsert::WrapType::INLINE;
        if (value == "TopBottom") return aspose::words::cloud::models::DrawingObjectInsert::WrapType::TOP_BOTTOM;
        if (value == "Square") return aspose::words::cloud::models::DrawingObjectInsert::WrapType::SQUARE;
        if (value == "None") return aspose::words::cloud::models::DrawingObjectInsert::WrapType::NONE;
        if (value == "Tight") return aspose::words::cloud::models::DrawingObjectInsert::WrapType::TIGHT;
        if (value == "Through") return aspose::words::cloud::models::DrawingObjectInsert::WrapType::THROUGH;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void DrawingObjectInsert::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Position) {
            this->m_Position->toJson(&json["Position"]);
        }
        if (this->m_RelativeHorizontalPosition) {
            json["RelativeHorizontalPosition"] = drawingObjectInsertRelativeHorizontalPositionToString(*(this->m_RelativeHorizontalPosition));
        }
        if (this->m_Left) {
            json["Left"] = *(this->m_Left);
        }
        if (this->m_RelativeVerticalPosition) {
            json["RelativeVerticalPosition"] = drawingObjectInsertRelativeVerticalPositionToString(*(this->m_RelativeVerticalPosition));
        }
        if (this->m_Top) {
            json["Top"] = *(this->m_Top);
        }
        if (this->m_Width) {
            json["Width"] = *(this->m_Width);
        }
        if (this->m_Height) {
            json["Height"] = *(this->m_Height);
        }
        if (this->m_WrapType) {
            json["WrapType"] = drawingObjectInsertWrapTypeToString(*(this->m_WrapType));
        }
        if (this->m_AspectRatioLocked) {
            json["AspectRatioLocked"] = *(this->m_AspectRatioLocked);
        }
    }

    void DrawingObjectInsert::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Position") && !json["Position"].is_null()) {
            this->m_Position = createModelInstance< aspose::words::cloud::models::Position >(L"Position, _", json["Position"]);
        }
        if (json.contains("RelativeHorizontalPosition") && !json["RelativeHorizontalPosition"].is_null()) {
            this->m_RelativeHorizontalPosition = std::make_shared< aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition >(
                drawingObjectInsertRelativeHorizontalPositionFromString(json["RelativeHorizontalPosition"].get< std::string >())
            );
        }
        if (json.contains("Left") && !json["Left"].is_null()) {
            this->m_Left = std::make_shared< double >(
                json["Left"].get< double >()
            );
        }
        if (json.contains("RelativeVerticalPosition") && !json["RelativeVerticalPosition"].is_null()) {
            this->m_RelativeVerticalPosition = std::make_shared< aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition >(
                drawingObjectInsertRelativeVerticalPositionFromString(json["RelativeVerticalPosition"].get< std::string >())
            );
        }
        if (json.contains("Top") && !json["Top"].is_null()) {
            this->m_Top = std::make_shared< double >(
                json["Top"].get< double >()
            );
        }
        if (json.contains("Width") && !json["Width"].is_null()) {
            this->m_Width = std::make_shared< double >(
                json["Width"].get< double >()
            );
        }
        if (json.contains("Height") && !json["Height"].is_null()) {
            this->m_Height = std::make_shared< double >(
                json["Height"].get< double >()
            );
        }
        if (json.contains("WrapType") && !json["WrapType"].is_null()) {
            this->m_WrapType = std::make_shared< aspose::words::cloud::models::DrawingObjectInsert::WrapType >(
                drawingObjectInsertWrapTypeFromString(json["WrapType"].get< std::string >())
            );
        }
        if (json.contains("AspectRatioLocked") && !json["AspectRatioLocked"].is_null()) {
            this->m_AspectRatioLocked = std::make_shared< bool >(
                json["AspectRatioLocked"].get< bool >()
            );
        }
    }

    void DrawingObjectInsert::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DrawingObjectInsert::validate()
    {
        if (this->m_RelativeHorizontalPosition == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property RelativeHorizontalPosition in DrawingObjectInsert is required.");
        }

        if (this->m_Left == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Left in DrawingObjectInsert is required.");
        }

        if (this->m_RelativeVerticalPosition == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property RelativeVerticalPosition in DrawingObjectInsert is required.");
        }

        if (this->m_Top == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Top in DrawingObjectInsert is required.");
        }

        if (this->m_Width == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Width in DrawingObjectInsert is required.");
        }

        if (this->m_Height == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Height in DrawingObjectInsert is required.");
        }

        if (this->m_WrapType == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property WrapType in DrawingObjectInsert is required.");
        }


        if (this->m_Position != nullptr)
        {
            this->m_Position->validate();
        }









    }

    std::shared_ptr< aspose::words::cloud::models::Position > DrawingObjectInsert::getPosition() const
    {
        return this->m_Position;
    }

    void DrawingObjectInsert::setPosition(std::shared_ptr< aspose::words::cloud::models::Position > value)
    {
        this->m_Position = value;
    }


    std::shared_ptr< aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition > DrawingObjectInsert::getRelativeHorizontalPosition() const
    {
        return this->m_RelativeHorizontalPosition;
    }

    void DrawingObjectInsert::setRelativeHorizontalPosition(std::shared_ptr< aspose::words::cloud::models::DrawingObjectInsert::RelativeHorizontalPosition > value)
    {
        this->m_RelativeHorizontalPosition = value;
    }


    std::shared_ptr< double > DrawingObjectInsert::getLeft() const
    {
        return this->m_Left;
    }

    void DrawingObjectInsert::setLeft(std::shared_ptr< double > value)
    {
        this->m_Left = value;
    }


    std::shared_ptr< aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition > DrawingObjectInsert::getRelativeVerticalPosition() const
    {
        return this->m_RelativeVerticalPosition;
    }

    void DrawingObjectInsert::setRelativeVerticalPosition(std::shared_ptr< aspose::words::cloud::models::DrawingObjectInsert::RelativeVerticalPosition > value)
    {
        this->m_RelativeVerticalPosition = value;
    }


    std::shared_ptr< double > DrawingObjectInsert::getTop() const
    {
        return this->m_Top;
    }

    void DrawingObjectInsert::setTop(std::shared_ptr< double > value)
    {
        this->m_Top = value;
    }


    std::shared_ptr< double > DrawingObjectInsert::getWidth() const
    {
        return this->m_Width;
    }

    void DrawingObjectInsert::setWidth(std::shared_ptr< double > value)
    {
        this->m_Width = value;
    }


    std::shared_ptr< double > DrawingObjectInsert::getHeight() const
    {
        return this->m_Height;
    }

    void DrawingObjectInsert::setHeight(std::shared_ptr< double > value)
    {
        this->m_Height = value;
    }


    std::shared_ptr< aspose::words::cloud::models::DrawingObjectInsert::WrapType > DrawingObjectInsert::getWrapType() const
    {
        return this->m_WrapType;
    }

    void DrawingObjectInsert::setWrapType(std::shared_ptr< aspose::words::cloud::models::DrawingObjectInsert::WrapType > value)
    {
        this->m_WrapType = value;
    }


    std::shared_ptr< bool > DrawingObjectInsert::getAspectRatioLocked() const
    {
        return this->m_AspectRatioLocked;
    }

    void DrawingObjectInsert::setAspectRatioLocked(std::shared_ptr< bool > value)
    {
        this->m_AspectRatioLocked = value;
    }



    /*
     * DrawingObjectLink implementation
     */
    void DrawingObjectLink::toJson(void* jsonIfc) const
    {
        NodeLink::toJson(jsonIfc);
    }

    void DrawingObjectLink::fromJson(const void* jsonIfc)
    {
        NodeLink::fromJson(jsonIfc);
    }

    void DrawingObjectLink::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DrawingObjectLink::validate()
    {
        NodeLink::validate();
    }




    /*
     * DrawingObjectResponse implementation
     */
    void DrawingObjectResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_DrawingObject) {
            this->m_DrawingObject->toJson(&json["DrawingObject"]);
        }
    }

    void DrawingObjectResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("DrawingObject") && !json["DrawingObject"].is_null()) {
            this->m_DrawingObject = createModelInstance< aspose::words::cloud::models::DrawingObject >(L"DrawingObject, _", json["DrawingObject"]);
        }
    }

    void DrawingObjectResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DrawingObjectResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_DrawingObject != nullptr)
        {
            this->m_DrawingObject->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::DrawingObject > DrawingObjectResponse::getDrawingObject() const
    {
        return this->m_DrawingObject;
    }

    void DrawingObjectResponse::setDrawingObject(std::shared_ptr< aspose::words::cloud::models::DrawingObject > value)
    {
        this->m_DrawingObject = value;
    }



    /*
     * DrawingObjectsResponse implementation
     */
    void DrawingObjectsResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_DrawingObjects) {
            this->m_DrawingObjects->toJson(&json["DrawingObjects"]);
        }
    }

    void DrawingObjectsResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("DrawingObjects") && !json["DrawingObjects"].is_null()) {
            this->m_DrawingObjects = createModelInstance< aspose::words::cloud::models::DrawingObjectCollection >(L"DrawingObjectCollection, _", json["DrawingObjects"]);
        }
    }

    void DrawingObjectsResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DrawingObjectsResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_DrawingObjects != nullptr)
        {
            this->m_DrawingObjects->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::DrawingObjectCollection > DrawingObjectsResponse::getDrawingObjects() const
    {
        return this->m_DrawingObjects;
    }

    void DrawingObjectsResponse::setDrawingObjects(std::shared_ptr< aspose::words::cloud::models::DrawingObjectCollection > value)
    {
        this->m_DrawingObjects = value;
    }



    /*
     * DrawingObjectUpdate implementation
     */
    inline std::string drawingObjectUpdateRelativeHorizontalPositionToString(aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition value)
    {
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::MARGIN) return "Margin";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::PAGE) return "Page";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::COLUMN) return "Column";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::DEFAULT) return "Default";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::CHARACTER) return "Character";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::LEFT_MARGIN) return "LeftMargin";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::RIGHT_MARGIN) return "RightMargin";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::INSIDE_MARGIN) return "InsideMargin";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::OUTSIDE_MARGIN) return "OutsideMargin";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition drawingObjectUpdateRelativeHorizontalPositionFromString(const std::string& value)
    {
        if (value == "Margin") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::MARGIN;
        if (value == "Page") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::PAGE;
        if (value == "Column") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::COLUMN;
        if (value == "Default") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::DEFAULT;
        if (value == "Character") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::CHARACTER;
        if (value == "LeftMargin") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::LEFT_MARGIN;
        if (value == "RightMargin") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::RIGHT_MARGIN;
        if (value == "InsideMargin") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::INSIDE_MARGIN;
        if (value == "OutsideMargin") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition::OUTSIDE_MARGIN;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string drawingObjectUpdateRelativeVerticalPositionToString(aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition value)
    {
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::MARGIN) return "Margin";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::TABLE_DEFAULT) return "TableDefault";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::PAGE) return "Page";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::PARAGRAPH) return "Paragraph";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::TEXT_FRAME_DEFAULT) return "TextFrameDefault";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::LINE) return "Line";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::TOP_MARGIN) return "TopMargin";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::BOTTOM_MARGIN) return "BottomMargin";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::INSIDE_MARGIN) return "InsideMargin";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::OUTSIDE_MARGIN) return "OutsideMargin";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition drawingObjectUpdateRelativeVerticalPositionFromString(const std::string& value)
    {
        if (value == "Margin") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::MARGIN;
        if (value == "TableDefault") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::TABLE_DEFAULT;
        if (value == "Page") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::PAGE;
        if (value == "Paragraph") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::PARAGRAPH;
        if (value == "TextFrameDefault") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::TEXT_FRAME_DEFAULT;
        if (value == "Line") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::LINE;
        if (value == "TopMargin") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::TOP_MARGIN;
        if (value == "BottomMargin") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::BOTTOM_MARGIN;
        if (value == "InsideMargin") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::INSIDE_MARGIN;
        if (value == "OutsideMargin") return aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition::OUTSIDE_MARGIN;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string drawingObjectUpdateWrapTypeToString(aspose::words::cloud::models::DrawingObjectUpdate::WrapType value)
    {
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::WrapType::INLINE) return "Inline";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::WrapType::TOP_BOTTOM) return "TopBottom";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::WrapType::SQUARE) return "Square";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::WrapType::NONE) return "None";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::WrapType::TIGHT) return "Tight";
        if (value == aspose::words::cloud::models::DrawingObjectUpdate::WrapType::THROUGH) return "Through";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::DrawingObjectUpdate::WrapType drawingObjectUpdateWrapTypeFromString(const std::string& value)
    {
        if (value == "Inline") return aspose::words::cloud::models::DrawingObjectUpdate::WrapType::INLINE;
        if (value == "TopBottom") return aspose::words::cloud::models::DrawingObjectUpdate::WrapType::TOP_BOTTOM;
        if (value == "Square") return aspose::words::cloud::models::DrawingObjectUpdate::WrapType::SQUARE;
        if (value == "None") return aspose::words::cloud::models::DrawingObjectUpdate::WrapType::NONE;
        if (value == "Tight") return aspose::words::cloud::models::DrawingObjectUpdate::WrapType::TIGHT;
        if (value == "Through") return aspose::words::cloud::models::DrawingObjectUpdate::WrapType::THROUGH;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void DrawingObjectUpdate::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_RelativeHorizontalPosition) {
            json["RelativeHorizontalPosition"] = drawingObjectUpdateRelativeHorizontalPositionToString(*(this->m_RelativeHorizontalPosition));
        }
        if (this->m_Left) {
            json["Left"] = *(this->m_Left);
        }
        if (this->m_RelativeVerticalPosition) {
            json["RelativeVerticalPosition"] = drawingObjectUpdateRelativeVerticalPositionToString(*(this->m_RelativeVerticalPosition));
        }
        if (this->m_Top) {
            json["Top"] = *(this->m_Top);
        }
        if (this->m_Width) {
            json["Width"] = *(this->m_Width);
        }
        if (this->m_Height) {
            json["Height"] = *(this->m_Height);
        }
        if (this->m_WrapType) {
            json["WrapType"] = drawingObjectUpdateWrapTypeToString(*(this->m_WrapType));
        }
        if (this->m_AspectRatioLocked) {
            json["AspectRatioLocked"] = *(this->m_AspectRatioLocked);
        }
    }

    void DrawingObjectUpdate::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("RelativeHorizontalPosition") && !json["RelativeHorizontalPosition"].is_null()) {
            this->m_RelativeHorizontalPosition = std::make_shared< aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition >(
                drawingObjectUpdateRelativeHorizontalPositionFromString(json["RelativeHorizontalPosition"].get< std::string >())
            );
        }
        if (json.contains("Left") && !json["Left"].is_null()) {
            this->m_Left = std::make_shared< double >(
                json["Left"].get< double >()
            );
        }
        if (json.contains("RelativeVerticalPosition") && !json["RelativeVerticalPosition"].is_null()) {
            this->m_RelativeVerticalPosition = std::make_shared< aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition >(
                drawingObjectUpdateRelativeVerticalPositionFromString(json["RelativeVerticalPosition"].get< std::string >())
            );
        }
        if (json.contains("Top") && !json["Top"].is_null()) {
            this->m_Top = std::make_shared< double >(
                json["Top"].get< double >()
            );
        }
        if (json.contains("Width") && !json["Width"].is_null()) {
            this->m_Width = std::make_shared< double >(
                json["Width"].get< double >()
            );
        }
        if (json.contains("Height") && !json["Height"].is_null()) {
            this->m_Height = std::make_shared< double >(
                json["Height"].get< double >()
            );
        }
        if (json.contains("WrapType") && !json["WrapType"].is_null()) {
            this->m_WrapType = std::make_shared< aspose::words::cloud::models::DrawingObjectUpdate::WrapType >(
                drawingObjectUpdateWrapTypeFromString(json["WrapType"].get< std::string >())
            );
        }
        if (json.contains("AspectRatioLocked") && !json["AspectRatioLocked"].is_null()) {
            this->m_AspectRatioLocked = std::make_shared< bool >(
                json["AspectRatioLocked"].get< bool >()
            );
        }
    }

    void DrawingObjectUpdate::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void DrawingObjectUpdate::validate()
    {
    }

    std::shared_ptr< aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition > DrawingObjectUpdate::getRelativeHorizontalPosition() const
    {
        return this->m_RelativeHorizontalPosition;
    }

    void DrawingObjectUpdate::setRelativeHorizontalPosition(std::shared_ptr< aspose::words::cloud::models::DrawingObjectUpdate::RelativeHorizontalPosition > value)
    {
        this->m_RelativeHorizontalPosition = value;
    }


    std::shared_ptr< double > DrawingObjectUpdate::getLeft() const
    {
        return this->m_Left;
    }

    void DrawingObjectUpdate::setLeft(std::shared_ptr< double > value)
    {
        this->m_Left = value;
    }


    std::shared_ptr< aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition > DrawingObjectUpdate::getRelativeVerticalPosition() const
    {
        return this->m_RelativeVerticalPosition;
    }

    void DrawingObjectUpdate::setRelativeVerticalPosition(std::shared_ptr< aspose::words::cloud::models::DrawingObjectUpdate::RelativeVerticalPosition > value)
    {
        this->m_RelativeVerticalPosition = value;
    }


    std::shared_ptr< double > DrawingObjectUpdate::getTop() const
    {
        return this->m_Top;
    }

    void DrawingObjectUpdate::setTop(std::shared_ptr< double > value)
    {
        this->m_Top = value;
    }


    std::shared_ptr< double > DrawingObjectUpdate::getWidth() const
    {
        return this->m_Width;
    }

    void DrawingObjectUpdate::setWidth(std::shared_ptr< double > value)
    {
        this->m_Width = value;
    }


    std::shared_ptr< double > DrawingObjectUpdate::getHeight() const
    {
        return this->m_Height;
    }

    void DrawingObjectUpdate::setHeight(std::shared_ptr< double > value)
    {
        this->m_Height = value;
    }


    std::shared_ptr< aspose::words::cloud::models::DrawingObjectUpdate::WrapType > DrawingObjectUpdate::getWrapType() const
    {
        return this->m_WrapType;
    }

    void DrawingObjectUpdate::setWrapType(std::shared_ptr< aspose::words::cloud::models::DrawingObjectUpdate::WrapType > value)
    {
        this->m_WrapType = value;
    }


    std::shared_ptr< bool > DrawingObjectUpdate::getAspectRatioLocked() const
    {
        return this->m_AspectRatioLocked;
    }

    void DrawingObjectUpdate::setAspectRatioLocked(std::shared_ptr< bool > value)
    {
        this->m_AspectRatioLocked = value;
    }



    /*
     * EmfSaveOptionsData implementation
     */
    void EmfSaveOptionsData::toJson(void* jsonIfc) const
    {
        ImageSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void EmfSaveOptionsData::fromJson(const void* jsonIfc)
    {
        ImageSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void EmfSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void EmfSaveOptionsData::validate()
    {
        ImageSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > EmfSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * EpsSaveOptionsData implementation
     */
    void EpsSaveOptionsData::toJson(void* jsonIfc) const
    {
        ImageSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void EpsSaveOptionsData::fromJson(const void* jsonIfc)
    {
        ImageSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void EpsSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void EpsSaveOptionsData::validate()
    {
        ImageSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > EpsSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * EpubSaveOptionsData implementation
     */
    void EpubSaveOptionsData::toJson(void* jsonIfc) const
    {
        HtmlSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_NavigationMapLevel) {
            json["NavigationMapLevel"] = *(this->m_NavigationMapLevel);
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void EpubSaveOptionsData::fromJson(const void* jsonIfc)
    {
        HtmlSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("NavigationMapLevel") && !json["NavigationMapLevel"].is_null()) {
            this->m_NavigationMapLevel = std::make_shared< int32_t >(
                json["NavigationMapLevel"].get< int32_t >()
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void EpubSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void EpubSaveOptionsData::validate()
    {
        HtmlSaveOptionsData::validate();
    }

    std::shared_ptr< int32_t > EpubSaveOptionsData::getNavigationMapLevel() const
    {
        return this->m_NavigationMapLevel;
    }

    void EpubSaveOptionsData::setNavigationMapLevel(std::shared_ptr< int32_t > value)
    {
        this->m_NavigationMapLevel = value;
    }


    std::shared_ptr< std::wstring > EpubSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * Error implementation
     */
    void Error::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Code) {
            json["Code"] = convertUtf16(*(this->m_Code));
        }
        if (this->m_Description) {
            json["Description"] = convertUtf16(*(this->m_Description));
        }
        if (this->m_InnerError) {
            this->m_InnerError->toJson(&json["InnerError"]);
        }
        if (this->m_Message) {
            json["Message"] = convertUtf16(*(this->m_Message));
        }
    }

    void Error::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Code") && !json["Code"].is_null()) {
            this->m_Code = std::make_shared< std::wstring >(
                convertUtf8( json["Code"].get< std::string >() )
            );
        }
        if (json.contains("Description") && !json["Description"].is_null()) {
            this->m_Description = std::make_shared< std::wstring >(
                convertUtf8( json["Description"].get< std::string >() )
            );
        }
        if (json.contains("InnerError") && !json["InnerError"].is_null()) {
            this->m_InnerError = createModelInstance< aspose::words::cloud::models::ErrorDetails >(L"ErrorDetails, _", json["InnerError"]);
        }
        if (json.contains("Message") && !json["Message"].is_null()) {
            this->m_Message = std::make_shared< std::wstring >(
                convertUtf8( json["Message"].get< std::string >() )
            );
        }
    }

    void Error::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Error::validate()
    {

        if (this->m_InnerError != nullptr)
        {
            this->m_InnerError->validate();
        }


    }

    std::shared_ptr< std::wstring > Error::getCode() const
    {
        return this->m_Code;
    }

    void Error::setCode(std::shared_ptr< std::wstring > value)
    {
        this->m_Code = value;
    }


    std::shared_ptr< std::wstring > Error::getDescription() const
    {
        return this->m_Description;
    }

    void Error::setDescription(std::shared_ptr< std::wstring > value)
    {
        this->m_Description = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ErrorDetails > Error::getInnerError() const
    {
        return this->m_InnerError;
    }

    void Error::setInnerError(std::shared_ptr< aspose::words::cloud::models::ErrorDetails > value)
    {
        this->m_InnerError = value;
    }


    std::shared_ptr< std::wstring > Error::getMessage() const
    {
        return this->m_Message;
    }

    void Error::setMessage(std::shared_ptr< std::wstring > value)
    {
        this->m_Message = value;
    }



    /*
     * ErrorDetails implementation
     */
    void ErrorDetails::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ErrorDateTime) {
            json["ErrorDateTime"] = convertUtf16(*(this->m_ErrorDateTime));
        }
        if (this->m_RequestId) {
            json["RequestId"] = convertUtf16(*(this->m_RequestId));
        }
    }

    void ErrorDetails::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ErrorDateTime") && !json["ErrorDateTime"].is_null()) {
            this->m_ErrorDateTime = std::make_shared< std::wstring >(
                convertUtf8( json["ErrorDateTime"].get< std::string >() )
            );
        }
        if (json.contains("RequestId") && !json["RequestId"].is_null()) {
            this->m_RequestId = std::make_shared< std::wstring >(
                convertUtf8( json["RequestId"].get< std::string >() )
            );
        }
    }

    void ErrorDetails::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ErrorDetails::validate()
    {
        if (this->m_ErrorDateTime == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property ErrorDateTime in ErrorDetails is required.");
        }

    }

    std::shared_ptr< std::wstring > ErrorDetails::getErrorDateTime() const
    {
        return this->m_ErrorDateTime;
    }

    void ErrorDetails::setErrorDateTime(std::shared_ptr< std::wstring > value)
    {
        this->m_ErrorDateTime = value;
    }


    std::shared_ptr< std::wstring > ErrorDetails::getRequestId() const
    {
        return this->m_RequestId;
    }

    void ErrorDetails::setRequestId(std::shared_ptr< std::wstring > value)
    {
        this->m_RequestId = value;
    }



    /*
     * Field implementation
     */
    void Field::toJson(void* jsonIfc) const
    {
        FieldLink::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_LocaleId) {
            json["LocaleId"] = convertUtf16(*(this->m_LocaleId));
        }
        if (this->m_Result) {
            json["Result"] = convertUtf16(*(this->m_Result));
        }
    }

    void Field::fromJson(const void* jsonIfc)
    {
        FieldLink::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("LocaleId") && !json["LocaleId"].is_null()) {
            this->m_LocaleId = std::make_shared< std::wstring >(
                convertUtf8( json["LocaleId"].get< std::string >() )
            );
        }
        if (json.contains("Result") && !json["Result"].is_null()) {
            this->m_Result = std::make_shared< std::wstring >(
                convertUtf8( json["Result"].get< std::string >() )
            );
        }
    }

    void Field::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Field::validate()
    {
        FieldLink::validate();
    }

    std::shared_ptr< std::wstring > Field::getLocaleId() const
    {
        return this->m_LocaleId;
    }

    void Field::setLocaleId(std::shared_ptr< std::wstring > value)
    {
        this->m_LocaleId = value;
    }


    std::shared_ptr< std::wstring > Field::getResult() const
    {
        return this->m_Result;
    }

    void Field::setResult(std::shared_ptr< std::wstring > value)
    {
        this->m_Result = value;
    }



    /*
     * FieldBase implementation
     */
    void FieldBase::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_LocaleId) {
            json["LocaleId"] = convertUtf16(*(this->m_LocaleId));
        }
        if (this->m_FieldCode) {
            json["FieldCode"] = convertUtf16(*(this->m_FieldCode));
        }
    }

    void FieldBase::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("LocaleId") && !json["LocaleId"].is_null()) {
            this->m_LocaleId = std::make_shared< std::wstring >(
                convertUtf8( json["LocaleId"].get< std::string >() )
            );
        }
        if (json.contains("FieldCode") && !json["FieldCode"].is_null()) {
            this->m_FieldCode = std::make_shared< std::wstring >(
                convertUtf8( json["FieldCode"].get< std::string >() )
            );
        }
    }

    void FieldBase::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FieldBase::validate()
    {
        if (this->m_FieldCode == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property FieldCode in FieldBase is required.");
        }

    }

    std::shared_ptr< std::wstring > FieldBase::getLocaleId() const
    {
        return this->m_LocaleId;
    }

    void FieldBase::setLocaleId(std::shared_ptr< std::wstring > value)
    {
        this->m_LocaleId = value;
    }


    std::shared_ptr< std::wstring > FieldBase::getFieldCode() const
    {
        return this->m_FieldCode;
    }

    void FieldBase::setFieldCode(std::shared_ptr< std::wstring > value)
    {
        this->m_FieldCode = value;
    }



    /*
     * FieldCollection implementation
     */
    void FieldCollection::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_List) {
            json["List"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_List)) {
                element->toJson(&json["List"].emplace_back());
            }
        }
    }

    void FieldCollection::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("List") && !json["List"].is_null()) {
            this->m_List = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::Field>> >();
            for (auto& element : json["List"]) {
                this->m_List->emplace_back(createModelInstance< aspose::words::cloud::models::Field >(L"Field, _", element));
            }
        }
    }

    void FieldCollection::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FieldCollection::validate()
    {
        LinkElement::validate();

        if (this->m_List != nullptr)
        {
            for (auto& elementList : *(this->m_List))
            {
                if (elementList != nullptr)
                {
                    elementList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Field>> > FieldCollection::getList() const
    {
        return this->m_List;
    }

    void FieldCollection::setList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Field>> > value)
    {
        this->m_List = value;
    }



    /*
     * FieldInsert implementation
     */
    void FieldInsert::toJson(void* jsonIfc) const
    {
        FieldBase::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Position) {
            this->m_Position->toJson(&json["Position"]);
        }
    }

    void FieldInsert::fromJson(const void* jsonIfc)
    {
        FieldBase::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Position") && !json["Position"].is_null()) {
            this->m_Position = createModelInstance< aspose::words::cloud::models::Position >(L"Position, _", json["Position"]);
        }
    }

    void FieldInsert::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FieldInsert::validate()
    {
        FieldBase::validate();

        if (this->m_Position != nullptr)
        {
            this->m_Position->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Position > FieldInsert::getPosition() const
    {
        return this->m_Position;
    }

    void FieldInsert::setPosition(std::shared_ptr< aspose::words::cloud::models::Position > value)
    {
        this->m_Position = value;
    }



    /*
     * FieldLink implementation
     */
    void FieldLink::toJson(void* jsonIfc) const
    {
        NodeLink::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_FieldCode) {
            json["FieldCode"] = convertUtf16(*(this->m_FieldCode));
        }
    }

    void FieldLink::fromJson(const void* jsonIfc)
    {
        NodeLink::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("FieldCode") && !json["FieldCode"].is_null()) {
            this->m_FieldCode = std::make_shared< std::wstring >(
                convertUtf8( json["FieldCode"].get< std::string >() )
            );
        }
    }

    void FieldLink::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FieldLink::validate()
    {
        NodeLink::validate();
    }

    std::shared_ptr< std::wstring > FieldLink::getFieldCode() const
    {
        return this->m_FieldCode;
    }

    void FieldLink::setFieldCode(std::shared_ptr< std::wstring > value)
    {
        this->m_FieldCode = value;
    }



    /*
     * FieldNames implementation
     */
    void FieldNames::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Names) {
            json["Names"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_Names)) {
                json["Names"].push_back(convertUtf16(*element));
            }
        }
    }

    void FieldNames::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Names") && !json["Names"].is_null()) {
            this->m_Names = std::make_shared< std::vector<std::shared_ptr<std::wstring>> >();
            for (auto& element : json["Names"]) {
                this->m_Names->push_back(std::make_shared< std::wstring >(convertUtf8( element.get< std::string >() )));
            }
        }
    }

    void FieldNames::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FieldNames::validate()
    {
        LinkElement::validate();
    }

    std::shared_ptr< std::vector<std::shared_ptr<std::wstring>> > FieldNames::getNames() const
    {
        return this->m_Names;
    }

    void FieldNames::setNames(std::shared_ptr< std::vector<std::shared_ptr<std::wstring>> > value)
    {
        this->m_Names = value;
    }



    /*
     * FieldNamesResponse implementation
     */
    void FieldNamesResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_FieldNames) {
            this->m_FieldNames->toJson(&json["FieldNames"]);
        }
    }

    void FieldNamesResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("FieldNames") && !json["FieldNames"].is_null()) {
            this->m_FieldNames = createModelInstance< aspose::words::cloud::models::FieldNames >(L"FieldNames, _", json["FieldNames"]);
        }
    }

    void FieldNamesResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FieldNamesResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_FieldNames != nullptr)
        {
            this->m_FieldNames->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::FieldNames > FieldNamesResponse::getFieldNames() const
    {
        return this->m_FieldNames;
    }

    void FieldNamesResponse::setFieldNames(std::shared_ptr< aspose::words::cloud::models::FieldNames > value)
    {
        this->m_FieldNames = value;
    }



    /*
     * FieldOptions implementation
     */
    inline std::string fieldOptionsFieldIndexFormatToString(aspose::words::cloud::models::FieldOptions::FieldIndexFormat value)
    {
        if (value == aspose::words::cloud::models::FieldOptions::FieldIndexFormat::TEMPLATE) return "Template";
        if (value == aspose::words::cloud::models::FieldOptions::FieldIndexFormat::CLASSIC) return "Classic";
        if (value == aspose::words::cloud::models::FieldOptions::FieldIndexFormat::FANCY) return "Fancy";
        if (value == aspose::words::cloud::models::FieldOptions::FieldIndexFormat::MODERN) return "Modern";
        if (value == aspose::words::cloud::models::FieldOptions::FieldIndexFormat::BULLETED) return "Bulleted";
        if (value == aspose::words::cloud::models::FieldOptions::FieldIndexFormat::FORMAL) return "Formal";
        if (value == aspose::words::cloud::models::FieldOptions::FieldIndexFormat::SIMPLE) return "Simple";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::FieldOptions::FieldIndexFormat fieldOptionsFieldIndexFormatFromString(const std::string& value)
    {
        if (value == "Template") return aspose::words::cloud::models::FieldOptions::FieldIndexFormat::TEMPLATE;
        if (value == "Classic") return aspose::words::cloud::models::FieldOptions::FieldIndexFormat::CLASSIC;
        if (value == "Fancy") return aspose::words::cloud::models::FieldOptions::FieldIndexFormat::FANCY;
        if (value == "Modern") return aspose::words::cloud::models::FieldOptions::FieldIndexFormat::MODERN;
        if (value == "Bulleted") return aspose::words::cloud::models::FieldOptions::FieldIndexFormat::BULLETED;
        if (value == "Formal") return aspose::words::cloud::models::FieldOptions::FieldIndexFormat::FORMAL;
        if (value == "Simple") return aspose::words::cloud::models::FieldOptions::FieldIndexFormat::SIMPLE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string fieldOptionsFieldUpdateCultureSourceToString(aspose::words::cloud::models::FieldOptions::FieldUpdateCultureSource value)
    {
        if (value == aspose::words::cloud::models::FieldOptions::FieldUpdateCultureSource::CURRENT_THREAD) return "CurrentThread";
        if (value == aspose::words::cloud::models::FieldOptions::FieldUpdateCultureSource::FIELD_CODE) return "FieldCode";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::FieldOptions::FieldUpdateCultureSource fieldOptionsFieldUpdateCultureSourceFromString(const std::string& value)
    {
        if (value == "CurrentThread") return aspose::words::cloud::models::FieldOptions::FieldUpdateCultureSource::CURRENT_THREAD;
        if (value == "FieldCode") return aspose::words::cloud::models::FieldOptions::FieldUpdateCultureSource::FIELD_CODE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void FieldOptions::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_CurrentUser) {
            this->m_CurrentUser->toJson(&json["CurrentUser"]);
        }
        if (this->m_CustomTocStyleSeparator) {
            json["CustomTocStyleSeparator"] = convertUtf16(*(this->m_CustomTocStyleSeparator));
        }
        if (this->m_DefaultDocumentAuthor) {
            json["DefaultDocumentAuthor"] = convertUtf16(*(this->m_DefaultDocumentAuthor));
        }
        if (this->m_FieldIndexFormat) {
            json["FieldIndexFormat"] = fieldOptionsFieldIndexFormatToString(*(this->m_FieldIndexFormat));
        }
        if (this->m_FieldUpdateCultureName) {
            json["FieldUpdateCultureName"] = convertUtf16(*(this->m_FieldUpdateCultureName));
        }
        if (this->m_FieldUpdateCultureSource) {
            json["FieldUpdateCultureSource"] = fieldOptionsFieldUpdateCultureSourceToString(*(this->m_FieldUpdateCultureSource));
        }
        if (this->m_FileName) {
            json["FileName"] = convertUtf16(*(this->m_FileName));
        }
        if (this->m_IsBidiTextSupportedOnUpdate) {
            json["IsBidiTextSupportedOnUpdate"] = *(this->m_IsBidiTextSupportedOnUpdate);
        }
        if (this->m_LegacyNumberFormat) {
            json["LegacyNumberFormat"] = *(this->m_LegacyNumberFormat);
        }
        if (this->m_PreProcessCultureName) {
            json["PreProcessCultureName"] = convertUtf16(*(this->m_PreProcessCultureName));
        }
        if (this->m_TemplateName) {
            json["TemplateName"] = convertUtf16(*(this->m_TemplateName));
        }
        if (this->m_UseInvariantCultureNumberFormat) {
            json["UseInvariantCultureNumberFormat"] = *(this->m_UseInvariantCultureNumberFormat);
        }
        if (this->m_BuiltInTemplatesPaths) {
            json["BuiltInTemplatesPaths"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_BuiltInTemplatesPaths)) {
                json["BuiltInTemplatesPaths"].push_back(convertUtf16(*element));
            }
        }
    }

    void FieldOptions::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("CurrentUser") && !json["CurrentUser"].is_null()) {
            this->m_CurrentUser = createModelInstance< aspose::words::cloud::models::UserInformation >(L"UserInformation, _", json["CurrentUser"]);
        }
        if (json.contains("CustomTocStyleSeparator") && !json["CustomTocStyleSeparator"].is_null()) {
            this->m_CustomTocStyleSeparator = std::make_shared< std::wstring >(
                convertUtf8( json["CustomTocStyleSeparator"].get< std::string >() )
            );
        }
        if (json.contains("DefaultDocumentAuthor") && !json["DefaultDocumentAuthor"].is_null()) {
            this->m_DefaultDocumentAuthor = std::make_shared< std::wstring >(
                convertUtf8( json["DefaultDocumentAuthor"].get< std::string >() )
            );
        }
        if (json.contains("FieldIndexFormat") && !json["FieldIndexFormat"].is_null()) {
            this->m_FieldIndexFormat = std::make_shared< aspose::words::cloud::models::FieldOptions::FieldIndexFormat >(
                fieldOptionsFieldIndexFormatFromString(json["FieldIndexFormat"].get< std::string >())
            );
        }
        if (json.contains("FieldUpdateCultureName") && !json["FieldUpdateCultureName"].is_null()) {
            this->m_FieldUpdateCultureName = std::make_shared< std::wstring >(
                convertUtf8( json["FieldUpdateCultureName"].get< std::string >() )
            );
        }
        if (json.contains("FieldUpdateCultureSource") && !json["FieldUpdateCultureSource"].is_null()) {
            this->m_FieldUpdateCultureSource = std::make_shared< aspose::words::cloud::models::FieldOptions::FieldUpdateCultureSource >(
                fieldOptionsFieldUpdateCultureSourceFromString(json["FieldUpdateCultureSource"].get< std::string >())
            );
        }
        if (json.contains("FileName") && !json["FileName"].is_null()) {
            this->m_FileName = std::make_shared< std::wstring >(
                convertUtf8( json["FileName"].get< std::string >() )
            );
        }
        if (json.contains("IsBidiTextSupportedOnUpdate") && !json["IsBidiTextSupportedOnUpdate"].is_null()) {
            this->m_IsBidiTextSupportedOnUpdate = std::make_shared< bool >(
                json["IsBidiTextSupportedOnUpdate"].get< bool >()
            );
        }
        if (json.contains("LegacyNumberFormat") && !json["LegacyNumberFormat"].is_null()) {
            this->m_LegacyNumberFormat = std::make_shared< bool >(
                json["LegacyNumberFormat"].get< bool >()
            );
        }
        if (json.contains("PreProcessCultureName") && !json["PreProcessCultureName"].is_null()) {
            this->m_PreProcessCultureName = std::make_shared< std::wstring >(
                convertUtf8( json["PreProcessCultureName"].get< std::string >() )
            );
        }
        if (json.contains("TemplateName") && !json["TemplateName"].is_null()) {
            this->m_TemplateName = std::make_shared< std::wstring >(
                convertUtf8( json["TemplateName"].get< std::string >() )
            );
        }
        if (json.contains("UseInvariantCultureNumberFormat") && !json["UseInvariantCultureNumberFormat"].is_null()) {
            this->m_UseInvariantCultureNumberFormat = std::make_shared< bool >(
                json["UseInvariantCultureNumberFormat"].get< bool >()
            );
        }
        if (json.contains("BuiltInTemplatesPaths") && !json["BuiltInTemplatesPaths"].is_null()) {
            this->m_BuiltInTemplatesPaths = std::make_shared< std::vector<std::shared_ptr<std::wstring>> >();
            for (auto& element : json["BuiltInTemplatesPaths"]) {
                this->m_BuiltInTemplatesPaths->push_back(std::make_shared< std::wstring >(convertUtf8( element.get< std::string >() )));
            }
        }
    }

    void FieldOptions::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FieldOptions::validate()
    {

        if (this->m_CurrentUser != nullptr)
        {
            this->m_CurrentUser->validate();
        }













    }

    std::shared_ptr< aspose::words::cloud::models::UserInformation > FieldOptions::getCurrentUser() const
    {
        return this->m_CurrentUser;
    }

    void FieldOptions::setCurrentUser(std::shared_ptr< aspose::words::cloud::models::UserInformation > value)
    {
        this->m_CurrentUser = value;
    }


    std::shared_ptr< std::wstring > FieldOptions::getCustomTocStyleSeparator() const
    {
        return this->m_CustomTocStyleSeparator;
    }

    void FieldOptions::setCustomTocStyleSeparator(std::shared_ptr< std::wstring > value)
    {
        this->m_CustomTocStyleSeparator = value;
    }


    std::shared_ptr< std::wstring > FieldOptions::getDefaultDocumentAuthor() const
    {
        return this->m_DefaultDocumentAuthor;
    }

    void FieldOptions::setDefaultDocumentAuthor(std::shared_ptr< std::wstring > value)
    {
        this->m_DefaultDocumentAuthor = value;
    }


    std::shared_ptr< aspose::words::cloud::models::FieldOptions::FieldIndexFormat > FieldOptions::getFieldIndexFormat() const
    {
        return this->m_FieldIndexFormat;
    }

    void FieldOptions::setFieldIndexFormat(std::shared_ptr< aspose::words::cloud::models::FieldOptions::FieldIndexFormat > value)
    {
        this->m_FieldIndexFormat = value;
    }


    std::shared_ptr< std::wstring > FieldOptions::getFieldUpdateCultureName() const
    {
        return this->m_FieldUpdateCultureName;
    }

    void FieldOptions::setFieldUpdateCultureName(std::shared_ptr< std::wstring > value)
    {
        this->m_FieldUpdateCultureName = value;
    }


    std::shared_ptr< aspose::words::cloud::models::FieldOptions::FieldUpdateCultureSource > FieldOptions::getFieldUpdateCultureSource() const
    {
        return this->m_FieldUpdateCultureSource;
    }

    void FieldOptions::setFieldUpdateCultureSource(std::shared_ptr< aspose::words::cloud::models::FieldOptions::FieldUpdateCultureSource > value)
    {
        this->m_FieldUpdateCultureSource = value;
    }


    std::shared_ptr< std::wstring > FieldOptions::getFileName() const
    {
        return this->m_FileName;
    }

    void FieldOptions::setFileName(std::shared_ptr< std::wstring > value)
    {
        this->m_FileName = value;
    }


    std::shared_ptr< bool > FieldOptions::getIsBidiTextSupportedOnUpdate() const
    {
        return this->m_IsBidiTextSupportedOnUpdate;
    }

    void FieldOptions::setIsBidiTextSupportedOnUpdate(std::shared_ptr< bool > value)
    {
        this->m_IsBidiTextSupportedOnUpdate = value;
    }


    std::shared_ptr< bool > FieldOptions::getLegacyNumberFormat() const
    {
        return this->m_LegacyNumberFormat;
    }

    void FieldOptions::setLegacyNumberFormat(std::shared_ptr< bool > value)
    {
        this->m_LegacyNumberFormat = value;
    }


    std::shared_ptr< std::wstring > FieldOptions::getPreProcessCultureName() const
    {
        return this->m_PreProcessCultureName;
    }

    void FieldOptions::setPreProcessCultureName(std::shared_ptr< std::wstring > value)
    {
        this->m_PreProcessCultureName = value;
    }


    std::shared_ptr< std::wstring > FieldOptions::getTemplateName() const
    {
        return this->m_TemplateName;
    }

    void FieldOptions::setTemplateName(std::shared_ptr< std::wstring > value)
    {
        this->m_TemplateName = value;
    }


    std::shared_ptr< bool > FieldOptions::getUseInvariantCultureNumberFormat() const
    {
        return this->m_UseInvariantCultureNumberFormat;
    }

    void FieldOptions::setUseInvariantCultureNumberFormat(std::shared_ptr< bool > value)
    {
        this->m_UseInvariantCultureNumberFormat = value;
    }


    std::shared_ptr< std::vector<std::shared_ptr<std::wstring>> > FieldOptions::getBuiltInTemplatesPaths() const
    {
        return this->m_BuiltInTemplatesPaths;
    }

    void FieldOptions::setBuiltInTemplatesPaths(std::shared_ptr< std::vector<std::shared_ptr<std::wstring>> > value)
    {
        this->m_BuiltInTemplatesPaths = value;
    }



    /*
     * FieldResponse implementation
     */
    void FieldResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Field) {
            this->m_Field->toJson(&json["Field"]);
        }
    }

    void FieldResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Field") && !json["Field"].is_null()) {
            this->m_Field = createModelInstance< aspose::words::cloud::models::Field >(L"Field, _", json["Field"]);
        }
    }

    void FieldResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FieldResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Field != nullptr)
        {
            this->m_Field->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Field > FieldResponse::getField() const
    {
        return this->m_Field;
    }

    void FieldResponse::setField(std::shared_ptr< aspose::words::cloud::models::Field > value)
    {
        this->m_Field = value;
    }



    /*
     * FieldsResponse implementation
     */
    void FieldsResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Fields) {
            this->m_Fields->toJson(&json["Fields"]);
        }
    }

    void FieldsResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Fields") && !json["Fields"].is_null()) {
            this->m_Fields = createModelInstance< aspose::words::cloud::models::FieldCollection >(L"FieldCollection, _", json["Fields"]);
        }
    }

    void FieldsResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FieldsResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Fields != nullptr)
        {
            this->m_Fields->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::FieldCollection > FieldsResponse::getFields() const
    {
        return this->m_Fields;
    }

    void FieldsResponse::setFields(std::shared_ptr< aspose::words::cloud::models::FieldCollection > value)
    {
        this->m_Fields = value;
    }



    /*
     * FieldUpdate implementation
     */
    void FieldUpdate::toJson(void* jsonIfc) const
    {
        FieldBase::toJson(jsonIfc);
    }

    void FieldUpdate::fromJson(const void* jsonIfc)
    {
        FieldBase::fromJson(jsonIfc);
    }

    void FieldUpdate::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FieldUpdate::validate()
    {
        FieldBase::validate();
    }




    /*
     * FileLink implementation
     */
    void FileLink::toJson(void* jsonIfc) const
    {
        Link::toJson(jsonIfc);
    }

    void FileLink::fromJson(const void* jsonIfc)
    {
        Link::fromJson(jsonIfc);
    }

    void FileLink::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FileLink::validate()
    {
        Link::validate();
    }




    /*
     * FilesList implementation
     */
    void FilesList::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Value) {
            json["Value"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_Value)) {
                element->toJson(&json["Value"].emplace_back());
            }
        }
    }

    void FilesList::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Value") && !json["Value"].is_null()) {
            this->m_Value = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::StorageFile>> >();
            for (auto& element : json["Value"]) {
                this->m_Value->emplace_back(createModelInstance< aspose::words::cloud::models::StorageFile >(L"StorageFile, _", element));
            }
        }
    }

    void FilesList::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FilesList::validate()
    {

        if (this->m_Value != nullptr)
        {
            for (auto& elementValue : *(this->m_Value))
            {
                if (elementValue != nullptr)
                {
                    elementValue->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::StorageFile>> > FilesList::getValue() const
    {
        return this->m_Value;
    }

    void FilesList::setValue(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::StorageFile>> > value)
    {
        this->m_Value = value;
    }



    /*
     * FilesUploadResult implementation
     */
    void FilesUploadResult::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Errors) {
            json["Errors"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_Errors)) {
                element->toJson(&json["Errors"].emplace_back());
            }
        }
        if (this->m_Uploaded) {
            json["Uploaded"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_Uploaded)) {
                json["Uploaded"].push_back(convertUtf16(*element));
            }
        }
    }

    void FilesUploadResult::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Errors") && !json["Errors"].is_null()) {
            this->m_Errors = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::Error>> >();
            for (auto& element : json["Errors"]) {
                this->m_Errors->emplace_back(createModelInstance< aspose::words::cloud::models::Error >(L"Error, _", element));
            }
        }
        if (json.contains("Uploaded") && !json["Uploaded"].is_null()) {
            this->m_Uploaded = std::make_shared< std::vector<std::shared_ptr<std::wstring>> >();
            for (auto& element : json["Uploaded"]) {
                this->m_Uploaded->push_back(std::make_shared< std::wstring >(convertUtf8( element.get< std::string >() )));
            }
        }
    }

    void FilesUploadResult::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FilesUploadResult::validate()
    {

        if (this->m_Errors != nullptr)
        {
            for (auto& elementErrors : *(this->m_Errors))
            {
                if (elementErrors != nullptr)
                {
                    elementErrors->validate();
                }
            }
        }


    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Error>> > FilesUploadResult::getErrors() const
    {
        return this->m_Errors;
    }

    void FilesUploadResult::setErrors(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Error>> > value)
    {
        this->m_Errors = value;
    }


    std::shared_ptr< std::vector<std::shared_ptr<std::wstring>> > FilesUploadResult::getUploaded() const
    {
        return this->m_Uploaded;
    }

    void FilesUploadResult::setUploaded(std::shared_ptr< std::vector<std::shared_ptr<std::wstring>> > value)
    {
        this->m_Uploaded = value;
    }



    /*
     * FixedPageSaveOptionsData implementation
     */
    inline std::string fixedPageSaveOptionsDataColorModeToString(aspose::words::cloud::models::FixedPageSaveOptionsData::ColorMode value)
    {
        if (value == aspose::words::cloud::models::FixedPageSaveOptionsData::ColorMode::NORMAL) return "Normal";
        if (value == aspose::words::cloud::models::FixedPageSaveOptionsData::ColorMode::GRAYSCALE) return "Grayscale";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::FixedPageSaveOptionsData::ColorMode fixedPageSaveOptionsDataColorModeFromString(const std::string& value)
    {
        if (value == "Normal") return aspose::words::cloud::models::FixedPageSaveOptionsData::ColorMode::NORMAL;
        if (value == "Grayscale") return aspose::words::cloud::models::FixedPageSaveOptionsData::ColorMode::GRAYSCALE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string fixedPageSaveOptionsDataNumeralFormatToString(aspose::words::cloud::models::FixedPageSaveOptionsData::NumeralFormat value)
    {
        if (value == aspose::words::cloud::models::FixedPageSaveOptionsData::NumeralFormat::EUROPEAN) return "European";
        if (value == aspose::words::cloud::models::FixedPageSaveOptionsData::NumeralFormat::ARABIC_INDIC) return "ArabicIndic";
        if (value == aspose::words::cloud::models::FixedPageSaveOptionsData::NumeralFormat::EASTERN_ARABIC_INDIC) return "EasternArabicIndic";
        if (value == aspose::words::cloud::models::FixedPageSaveOptionsData::NumeralFormat::CONTEXT) return "Context";
        if (value == aspose::words::cloud::models::FixedPageSaveOptionsData::NumeralFormat::SYSTEM) return "System";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::FixedPageSaveOptionsData::NumeralFormat fixedPageSaveOptionsDataNumeralFormatFromString(const std::string& value)
    {
        if (value == "European") return aspose::words::cloud::models::FixedPageSaveOptionsData::NumeralFormat::EUROPEAN;
        if (value == "ArabicIndic") return aspose::words::cloud::models::FixedPageSaveOptionsData::NumeralFormat::ARABIC_INDIC;
        if (value == "EasternArabicIndic") return aspose::words::cloud::models::FixedPageSaveOptionsData::NumeralFormat::EASTERN_ARABIC_INDIC;
        if (value == "Context") return aspose::words::cloud::models::FixedPageSaveOptionsData::NumeralFormat::CONTEXT;
        if (value == "System") return aspose::words::cloud::models::FixedPageSaveOptionsData::NumeralFormat::SYSTEM;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void FixedPageSaveOptionsData::toJson(void* jsonIfc) const
    {
        SaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ColorMode) {
            json["ColorMode"] = fixedPageSaveOptionsDataColorModeToString(*(this->m_ColorMode));
        }
        if (this->m_JpegQuality) {
            json["JpegQuality"] = *(this->m_JpegQuality);
        }
        if (this->m_MetafileRenderingOptions) {
            this->m_MetafileRenderingOptions->toJson(&json["MetafileRenderingOptions"]);
        }
        if (this->m_NumeralFormat) {
            json["NumeralFormat"] = fixedPageSaveOptionsDataNumeralFormatToString(*(this->m_NumeralFormat));
        }
        if (this->m_OptimizeOutput) {
            json["OptimizeOutput"] = *(this->m_OptimizeOutput);
        }
        if (this->m_PageCount) {
            json["PageCount"] = *(this->m_PageCount);
        }
        if (this->m_PageIndex) {
            json["PageIndex"] = *(this->m_PageIndex);
        }
    }

    void FixedPageSaveOptionsData::fromJson(const void* jsonIfc)
    {
        SaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ColorMode") && !json["ColorMode"].is_null()) {
            this->m_ColorMode = std::make_shared< aspose::words::cloud::models::FixedPageSaveOptionsData::ColorMode >(
                fixedPageSaveOptionsDataColorModeFromString(json["ColorMode"].get< std::string >())
            );
        }
        if (json.contains("JpegQuality") && !json["JpegQuality"].is_null()) {
            this->m_JpegQuality = std::make_shared< int32_t >(
                json["JpegQuality"].get< int32_t >()
            );
        }
        if (json.contains("MetafileRenderingOptions") && !json["MetafileRenderingOptions"].is_null()) {
            this->m_MetafileRenderingOptions = createModelInstance< aspose::words::cloud::models::MetafileRenderingOptionsData >(L"MetafileRenderingOptionsData, _", json["MetafileRenderingOptions"]);
        }
        if (json.contains("NumeralFormat") && !json["NumeralFormat"].is_null()) {
            this->m_NumeralFormat = std::make_shared< aspose::words::cloud::models::FixedPageSaveOptionsData::NumeralFormat >(
                fixedPageSaveOptionsDataNumeralFormatFromString(json["NumeralFormat"].get< std::string >())
            );
        }
        if (json.contains("OptimizeOutput") && !json["OptimizeOutput"].is_null()) {
            this->m_OptimizeOutput = std::make_shared< bool >(
                json["OptimizeOutput"].get< bool >()
            );
        }
        if (json.contains("PageCount") && !json["PageCount"].is_null()) {
            this->m_PageCount = std::make_shared< int32_t >(
                json["PageCount"].get< int32_t >()
            );
        }
        if (json.contains("PageIndex") && !json["PageIndex"].is_null()) {
            this->m_PageIndex = std::make_shared< int32_t >(
                json["PageIndex"].get< int32_t >()
            );
        }
    }

    void FixedPageSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FixedPageSaveOptionsData::validate()
    {
        SaveOptionsData::validate();

        if (this->m_MetafileRenderingOptions != nullptr)
        {
            this->m_MetafileRenderingOptions->validate();
        }





    }

    std::shared_ptr< aspose::words::cloud::models::FixedPageSaveOptionsData::ColorMode > FixedPageSaveOptionsData::getColorMode() const
    {
        return this->m_ColorMode;
    }

    void FixedPageSaveOptionsData::setColorMode(std::shared_ptr< aspose::words::cloud::models::FixedPageSaveOptionsData::ColorMode > value)
    {
        this->m_ColorMode = value;
    }


    std::shared_ptr< int32_t > FixedPageSaveOptionsData::getJpegQuality() const
    {
        return this->m_JpegQuality;
    }

    void FixedPageSaveOptionsData::setJpegQuality(std::shared_ptr< int32_t > value)
    {
        this->m_JpegQuality = value;
    }


    std::shared_ptr< aspose::words::cloud::models::MetafileRenderingOptionsData > FixedPageSaveOptionsData::getMetafileRenderingOptions() const
    {
        return this->m_MetafileRenderingOptions;
    }

    void FixedPageSaveOptionsData::setMetafileRenderingOptions(std::shared_ptr< aspose::words::cloud::models::MetafileRenderingOptionsData > value)
    {
        this->m_MetafileRenderingOptions = value;
    }


    std::shared_ptr< aspose::words::cloud::models::FixedPageSaveOptionsData::NumeralFormat > FixedPageSaveOptionsData::getNumeralFormat() const
    {
        return this->m_NumeralFormat;
    }

    void FixedPageSaveOptionsData::setNumeralFormat(std::shared_ptr< aspose::words::cloud::models::FixedPageSaveOptionsData::NumeralFormat > value)
    {
        this->m_NumeralFormat = value;
    }


    std::shared_ptr< bool > FixedPageSaveOptionsData::getOptimizeOutput() const
    {
        return this->m_OptimizeOutput;
    }

    void FixedPageSaveOptionsData::setOptimizeOutput(std::shared_ptr< bool > value)
    {
        this->m_OptimizeOutput = value;
    }


    std::shared_ptr< int32_t > FixedPageSaveOptionsData::getPageCount() const
    {
        return this->m_PageCount;
    }

    void FixedPageSaveOptionsData::setPageCount(std::shared_ptr< int32_t > value)
    {
        this->m_PageCount = value;
    }


    std::shared_ptr< int32_t > FixedPageSaveOptionsData::getPageIndex() const
    {
        return this->m_PageIndex;
    }

    void FixedPageSaveOptionsData::setPageIndex(std::shared_ptr< int32_t > value)
    {
        this->m_PageIndex = value;
    }



    /*
     * FlatOpcMacroSaveOptionsData implementation
     */
    void FlatOpcMacroSaveOptionsData::toJson(void* jsonIfc) const
    {
        OoxmlSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void FlatOpcMacroSaveOptionsData::fromJson(const void* jsonIfc)
    {
        OoxmlSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void FlatOpcMacroSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FlatOpcMacroSaveOptionsData::validate()
    {
        OoxmlSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > FlatOpcMacroSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * FlatOpcSaveOptionsData implementation
     */
    void FlatOpcSaveOptionsData::toJson(void* jsonIfc) const
    {
        OoxmlSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void FlatOpcSaveOptionsData::fromJson(const void* jsonIfc)
    {
        OoxmlSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void FlatOpcSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FlatOpcSaveOptionsData::validate()
    {
        OoxmlSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > FlatOpcSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * FlatOpcTemplateMacroSaveOptionsData implementation
     */
    void FlatOpcTemplateMacroSaveOptionsData::toJson(void* jsonIfc) const
    {
        OoxmlSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void FlatOpcTemplateMacroSaveOptionsData::fromJson(const void* jsonIfc)
    {
        OoxmlSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void FlatOpcTemplateMacroSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FlatOpcTemplateMacroSaveOptionsData::validate()
    {
        OoxmlSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > FlatOpcTemplateMacroSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * FlatOpcTemplateSaveOptionsData implementation
     */
    void FlatOpcTemplateSaveOptionsData::toJson(void* jsonIfc) const
    {
        OoxmlSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void FlatOpcTemplateSaveOptionsData::fromJson(const void* jsonIfc)
    {
        OoxmlSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void FlatOpcTemplateSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FlatOpcTemplateSaveOptionsData::validate()
    {
        OoxmlSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > FlatOpcTemplateSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * Font implementation
     */
    inline std::string fontStyleIdentifierToString(aspose::words::cloud::models::Font::StyleIdentifier value)
    {
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::NORMAL) return "Normal";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HEADING1) return "Heading1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HEADING2) return "Heading2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HEADING3) return "Heading3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HEADING4) return "Heading4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HEADING5) return "Heading5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HEADING6) return "Heading6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HEADING7) return "Heading7";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HEADING8) return "Heading8";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HEADING9) return "Heading9";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::INDEX1) return "Index1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::INDEX2) return "Index2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::INDEX3) return "Index3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::INDEX4) return "Index4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::INDEX5) return "Index5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::INDEX6) return "Index6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::INDEX7) return "Index7";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::INDEX8) return "Index8";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::INDEX9) return "Index9";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TOC1) return "Toc1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TOC2) return "Toc2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TOC3) return "Toc3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TOC4) return "Toc4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TOC5) return "Toc5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TOC6) return "Toc6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TOC7) return "Toc7";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TOC8) return "Toc8";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TOC9) return "Toc9";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::NORMAL_INDENT) return "NormalIndent";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::FOOTNOTE_TEXT) return "FootnoteText";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COMMENT_TEXT) return "CommentText";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HEADER) return "Header";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::FOOTER) return "Footer";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::INDEX_HEADING) return "IndexHeading";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::CAPTION) return "Caption";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_OF_FIGURES) return "TableOfFigures";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::ENVELOPE_ADDRESS) return "EnvelopeAddress";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::ENVELOPE_RETURN) return "EnvelopeReturn";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::FOOTNOTE_REFERENCE) return "FootnoteReference";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COMMENT_REFERENCE) return "CommentReference";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LINE_NUMBER) return "LineNumber";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::PAGE_NUMBER) return "PageNumber";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::ENDNOTE_REFERENCE) return "EndnoteReference";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::ENDNOTE_TEXT) return "EndnoteText";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_OF_AUTHORITIES) return "TableOfAuthorities";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MACRO) return "Macro";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TOA_HEADING) return "ToaHeading";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST) return "List";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_BULLET) return "ListBullet";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_NUMBER) return "ListNumber";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST2) return "List2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST3) return "List3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST4) return "List4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST5) return "List5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_BULLET2) return "ListBullet2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_BULLET3) return "ListBullet3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_BULLET4) return "ListBullet4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_BULLET5) return "ListBullet5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_NUMBER2) return "ListNumber2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_NUMBER3) return "ListNumber3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_NUMBER4) return "ListNumber4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_NUMBER5) return "ListNumber5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TITLE) return "Title";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::CLOSING) return "Closing";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::SIGNATURE) return "Signature";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::DEFAULT_PARAGRAPH_FONT) return "DefaultParagraphFont";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::BODY_TEXT) return "BodyText";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::BODY_TEXT_IND) return "BodyTextInd";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_CONTINUE) return "ListContinue";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_CONTINUE2) return "ListContinue2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_CONTINUE3) return "ListContinue3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_CONTINUE4) return "ListContinue4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_CONTINUE5) return "ListContinue5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MESSAGE_HEADER) return "MessageHeader";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::SUBTITLE) return "Subtitle";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::SALUTATION) return "Salutation";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::DATE) return "Date";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::BODY_TEXT1_I) return "BodyText1I";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::BODY_TEXT1_I2) return "BodyText1I2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::NOTE_HEADING) return "NoteHeading";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::BODY_TEXT2) return "BodyText2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::BODY_TEXT3) return "BodyText3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::BODY_TEXT_IND2) return "BodyTextInd2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::BODY_TEXT_IND3) return "BodyTextInd3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::BLOCK_TEXT) return "BlockText";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HYPERLINK) return "Hyperlink";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::FOLLOWED_HYPERLINK) return "FollowedHyperlink";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::STRONG) return "Strong";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::EMPHASIS) return "Emphasis";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::DOCUMENT_MAP) return "DocumentMap";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::PLAIN_TEXT) return "PlainText";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::EMAIL_SIGNATURE) return "EmailSignature";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HTML_TOP_OF_FORM) return "HtmlTopOfForm";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HTML_BOTTOM_OF_FORM) return "HtmlBottomOfForm";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::NORMAL_WEB) return "NormalWeb";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HTML_ACRONYM) return "HtmlAcronym";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HTML_ADDRESS) return "HtmlAddress";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HTML_CITE) return "HtmlCite";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HTML_CODE) return "HtmlCode";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HTML_DEFINITION) return "HtmlDefinition";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HTML_KEYBOARD) return "HtmlKeyboard";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HTML_PREFORMATTED) return "HtmlPreformatted";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HTML_SAMPLE) return "HtmlSample";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HTML_TYPEWRITER) return "HtmlTypewriter";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HTML_VARIABLE) return "HtmlVariable";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_NORMAL) return "TableNormal";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COMMENT_SUBJECT) return "CommentSubject";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::NO_LIST) return "NoList";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::OUTLINE_LIST1) return "OutlineList1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::OUTLINE_LIST2) return "OutlineList2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::OUTLINE_LIST3) return "OutlineList3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_SIMPLE1) return "TableSimple1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_SIMPLE2) return "TableSimple2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_SIMPLE3) return "TableSimple3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_CLASSIC1) return "TableClassic1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_CLASSIC2) return "TableClassic2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_CLASSIC3) return "TableClassic3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_CLASSIC4) return "TableClassic4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_COLORFUL1) return "TableColorful1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_COLORFUL2) return "TableColorful2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_COLORFUL3) return "TableColorful3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_COLUMNS1) return "TableColumns1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_COLUMNS2) return "TableColumns2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_COLUMNS3) return "TableColumns3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_COLUMNS4) return "TableColumns4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_COLUMNS5) return "TableColumns5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID1) return "TableGrid1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID2) return "TableGrid2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID3) return "TableGrid3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID4) return "TableGrid4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID5) return "TableGrid5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID6) return "TableGrid6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID7) return "TableGrid7";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID8) return "TableGrid8";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_LIST1) return "TableList1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_LIST2) return "TableList2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_LIST3) return "TableList3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_LIST4) return "TableList4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_LIST5) return "TableList5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_LIST6) return "TableList6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_LIST7) return "TableList7";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_LIST8) return "TableList8";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE3_D_EFFECTS1) return "Table3DEffects1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE3_D_EFFECTS2) return "Table3DEffects2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE3_D_EFFECTS3) return "Table3DEffects3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_CONTEMPORARY) return "TableContemporary";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_ELEGANT) return "TableElegant";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_PROFESSIONAL) return "TableProfessional";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_SUBTLE1) return "TableSubtle1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_SUBTLE2) return "TableSubtle2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_WEB1) return "TableWeb1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_WEB2) return "TableWeb2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_WEB3) return "TableWeb3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::BALLOON_TEXT) return "BalloonText";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID) return "TableGrid";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_THEME) return "TableTheme";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::PLACEHOLDER_TEXT) return "PlaceholderText";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::NO_SPACING) return "NoSpacing";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_SHADING) return "LightShading";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_LIST) return "LightList";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_GRID) return "LightGrid";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING1) return "MediumShading1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING2) return "MediumShading2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST1) return "MediumList1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST2) return "MediumList2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID1) return "MediumGrid1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID2) return "MediumGrid2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID3) return "MediumGrid3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::DARK_LIST) return "DarkList";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_SHADING) return "ColorfulShading";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_LIST) return "ColorfulList";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_GRID) return "ColorfulGrid";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_SHADING_ACCENT1) return "LightShadingAccent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_LIST_ACCENT1) return "LightListAccent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_GRID_ACCENT1) return "LightGridAccent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING1_ACCENT1) return "MediumShading1Accent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING2_ACCENT1) return "MediumShading2Accent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST1_ACCENT1) return "MediumList1Accent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::REVISION) return "Revision";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_PARAGRAPH) return "ListParagraph";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::QUOTE) return "Quote";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::INTENSE_QUOTE) return "IntenseQuote";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST2_ACCENT1) return "MediumList2Accent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID1_ACCENT1) return "MediumGrid1Accent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID2_ACCENT1) return "MediumGrid2Accent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID3_ACCENT1) return "MediumGrid3Accent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::DARK_LIST_ACCENT1) return "DarkListAccent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_SHADING_ACCENT1) return "ColorfulShadingAccent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_LIST_ACCENT1) return "ColorfulListAccent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_GRID_ACCENT1) return "ColorfulGridAccent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_SHADING_ACCENT2) return "LightShadingAccent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_LIST_ACCENT2) return "LightListAccent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_GRID_ACCENT2) return "LightGridAccent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING1_ACCENT2) return "MediumShading1Accent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING2_ACCENT2) return "MediumShading2Accent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST1_ACCENT2) return "MediumList1Accent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST2_ACCENT2) return "MediumList2Accent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID1_ACCENT2) return "MediumGrid1Accent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID2_ACCENT2) return "MediumGrid2Accent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID3_ACCENT2) return "MediumGrid3Accent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::DARK_LIST_ACCENT2) return "DarkListAccent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_SHADING_ACCENT2) return "ColorfulShadingAccent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_LIST_ACCENT2) return "ColorfulListAccent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_GRID_ACCENT2) return "ColorfulGridAccent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_SHADING_ACCENT3) return "LightShadingAccent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_LIST_ACCENT3) return "LightListAccent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_GRID_ACCENT3) return "LightGridAccent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING1_ACCENT3) return "MediumShading1Accent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING2_ACCENT3) return "MediumShading2Accent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST1_ACCENT3) return "MediumList1Accent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST2_ACCENT3) return "MediumList2Accent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID1_ACCENT3) return "MediumGrid1Accent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID2_ACCENT3) return "MediumGrid2Accent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID3_ACCENT3) return "MediumGrid3Accent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::DARK_LIST_ACCENT3) return "DarkListAccent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_SHADING_ACCENT3) return "ColorfulShadingAccent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_LIST_ACCENT3) return "ColorfulListAccent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_GRID_ACCENT3) return "ColorfulGridAccent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_SHADING_ACCENT4) return "LightShadingAccent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_LIST_ACCENT4) return "LightListAccent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_GRID_ACCENT4) return "LightGridAccent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING1_ACCENT4) return "MediumShading1Accent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING2_ACCENT4) return "MediumShading2Accent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST1_ACCENT4) return "MediumList1Accent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST2_ACCENT4) return "MediumList2Accent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID1_ACCENT4) return "MediumGrid1Accent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID2_ACCENT4) return "MediumGrid2Accent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID3_ACCENT4) return "MediumGrid3Accent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::DARK_LIST_ACCENT4) return "DarkListAccent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_SHADING_ACCENT4) return "ColorfulShadingAccent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_LIST_ACCENT4) return "ColorfulListAccent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_GRID_ACCENT4) return "ColorfulGridAccent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_SHADING_ACCENT5) return "LightShadingAccent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_LIST_ACCENT5) return "LightListAccent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_GRID_ACCENT5) return "LightGridAccent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING1_ACCENT5) return "MediumShading1Accent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING2_ACCENT5) return "MediumShading2Accent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST1_ACCENT5) return "MediumList1Accent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST2_ACCENT5) return "MediumList2Accent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID1_ACCENT5) return "MediumGrid1Accent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID2_ACCENT5) return "MediumGrid2Accent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID3_ACCENT5) return "MediumGrid3Accent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::DARK_LIST_ACCENT5) return "DarkListAccent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_SHADING_ACCENT5) return "ColorfulShadingAccent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_LIST_ACCENT5) return "ColorfulListAccent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_GRID_ACCENT5) return "ColorfulGridAccent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_SHADING_ACCENT6) return "LightShadingAccent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_LIST_ACCENT6) return "LightListAccent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_GRID_ACCENT6) return "LightGridAccent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING1_ACCENT6) return "MediumShading1Accent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING2_ACCENT6) return "MediumShading2Accent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST1_ACCENT6) return "MediumList1Accent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST2_ACCENT6) return "MediumList2Accent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID1_ACCENT6) return "MediumGrid1Accent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID2_ACCENT6) return "MediumGrid2Accent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID3_ACCENT6) return "MediumGrid3Accent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::DARK_LIST_ACCENT6) return "DarkListAccent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_SHADING_ACCENT6) return "ColorfulShadingAccent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_LIST_ACCENT6) return "ColorfulListAccent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_GRID_ACCENT6) return "ColorfulGridAccent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::SUBTLE_EMPHASIS) return "SubtleEmphasis";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::INTENSE_EMPHASIS) return "IntenseEmphasis";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::SUBTLE_REFERENCE) return "SubtleReference";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::INTENSE_REFERENCE) return "IntenseReference";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::BOOK_TITLE) return "BookTitle";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::BIBLIOGRAPHY) return "Bibliography";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TOC_HEADING) return "TocHeading";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::PLAIN_TABLE1) return "PlainTable1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::PLAIN_TABLE2) return "PlainTable2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::PLAIN_TABLE3) return "PlainTable3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::PLAIN_TABLE4) return "PlainTable4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::PLAIN_TABLE5) return "PlainTable5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID_LIGHT) return "TableGridLight";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE1_LIGHT) return "GridTable1Light";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE2) return "GridTable2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE3) return "GridTable3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE4) return "GridTable4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE5_DARK) return "GridTable5Dark";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE6_COLORFUL) return "GridTable6Colorful";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE7_COLORFUL) return "GridTable7Colorful";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT1) return "GridTable1LightAccent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE2_ACCENT1) return "GridTable2Accent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE3_ACCENT1) return "GridTable3Accent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE4_ACCENT1) return "GridTable4Accent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE5_DARK_ACCENT1) return "GridTable5DarkAccent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT1) return "GridTable6ColorfulAccent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT1) return "GridTable7ColorfulAccent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT2) return "GridTable1LightAccent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE2_ACCENT2) return "GridTable2Accent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE3_ACCENT2) return "GridTable3Accent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE4_ACCENT2) return "GridTable4Accent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE5_DARK_ACCENT2) return "GridTable5DarkAccent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT2) return "GridTable6ColorfulAccent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT2) return "GridTable7ColorfulAccent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT3) return "GridTable1LightAccent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE2_ACCENT3) return "GridTable2Accent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE3_ACCENT3) return "GridTable3Accent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE4_ACCENT3) return "GridTable4Accent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE5_DARK_ACCENT3) return "GridTable5DarkAccent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT3) return "GridTable6ColorfulAccent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT3) return "GridTable7ColorfulAccent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT4) return "GridTable1LightAccent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE2_ACCENT4) return "GridTable2Accent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE3_ACCENT4) return "GridTable3Accent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE4_ACCENT4) return "GridTable4Accent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE5_DARK_ACCENT4) return "GridTable5DarkAccent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT4) return "GridTable6ColorfulAccent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT4) return "GridTable7ColorfulAccent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT5) return "GridTable1LightAccent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE2_ACCENT5) return "GridTable2Accent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE3_ACCENT5) return "GridTable3Accent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE4_ACCENT5) return "GridTable4Accent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE5_DARK_ACCENT5) return "GridTable5DarkAccent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT5) return "GridTable6ColorfulAccent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT5) return "GridTable7ColorfulAccent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT6) return "GridTable1LightAccent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE2_ACCENT6) return "GridTable2Accent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE3_ACCENT6) return "GridTable3Accent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE4_ACCENT6) return "GridTable4Accent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE5_DARK_ACCENT6) return "GridTable5DarkAccent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT6) return "GridTable6ColorfulAccent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT6) return "GridTable7ColorfulAccent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE1_LIGHT) return "ListTable1Light";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE2) return "ListTable2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE3) return "ListTable3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE4) return "ListTable4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE5_DARK) return "ListTable5Dark";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE6_COLORFUL) return "ListTable6Colorful";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE7_COLORFUL) return "ListTable7Colorful";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT1) return "ListTable1LightAccent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE2_ACCENT1) return "ListTable2Accent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE3_ACCENT1) return "ListTable3Accent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE4_ACCENT1) return "ListTable4Accent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE5_DARK_ACCENT1) return "ListTable5DarkAccent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT1) return "ListTable6ColorfulAccent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT1) return "ListTable7ColorfulAccent1";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT2) return "ListTable1LightAccent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE2_ACCENT2) return "ListTable2Accent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE3_ACCENT2) return "ListTable3Accent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE4_ACCENT2) return "ListTable4Accent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE5_DARK_ACCENT2) return "ListTable5DarkAccent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT2) return "ListTable6ColorfulAccent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT2) return "ListTable7ColorfulAccent2";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT3) return "ListTable1LightAccent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE2_ACCENT3) return "ListTable2Accent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE3_ACCENT3) return "ListTable3Accent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE4_ACCENT3) return "ListTable4Accent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE5_DARK_ACCENT3) return "ListTable5DarkAccent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT3) return "ListTable6ColorfulAccent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT3) return "ListTable7ColorfulAccent3";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT4) return "ListTable1LightAccent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE2_ACCENT4) return "ListTable2Accent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE3_ACCENT4) return "ListTable3Accent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE4_ACCENT4) return "ListTable4Accent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE5_DARK_ACCENT4) return "ListTable5DarkAccent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT4) return "ListTable6ColorfulAccent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT4) return "ListTable7ColorfulAccent4";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT5) return "ListTable1LightAccent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE2_ACCENT5) return "ListTable2Accent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE3_ACCENT5) return "ListTable3Accent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE4_ACCENT5) return "ListTable4Accent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE5_DARK_ACCENT5) return "ListTable5DarkAccent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT5) return "ListTable6ColorfulAccent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT5) return "ListTable7ColorfulAccent5";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT6) return "ListTable1LightAccent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE2_ACCENT6) return "ListTable2Accent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE3_ACCENT6) return "ListTable3Accent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE4_ACCENT6) return "ListTable4Accent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE5_DARK_ACCENT6) return "ListTable5DarkAccent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT6) return "ListTable6ColorfulAccent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT6) return "ListTable7ColorfulAccent6";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::SMART_LINK) return "SmartLink";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::MENTION) return "Mention";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::SMART_HYPERLINK) return "SmartHyperlink";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::HASHTAG) return "Hashtag";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::UNRESOLVED_MENTION) return "UnresolvedMention";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::USER) return "User";
        if (value == aspose::words::cloud::models::Font::StyleIdentifier::NIL) return "Nil";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::Font::StyleIdentifier fontStyleIdentifierFromString(const std::string& value)
    {
        if (value == "Normal") return aspose::words::cloud::models::Font::StyleIdentifier::NORMAL;
        if (value == "Heading1") return aspose::words::cloud::models::Font::StyleIdentifier::HEADING1;
        if (value == "Heading2") return aspose::words::cloud::models::Font::StyleIdentifier::HEADING2;
        if (value == "Heading3") return aspose::words::cloud::models::Font::StyleIdentifier::HEADING3;
        if (value == "Heading4") return aspose::words::cloud::models::Font::StyleIdentifier::HEADING4;
        if (value == "Heading5") return aspose::words::cloud::models::Font::StyleIdentifier::HEADING5;
        if (value == "Heading6") return aspose::words::cloud::models::Font::StyleIdentifier::HEADING6;
        if (value == "Heading7") return aspose::words::cloud::models::Font::StyleIdentifier::HEADING7;
        if (value == "Heading8") return aspose::words::cloud::models::Font::StyleIdentifier::HEADING8;
        if (value == "Heading9") return aspose::words::cloud::models::Font::StyleIdentifier::HEADING9;
        if (value == "Index1") return aspose::words::cloud::models::Font::StyleIdentifier::INDEX1;
        if (value == "Index2") return aspose::words::cloud::models::Font::StyleIdentifier::INDEX2;
        if (value == "Index3") return aspose::words::cloud::models::Font::StyleIdentifier::INDEX3;
        if (value == "Index4") return aspose::words::cloud::models::Font::StyleIdentifier::INDEX4;
        if (value == "Index5") return aspose::words::cloud::models::Font::StyleIdentifier::INDEX5;
        if (value == "Index6") return aspose::words::cloud::models::Font::StyleIdentifier::INDEX6;
        if (value == "Index7") return aspose::words::cloud::models::Font::StyleIdentifier::INDEX7;
        if (value == "Index8") return aspose::words::cloud::models::Font::StyleIdentifier::INDEX8;
        if (value == "Index9") return aspose::words::cloud::models::Font::StyleIdentifier::INDEX9;
        if (value == "Toc1") return aspose::words::cloud::models::Font::StyleIdentifier::TOC1;
        if (value == "Toc2") return aspose::words::cloud::models::Font::StyleIdentifier::TOC2;
        if (value == "Toc3") return aspose::words::cloud::models::Font::StyleIdentifier::TOC3;
        if (value == "Toc4") return aspose::words::cloud::models::Font::StyleIdentifier::TOC4;
        if (value == "Toc5") return aspose::words::cloud::models::Font::StyleIdentifier::TOC5;
        if (value == "Toc6") return aspose::words::cloud::models::Font::StyleIdentifier::TOC6;
        if (value == "Toc7") return aspose::words::cloud::models::Font::StyleIdentifier::TOC7;
        if (value == "Toc8") return aspose::words::cloud::models::Font::StyleIdentifier::TOC8;
        if (value == "Toc9") return aspose::words::cloud::models::Font::StyleIdentifier::TOC9;
        if (value == "NormalIndent") return aspose::words::cloud::models::Font::StyleIdentifier::NORMAL_INDENT;
        if (value == "FootnoteText") return aspose::words::cloud::models::Font::StyleIdentifier::FOOTNOTE_TEXT;
        if (value == "CommentText") return aspose::words::cloud::models::Font::StyleIdentifier::COMMENT_TEXT;
        if (value == "Header") return aspose::words::cloud::models::Font::StyleIdentifier::HEADER;
        if (value == "Footer") return aspose::words::cloud::models::Font::StyleIdentifier::FOOTER;
        if (value == "IndexHeading") return aspose::words::cloud::models::Font::StyleIdentifier::INDEX_HEADING;
        if (value == "Caption") return aspose::words::cloud::models::Font::StyleIdentifier::CAPTION;
        if (value == "TableOfFigures") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_OF_FIGURES;
        if (value == "EnvelopeAddress") return aspose::words::cloud::models::Font::StyleIdentifier::ENVELOPE_ADDRESS;
        if (value == "EnvelopeReturn") return aspose::words::cloud::models::Font::StyleIdentifier::ENVELOPE_RETURN;
        if (value == "FootnoteReference") return aspose::words::cloud::models::Font::StyleIdentifier::FOOTNOTE_REFERENCE;
        if (value == "CommentReference") return aspose::words::cloud::models::Font::StyleIdentifier::COMMENT_REFERENCE;
        if (value == "LineNumber") return aspose::words::cloud::models::Font::StyleIdentifier::LINE_NUMBER;
        if (value == "PageNumber") return aspose::words::cloud::models::Font::StyleIdentifier::PAGE_NUMBER;
        if (value == "EndnoteReference") return aspose::words::cloud::models::Font::StyleIdentifier::ENDNOTE_REFERENCE;
        if (value == "EndnoteText") return aspose::words::cloud::models::Font::StyleIdentifier::ENDNOTE_TEXT;
        if (value == "TableOfAuthorities") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_OF_AUTHORITIES;
        if (value == "Macro") return aspose::words::cloud::models::Font::StyleIdentifier::MACRO;
        if (value == "ToaHeading") return aspose::words::cloud::models::Font::StyleIdentifier::TOA_HEADING;
        if (value == "List") return aspose::words::cloud::models::Font::StyleIdentifier::LIST;
        if (value == "ListBullet") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_BULLET;
        if (value == "ListNumber") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_NUMBER;
        if (value == "List2") return aspose::words::cloud::models::Font::StyleIdentifier::LIST2;
        if (value == "List3") return aspose::words::cloud::models::Font::StyleIdentifier::LIST3;
        if (value == "List4") return aspose::words::cloud::models::Font::StyleIdentifier::LIST4;
        if (value == "List5") return aspose::words::cloud::models::Font::StyleIdentifier::LIST5;
        if (value == "ListBullet2") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_BULLET2;
        if (value == "ListBullet3") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_BULLET3;
        if (value == "ListBullet4") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_BULLET4;
        if (value == "ListBullet5") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_BULLET5;
        if (value == "ListNumber2") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_NUMBER2;
        if (value == "ListNumber3") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_NUMBER3;
        if (value == "ListNumber4") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_NUMBER4;
        if (value == "ListNumber5") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_NUMBER5;
        if (value == "Title") return aspose::words::cloud::models::Font::StyleIdentifier::TITLE;
        if (value == "Closing") return aspose::words::cloud::models::Font::StyleIdentifier::CLOSING;
        if (value == "Signature") return aspose::words::cloud::models::Font::StyleIdentifier::SIGNATURE;
        if (value == "DefaultParagraphFont") return aspose::words::cloud::models::Font::StyleIdentifier::DEFAULT_PARAGRAPH_FONT;
        if (value == "BodyText") return aspose::words::cloud::models::Font::StyleIdentifier::BODY_TEXT;
        if (value == "BodyTextInd") return aspose::words::cloud::models::Font::StyleIdentifier::BODY_TEXT_IND;
        if (value == "ListContinue") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_CONTINUE;
        if (value == "ListContinue2") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_CONTINUE2;
        if (value == "ListContinue3") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_CONTINUE3;
        if (value == "ListContinue4") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_CONTINUE4;
        if (value == "ListContinue5") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_CONTINUE5;
        if (value == "MessageHeader") return aspose::words::cloud::models::Font::StyleIdentifier::MESSAGE_HEADER;
        if (value == "Subtitle") return aspose::words::cloud::models::Font::StyleIdentifier::SUBTITLE;
        if (value == "Salutation") return aspose::words::cloud::models::Font::StyleIdentifier::SALUTATION;
        if (value == "Date") return aspose::words::cloud::models::Font::StyleIdentifier::DATE;
        if (value == "BodyText1I") return aspose::words::cloud::models::Font::StyleIdentifier::BODY_TEXT1_I;
        if (value == "BodyText1I2") return aspose::words::cloud::models::Font::StyleIdentifier::BODY_TEXT1_I2;
        if (value == "NoteHeading") return aspose::words::cloud::models::Font::StyleIdentifier::NOTE_HEADING;
        if (value == "BodyText2") return aspose::words::cloud::models::Font::StyleIdentifier::BODY_TEXT2;
        if (value == "BodyText3") return aspose::words::cloud::models::Font::StyleIdentifier::BODY_TEXT3;
        if (value == "BodyTextInd2") return aspose::words::cloud::models::Font::StyleIdentifier::BODY_TEXT_IND2;
        if (value == "BodyTextInd3") return aspose::words::cloud::models::Font::StyleIdentifier::BODY_TEXT_IND3;
        if (value == "BlockText") return aspose::words::cloud::models::Font::StyleIdentifier::BLOCK_TEXT;
        if (value == "Hyperlink") return aspose::words::cloud::models::Font::StyleIdentifier::HYPERLINK;
        if (value == "FollowedHyperlink") return aspose::words::cloud::models::Font::StyleIdentifier::FOLLOWED_HYPERLINK;
        if (value == "Strong") return aspose::words::cloud::models::Font::StyleIdentifier::STRONG;
        if (value == "Emphasis") return aspose::words::cloud::models::Font::StyleIdentifier::EMPHASIS;
        if (value == "DocumentMap") return aspose::words::cloud::models::Font::StyleIdentifier::DOCUMENT_MAP;
        if (value == "PlainText") return aspose::words::cloud::models::Font::StyleIdentifier::PLAIN_TEXT;
        if (value == "EmailSignature") return aspose::words::cloud::models::Font::StyleIdentifier::EMAIL_SIGNATURE;
        if (value == "HtmlTopOfForm") return aspose::words::cloud::models::Font::StyleIdentifier::HTML_TOP_OF_FORM;
        if (value == "HtmlBottomOfForm") return aspose::words::cloud::models::Font::StyleIdentifier::HTML_BOTTOM_OF_FORM;
        if (value == "NormalWeb") return aspose::words::cloud::models::Font::StyleIdentifier::NORMAL_WEB;
        if (value == "HtmlAcronym") return aspose::words::cloud::models::Font::StyleIdentifier::HTML_ACRONYM;
        if (value == "HtmlAddress") return aspose::words::cloud::models::Font::StyleIdentifier::HTML_ADDRESS;
        if (value == "HtmlCite") return aspose::words::cloud::models::Font::StyleIdentifier::HTML_CITE;
        if (value == "HtmlCode") return aspose::words::cloud::models::Font::StyleIdentifier::HTML_CODE;
        if (value == "HtmlDefinition") return aspose::words::cloud::models::Font::StyleIdentifier::HTML_DEFINITION;
        if (value == "HtmlKeyboard") return aspose::words::cloud::models::Font::StyleIdentifier::HTML_KEYBOARD;
        if (value == "HtmlPreformatted") return aspose::words::cloud::models::Font::StyleIdentifier::HTML_PREFORMATTED;
        if (value == "HtmlSample") return aspose::words::cloud::models::Font::StyleIdentifier::HTML_SAMPLE;
        if (value == "HtmlTypewriter") return aspose::words::cloud::models::Font::StyleIdentifier::HTML_TYPEWRITER;
        if (value == "HtmlVariable") return aspose::words::cloud::models::Font::StyleIdentifier::HTML_VARIABLE;
        if (value == "TableNormal") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_NORMAL;
        if (value == "CommentSubject") return aspose::words::cloud::models::Font::StyleIdentifier::COMMENT_SUBJECT;
        if (value == "NoList") return aspose::words::cloud::models::Font::StyleIdentifier::NO_LIST;
        if (value == "OutlineList1") return aspose::words::cloud::models::Font::StyleIdentifier::OUTLINE_LIST1;
        if (value == "OutlineList2") return aspose::words::cloud::models::Font::StyleIdentifier::OUTLINE_LIST2;
        if (value == "OutlineList3") return aspose::words::cloud::models::Font::StyleIdentifier::OUTLINE_LIST3;
        if (value == "TableSimple1") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_SIMPLE1;
        if (value == "TableSimple2") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_SIMPLE2;
        if (value == "TableSimple3") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_SIMPLE3;
        if (value == "TableClassic1") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_CLASSIC1;
        if (value == "TableClassic2") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_CLASSIC2;
        if (value == "TableClassic3") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_CLASSIC3;
        if (value == "TableClassic4") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_CLASSIC4;
        if (value == "TableColorful1") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_COLORFUL1;
        if (value == "TableColorful2") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_COLORFUL2;
        if (value == "TableColorful3") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_COLORFUL3;
        if (value == "TableColumns1") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_COLUMNS1;
        if (value == "TableColumns2") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_COLUMNS2;
        if (value == "TableColumns3") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_COLUMNS3;
        if (value == "TableColumns4") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_COLUMNS4;
        if (value == "TableColumns5") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_COLUMNS5;
        if (value == "TableGrid1") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID1;
        if (value == "TableGrid2") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID2;
        if (value == "TableGrid3") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID3;
        if (value == "TableGrid4") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID4;
        if (value == "TableGrid5") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID5;
        if (value == "TableGrid6") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID6;
        if (value == "TableGrid7") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID7;
        if (value == "TableGrid8") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID8;
        if (value == "TableList1") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_LIST1;
        if (value == "TableList2") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_LIST2;
        if (value == "TableList3") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_LIST3;
        if (value == "TableList4") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_LIST4;
        if (value == "TableList5") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_LIST5;
        if (value == "TableList6") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_LIST6;
        if (value == "TableList7") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_LIST7;
        if (value == "TableList8") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_LIST8;
        if (value == "Table3DEffects1") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE3_D_EFFECTS1;
        if (value == "Table3DEffects2") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE3_D_EFFECTS2;
        if (value == "Table3DEffects3") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE3_D_EFFECTS3;
        if (value == "TableContemporary") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_CONTEMPORARY;
        if (value == "TableElegant") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_ELEGANT;
        if (value == "TableProfessional") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_PROFESSIONAL;
        if (value == "TableSubtle1") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_SUBTLE1;
        if (value == "TableSubtle2") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_SUBTLE2;
        if (value == "TableWeb1") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_WEB1;
        if (value == "TableWeb2") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_WEB2;
        if (value == "TableWeb3") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_WEB3;
        if (value == "BalloonText") return aspose::words::cloud::models::Font::StyleIdentifier::BALLOON_TEXT;
        if (value == "TableGrid") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID;
        if (value == "TableTheme") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_THEME;
        if (value == "PlaceholderText") return aspose::words::cloud::models::Font::StyleIdentifier::PLACEHOLDER_TEXT;
        if (value == "NoSpacing") return aspose::words::cloud::models::Font::StyleIdentifier::NO_SPACING;
        if (value == "LightShading") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_SHADING;
        if (value == "LightList") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_LIST;
        if (value == "LightGrid") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_GRID;
        if (value == "MediumShading1") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING1;
        if (value == "MediumShading2") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING2;
        if (value == "MediumList1") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST1;
        if (value == "MediumList2") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST2;
        if (value == "MediumGrid1") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID1;
        if (value == "MediumGrid2") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID2;
        if (value == "MediumGrid3") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID3;
        if (value == "DarkList") return aspose::words::cloud::models::Font::StyleIdentifier::DARK_LIST;
        if (value == "ColorfulShading") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_SHADING;
        if (value == "ColorfulList") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_LIST;
        if (value == "ColorfulGrid") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_GRID;
        if (value == "LightShadingAccent1") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_SHADING_ACCENT1;
        if (value == "LightListAccent1") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_LIST_ACCENT1;
        if (value == "LightGridAccent1") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_GRID_ACCENT1;
        if (value == "MediumShading1Accent1") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING1_ACCENT1;
        if (value == "MediumShading2Accent1") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING2_ACCENT1;
        if (value == "MediumList1Accent1") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST1_ACCENT1;
        if (value == "Revision") return aspose::words::cloud::models::Font::StyleIdentifier::REVISION;
        if (value == "ListParagraph") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_PARAGRAPH;
        if (value == "Quote") return aspose::words::cloud::models::Font::StyleIdentifier::QUOTE;
        if (value == "IntenseQuote") return aspose::words::cloud::models::Font::StyleIdentifier::INTENSE_QUOTE;
        if (value == "MediumList2Accent1") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST2_ACCENT1;
        if (value == "MediumGrid1Accent1") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID1_ACCENT1;
        if (value == "MediumGrid2Accent1") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID2_ACCENT1;
        if (value == "MediumGrid3Accent1") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID3_ACCENT1;
        if (value == "DarkListAccent1") return aspose::words::cloud::models::Font::StyleIdentifier::DARK_LIST_ACCENT1;
        if (value == "ColorfulShadingAccent1") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_SHADING_ACCENT1;
        if (value == "ColorfulListAccent1") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_LIST_ACCENT1;
        if (value == "ColorfulGridAccent1") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_GRID_ACCENT1;
        if (value == "LightShadingAccent2") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_SHADING_ACCENT2;
        if (value == "LightListAccent2") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_LIST_ACCENT2;
        if (value == "LightGridAccent2") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_GRID_ACCENT2;
        if (value == "MediumShading1Accent2") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING1_ACCENT2;
        if (value == "MediumShading2Accent2") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING2_ACCENT2;
        if (value == "MediumList1Accent2") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST1_ACCENT2;
        if (value == "MediumList2Accent2") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST2_ACCENT2;
        if (value == "MediumGrid1Accent2") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID1_ACCENT2;
        if (value == "MediumGrid2Accent2") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID2_ACCENT2;
        if (value == "MediumGrid3Accent2") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID3_ACCENT2;
        if (value == "DarkListAccent2") return aspose::words::cloud::models::Font::StyleIdentifier::DARK_LIST_ACCENT2;
        if (value == "ColorfulShadingAccent2") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_SHADING_ACCENT2;
        if (value == "ColorfulListAccent2") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_LIST_ACCENT2;
        if (value == "ColorfulGridAccent2") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_GRID_ACCENT2;
        if (value == "LightShadingAccent3") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_SHADING_ACCENT3;
        if (value == "LightListAccent3") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_LIST_ACCENT3;
        if (value == "LightGridAccent3") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_GRID_ACCENT3;
        if (value == "MediumShading1Accent3") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING1_ACCENT3;
        if (value == "MediumShading2Accent3") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING2_ACCENT3;
        if (value == "MediumList1Accent3") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST1_ACCENT3;
        if (value == "MediumList2Accent3") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST2_ACCENT3;
        if (value == "MediumGrid1Accent3") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID1_ACCENT3;
        if (value == "MediumGrid2Accent3") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID2_ACCENT3;
        if (value == "MediumGrid3Accent3") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID3_ACCENT3;
        if (value == "DarkListAccent3") return aspose::words::cloud::models::Font::StyleIdentifier::DARK_LIST_ACCENT3;
        if (value == "ColorfulShadingAccent3") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_SHADING_ACCENT3;
        if (value == "ColorfulListAccent3") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_LIST_ACCENT3;
        if (value == "ColorfulGridAccent3") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_GRID_ACCENT3;
        if (value == "LightShadingAccent4") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_SHADING_ACCENT4;
        if (value == "LightListAccent4") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_LIST_ACCENT4;
        if (value == "LightGridAccent4") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_GRID_ACCENT4;
        if (value == "MediumShading1Accent4") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING1_ACCENT4;
        if (value == "MediumShading2Accent4") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING2_ACCENT4;
        if (value == "MediumList1Accent4") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST1_ACCENT4;
        if (value == "MediumList2Accent4") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST2_ACCENT4;
        if (value == "MediumGrid1Accent4") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID1_ACCENT4;
        if (value == "MediumGrid2Accent4") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID2_ACCENT4;
        if (value == "MediumGrid3Accent4") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID3_ACCENT4;
        if (value == "DarkListAccent4") return aspose::words::cloud::models::Font::StyleIdentifier::DARK_LIST_ACCENT4;
        if (value == "ColorfulShadingAccent4") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_SHADING_ACCENT4;
        if (value == "ColorfulListAccent4") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_LIST_ACCENT4;
        if (value == "ColorfulGridAccent4") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_GRID_ACCENT4;
        if (value == "LightShadingAccent5") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_SHADING_ACCENT5;
        if (value == "LightListAccent5") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_LIST_ACCENT5;
        if (value == "LightGridAccent5") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_GRID_ACCENT5;
        if (value == "MediumShading1Accent5") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING1_ACCENT5;
        if (value == "MediumShading2Accent5") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING2_ACCENT5;
        if (value == "MediumList1Accent5") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST1_ACCENT5;
        if (value == "MediumList2Accent5") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST2_ACCENT5;
        if (value == "MediumGrid1Accent5") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID1_ACCENT5;
        if (value == "MediumGrid2Accent5") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID2_ACCENT5;
        if (value == "MediumGrid3Accent5") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID3_ACCENT5;
        if (value == "DarkListAccent5") return aspose::words::cloud::models::Font::StyleIdentifier::DARK_LIST_ACCENT5;
        if (value == "ColorfulShadingAccent5") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_SHADING_ACCENT5;
        if (value == "ColorfulListAccent5") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_LIST_ACCENT5;
        if (value == "ColorfulGridAccent5") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_GRID_ACCENT5;
        if (value == "LightShadingAccent6") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_SHADING_ACCENT6;
        if (value == "LightListAccent6") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_LIST_ACCENT6;
        if (value == "LightGridAccent6") return aspose::words::cloud::models::Font::StyleIdentifier::LIGHT_GRID_ACCENT6;
        if (value == "MediumShading1Accent6") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING1_ACCENT6;
        if (value == "MediumShading2Accent6") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_SHADING2_ACCENT6;
        if (value == "MediumList1Accent6") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST1_ACCENT6;
        if (value == "MediumList2Accent6") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_LIST2_ACCENT6;
        if (value == "MediumGrid1Accent6") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID1_ACCENT6;
        if (value == "MediumGrid2Accent6") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID2_ACCENT6;
        if (value == "MediumGrid3Accent6") return aspose::words::cloud::models::Font::StyleIdentifier::MEDIUM_GRID3_ACCENT6;
        if (value == "DarkListAccent6") return aspose::words::cloud::models::Font::StyleIdentifier::DARK_LIST_ACCENT6;
        if (value == "ColorfulShadingAccent6") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_SHADING_ACCENT6;
        if (value == "ColorfulListAccent6") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_LIST_ACCENT6;
        if (value == "ColorfulGridAccent6") return aspose::words::cloud::models::Font::StyleIdentifier::COLORFUL_GRID_ACCENT6;
        if (value == "SubtleEmphasis") return aspose::words::cloud::models::Font::StyleIdentifier::SUBTLE_EMPHASIS;
        if (value == "IntenseEmphasis") return aspose::words::cloud::models::Font::StyleIdentifier::INTENSE_EMPHASIS;
        if (value == "SubtleReference") return aspose::words::cloud::models::Font::StyleIdentifier::SUBTLE_REFERENCE;
        if (value == "IntenseReference") return aspose::words::cloud::models::Font::StyleIdentifier::INTENSE_REFERENCE;
        if (value == "BookTitle") return aspose::words::cloud::models::Font::StyleIdentifier::BOOK_TITLE;
        if (value == "Bibliography") return aspose::words::cloud::models::Font::StyleIdentifier::BIBLIOGRAPHY;
        if (value == "TocHeading") return aspose::words::cloud::models::Font::StyleIdentifier::TOC_HEADING;
        if (value == "PlainTable1") return aspose::words::cloud::models::Font::StyleIdentifier::PLAIN_TABLE1;
        if (value == "PlainTable2") return aspose::words::cloud::models::Font::StyleIdentifier::PLAIN_TABLE2;
        if (value == "PlainTable3") return aspose::words::cloud::models::Font::StyleIdentifier::PLAIN_TABLE3;
        if (value == "PlainTable4") return aspose::words::cloud::models::Font::StyleIdentifier::PLAIN_TABLE4;
        if (value == "PlainTable5") return aspose::words::cloud::models::Font::StyleIdentifier::PLAIN_TABLE5;
        if (value == "TableGridLight") return aspose::words::cloud::models::Font::StyleIdentifier::TABLE_GRID_LIGHT;
        if (value == "GridTable1Light") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE1_LIGHT;
        if (value == "GridTable2") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE2;
        if (value == "GridTable3") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE3;
        if (value == "GridTable4") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE4;
        if (value == "GridTable5Dark") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE5_DARK;
        if (value == "GridTable6Colorful") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE6_COLORFUL;
        if (value == "GridTable7Colorful") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE7_COLORFUL;
        if (value == "GridTable1LightAccent1") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT1;
        if (value == "GridTable2Accent1") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE2_ACCENT1;
        if (value == "GridTable3Accent1") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE3_ACCENT1;
        if (value == "GridTable4Accent1") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE4_ACCENT1;
        if (value == "GridTable5DarkAccent1") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE5_DARK_ACCENT1;
        if (value == "GridTable6ColorfulAccent1") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT1;
        if (value == "GridTable7ColorfulAccent1") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT1;
        if (value == "GridTable1LightAccent2") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT2;
        if (value == "GridTable2Accent2") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE2_ACCENT2;
        if (value == "GridTable3Accent2") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE3_ACCENT2;
        if (value == "GridTable4Accent2") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE4_ACCENT2;
        if (value == "GridTable5DarkAccent2") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE5_DARK_ACCENT2;
        if (value == "GridTable6ColorfulAccent2") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT2;
        if (value == "GridTable7ColorfulAccent2") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT2;
        if (value == "GridTable1LightAccent3") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT3;
        if (value == "GridTable2Accent3") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE2_ACCENT3;
        if (value == "GridTable3Accent3") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE3_ACCENT3;
        if (value == "GridTable4Accent3") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE4_ACCENT3;
        if (value == "GridTable5DarkAccent3") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE5_DARK_ACCENT3;
        if (value == "GridTable6ColorfulAccent3") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT3;
        if (value == "GridTable7ColorfulAccent3") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT3;
        if (value == "GridTable1LightAccent4") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT4;
        if (value == "GridTable2Accent4") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE2_ACCENT4;
        if (value == "GridTable3Accent4") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE3_ACCENT4;
        if (value == "GridTable4Accent4") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE4_ACCENT4;
        if (value == "GridTable5DarkAccent4") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE5_DARK_ACCENT4;
        if (value == "GridTable6ColorfulAccent4") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT4;
        if (value == "GridTable7ColorfulAccent4") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT4;
        if (value == "GridTable1LightAccent5") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT5;
        if (value == "GridTable2Accent5") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE2_ACCENT5;
        if (value == "GridTable3Accent5") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE3_ACCENT5;
        if (value == "GridTable4Accent5") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE4_ACCENT5;
        if (value == "GridTable5DarkAccent5") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE5_DARK_ACCENT5;
        if (value == "GridTable6ColorfulAccent5") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT5;
        if (value == "GridTable7ColorfulAccent5") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT5;
        if (value == "GridTable1LightAccent6") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT6;
        if (value == "GridTable2Accent6") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE2_ACCENT6;
        if (value == "GridTable3Accent6") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE3_ACCENT6;
        if (value == "GridTable4Accent6") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE4_ACCENT6;
        if (value == "GridTable5DarkAccent6") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE5_DARK_ACCENT6;
        if (value == "GridTable6ColorfulAccent6") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT6;
        if (value == "GridTable7ColorfulAccent6") return aspose::words::cloud::models::Font::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT6;
        if (value == "ListTable1Light") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE1_LIGHT;
        if (value == "ListTable2") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE2;
        if (value == "ListTable3") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE3;
        if (value == "ListTable4") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE4;
        if (value == "ListTable5Dark") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE5_DARK;
        if (value == "ListTable6Colorful") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE6_COLORFUL;
        if (value == "ListTable7Colorful") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE7_COLORFUL;
        if (value == "ListTable1LightAccent1") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT1;
        if (value == "ListTable2Accent1") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE2_ACCENT1;
        if (value == "ListTable3Accent1") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE3_ACCENT1;
        if (value == "ListTable4Accent1") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE4_ACCENT1;
        if (value == "ListTable5DarkAccent1") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE5_DARK_ACCENT1;
        if (value == "ListTable6ColorfulAccent1") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT1;
        if (value == "ListTable7ColorfulAccent1") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT1;
        if (value == "ListTable1LightAccent2") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT2;
        if (value == "ListTable2Accent2") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE2_ACCENT2;
        if (value == "ListTable3Accent2") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE3_ACCENT2;
        if (value == "ListTable4Accent2") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE4_ACCENT2;
        if (value == "ListTable5DarkAccent2") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE5_DARK_ACCENT2;
        if (value == "ListTable6ColorfulAccent2") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT2;
        if (value == "ListTable7ColorfulAccent2") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT2;
        if (value == "ListTable1LightAccent3") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT3;
        if (value == "ListTable2Accent3") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE2_ACCENT3;
        if (value == "ListTable3Accent3") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE3_ACCENT3;
        if (value == "ListTable4Accent3") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE4_ACCENT3;
        if (value == "ListTable5DarkAccent3") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE5_DARK_ACCENT3;
        if (value == "ListTable6ColorfulAccent3") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT3;
        if (value == "ListTable7ColorfulAccent3") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT3;
        if (value == "ListTable1LightAccent4") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT4;
        if (value == "ListTable2Accent4") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE2_ACCENT4;
        if (value == "ListTable3Accent4") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE3_ACCENT4;
        if (value == "ListTable4Accent4") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE4_ACCENT4;
        if (value == "ListTable5DarkAccent4") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE5_DARK_ACCENT4;
        if (value == "ListTable6ColorfulAccent4") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT4;
        if (value == "ListTable7ColorfulAccent4") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT4;
        if (value == "ListTable1LightAccent5") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT5;
        if (value == "ListTable2Accent5") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE2_ACCENT5;
        if (value == "ListTable3Accent5") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE3_ACCENT5;
        if (value == "ListTable4Accent5") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE4_ACCENT5;
        if (value == "ListTable5DarkAccent5") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE5_DARK_ACCENT5;
        if (value == "ListTable6ColorfulAccent5") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT5;
        if (value == "ListTable7ColorfulAccent5") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT5;
        if (value == "ListTable1LightAccent6") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT6;
        if (value == "ListTable2Accent6") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE2_ACCENT6;
        if (value == "ListTable3Accent6") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE3_ACCENT6;
        if (value == "ListTable4Accent6") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE4_ACCENT6;
        if (value == "ListTable5DarkAccent6") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE5_DARK_ACCENT6;
        if (value == "ListTable6ColorfulAccent6") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT6;
        if (value == "ListTable7ColorfulAccent6") return aspose::words::cloud::models::Font::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT6;
        if (value == "SmartLink") return aspose::words::cloud::models::Font::StyleIdentifier::SMART_LINK;
        if (value == "Mention") return aspose::words::cloud::models::Font::StyleIdentifier::MENTION;
        if (value == "SmartHyperlink") return aspose::words::cloud::models::Font::StyleIdentifier::SMART_HYPERLINK;
        if (value == "Hashtag") return aspose::words::cloud::models::Font::StyleIdentifier::HASHTAG;
        if (value == "UnresolvedMention") return aspose::words::cloud::models::Font::StyleIdentifier::UNRESOLVED_MENTION;
        if (value == "User") return aspose::words::cloud::models::Font::StyleIdentifier::USER;
        if (value == "Nil") return aspose::words::cloud::models::Font::StyleIdentifier::NIL;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string fontTextEffectToString(aspose::words::cloud::models::Font::TextEffect value)
    {
        if (value == aspose::words::cloud::models::Font::TextEffect::NONE) return "None";
        if (value == aspose::words::cloud::models::Font::TextEffect::LAS_VEGAS_LIGHTS) return "LasVegasLights";
        if (value == aspose::words::cloud::models::Font::TextEffect::BLINKING_BACKGROUND) return "BlinkingBackground";
        if (value == aspose::words::cloud::models::Font::TextEffect::SPARKLE_TEXT) return "SparkleText";
        if (value == aspose::words::cloud::models::Font::TextEffect::MARCHING_BLACK_ANTS) return "MarchingBlackAnts";
        if (value == aspose::words::cloud::models::Font::TextEffect::MARCHING_RED_ANTS) return "MarchingRedAnts";
        if (value == aspose::words::cloud::models::Font::TextEffect::SHIMMER) return "Shimmer";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::Font::TextEffect fontTextEffectFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::Font::TextEffect::NONE;
        if (value == "LasVegasLights") return aspose::words::cloud::models::Font::TextEffect::LAS_VEGAS_LIGHTS;
        if (value == "BlinkingBackground") return aspose::words::cloud::models::Font::TextEffect::BLINKING_BACKGROUND;
        if (value == "SparkleText") return aspose::words::cloud::models::Font::TextEffect::SPARKLE_TEXT;
        if (value == "MarchingBlackAnts") return aspose::words::cloud::models::Font::TextEffect::MARCHING_BLACK_ANTS;
        if (value == "MarchingRedAnts") return aspose::words::cloud::models::Font::TextEffect::MARCHING_RED_ANTS;
        if (value == "Shimmer") return aspose::words::cloud::models::Font::TextEffect::SHIMMER;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string fontUnderlineToString(aspose::words::cloud::models::Font::Underline value)
    {
        if (value == aspose::words::cloud::models::Font::Underline::NONE) return "None";
        if (value == aspose::words::cloud::models::Font::Underline::SINGLE) return "Single";
        if (value == aspose::words::cloud::models::Font::Underline::WORDS) return "Words";
        if (value == aspose::words::cloud::models::Font::Underline::DOUBLE) return "Double";
        if (value == aspose::words::cloud::models::Font::Underline::DOTTED) return "Dotted";
        if (value == aspose::words::cloud::models::Font::Underline::THICK) return "Thick";
        if (value == aspose::words::cloud::models::Font::Underline::DASH) return "Dash";
        if (value == aspose::words::cloud::models::Font::Underline::DOT_DASH) return "DotDash";
        if (value == aspose::words::cloud::models::Font::Underline::DOT_DOT_DASH) return "DotDotDash";
        if (value == aspose::words::cloud::models::Font::Underline::WAVY) return "Wavy";
        if (value == aspose::words::cloud::models::Font::Underline::DOTTED_HEAVY) return "DottedHeavy";
        if (value == aspose::words::cloud::models::Font::Underline::DASH_HEAVY) return "DashHeavy";
        if (value == aspose::words::cloud::models::Font::Underline::DOT_DASH_HEAVY) return "DotDashHeavy";
        if (value == aspose::words::cloud::models::Font::Underline::DOT_DOT_DASH_HEAVY) return "DotDotDashHeavy";
        if (value == aspose::words::cloud::models::Font::Underline::WAVY_HEAVY) return "WavyHeavy";
        if (value == aspose::words::cloud::models::Font::Underline::DASH_LONG) return "DashLong";
        if (value == aspose::words::cloud::models::Font::Underline::WAVY_DOUBLE) return "WavyDouble";
        if (value == aspose::words::cloud::models::Font::Underline::DASH_LONG_HEAVY) return "DashLongHeavy";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::Font::Underline fontUnderlineFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::Font::Underline::NONE;
        if (value == "Single") return aspose::words::cloud::models::Font::Underline::SINGLE;
        if (value == "Words") return aspose::words::cloud::models::Font::Underline::WORDS;
        if (value == "Double") return aspose::words::cloud::models::Font::Underline::DOUBLE;
        if (value == "Dotted") return aspose::words::cloud::models::Font::Underline::DOTTED;
        if (value == "Thick") return aspose::words::cloud::models::Font::Underline::THICK;
        if (value == "Dash") return aspose::words::cloud::models::Font::Underline::DASH;
        if (value == "DotDash") return aspose::words::cloud::models::Font::Underline::DOT_DASH;
        if (value == "DotDotDash") return aspose::words::cloud::models::Font::Underline::DOT_DOT_DASH;
        if (value == "Wavy") return aspose::words::cloud::models::Font::Underline::WAVY;
        if (value == "DottedHeavy") return aspose::words::cloud::models::Font::Underline::DOTTED_HEAVY;
        if (value == "DashHeavy") return aspose::words::cloud::models::Font::Underline::DASH_HEAVY;
        if (value == "DotDashHeavy") return aspose::words::cloud::models::Font::Underline::DOT_DASH_HEAVY;
        if (value == "DotDotDashHeavy") return aspose::words::cloud::models::Font::Underline::DOT_DOT_DASH_HEAVY;
        if (value == "WavyHeavy") return aspose::words::cloud::models::Font::Underline::WAVY_HEAVY;
        if (value == "DashLong") return aspose::words::cloud::models::Font::Underline::DASH_LONG;
        if (value == "WavyDouble") return aspose::words::cloud::models::Font::Underline::WAVY_DOUBLE;
        if (value == "DashLongHeavy") return aspose::words::cloud::models::Font::Underline::DASH_LONG_HEAVY;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void Font::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_AllCaps) {
            json["AllCaps"] = *(this->m_AllCaps);
        }
        if (this->m_Bidi) {
            json["Bidi"] = *(this->m_Bidi);
        }
        if (this->m_Bold) {
            json["Bold"] = *(this->m_Bold);
        }
        if (this->m_BoldBi) {
            json["BoldBi"] = *(this->m_BoldBi);
        }
        if (this->m_Border) {
            this->m_Border->toJson(&json["Border"]);
        }
        if (this->m_Color) {
            this->m_Color->toJson(&json["Color"]);
        }
        if (this->m_ComplexScript) {
            json["ComplexScript"] = *(this->m_ComplexScript);
        }
        if (this->m_DoubleStrikeThrough) {
            json["DoubleStrikeThrough"] = *(this->m_DoubleStrikeThrough);
        }
        if (this->m_Emboss) {
            json["Emboss"] = *(this->m_Emboss);
        }
        if (this->m_Engrave) {
            json["Engrave"] = *(this->m_Engrave);
        }
        if (this->m_Hidden) {
            json["Hidden"] = *(this->m_Hidden);
        }
        if (this->m_HighlightColor) {
            this->m_HighlightColor->toJson(&json["HighlightColor"]);
        }
        if (this->m_Italic) {
            json["Italic"] = *(this->m_Italic);
        }
        if (this->m_ItalicBi) {
            json["ItalicBi"] = *(this->m_ItalicBi);
        }
        if (this->m_Kerning) {
            json["Kerning"] = *(this->m_Kerning);
        }
        if (this->m_LocaleId) {
            json["LocaleId"] = *(this->m_LocaleId);
        }
        if (this->m_LocaleIdBi) {
            json["LocaleIdBi"] = *(this->m_LocaleIdBi);
        }
        if (this->m_LocaleIdFarEast) {
            json["LocaleIdFarEast"] = *(this->m_LocaleIdFarEast);
        }
        if (this->m_Name) {
            json["Name"] = convertUtf16(*(this->m_Name));
        }
        if (this->m_NameAscii) {
            json["NameAscii"] = convertUtf16(*(this->m_NameAscii));
        }
        if (this->m_NameBi) {
            json["NameBi"] = convertUtf16(*(this->m_NameBi));
        }
        if (this->m_NameFarEast) {
            json["NameFarEast"] = convertUtf16(*(this->m_NameFarEast));
        }
        if (this->m_NameOther) {
            json["NameOther"] = convertUtf16(*(this->m_NameOther));
        }
        if (this->m_NoProofing) {
            json["NoProofing"] = *(this->m_NoProofing);
        }
        if (this->m_Outline) {
            json["Outline"] = *(this->m_Outline);
        }
        if (this->m_Position) {
            json["Position"] = *(this->m_Position);
        }
        if (this->m_Scaling) {
            json["Scaling"] = *(this->m_Scaling);
        }
        if (this->m_Shadow) {
            json["Shadow"] = *(this->m_Shadow);
        }
        if (this->m_Size) {
            json["Size"] = *(this->m_Size);
        }
        if (this->m_SizeBi) {
            json["SizeBi"] = *(this->m_SizeBi);
        }
        if (this->m_SmallCaps) {
            json["SmallCaps"] = *(this->m_SmallCaps);
        }
        if (this->m_Spacing) {
            json["Spacing"] = *(this->m_Spacing);
        }
        if (this->m_StrikeThrough) {
            json["StrikeThrough"] = *(this->m_StrikeThrough);
        }
        if (this->m_StyleIdentifier) {
            json["StyleIdentifier"] = fontStyleIdentifierToString(*(this->m_StyleIdentifier));
        }
        if (this->m_StyleName) {
            json["StyleName"] = convertUtf16(*(this->m_StyleName));
        }
        if (this->m_Subscript) {
            json["Subscript"] = *(this->m_Subscript);
        }
        if (this->m_Superscript) {
            json["Superscript"] = *(this->m_Superscript);
        }
        if (this->m_TextEffect) {
            json["TextEffect"] = fontTextEffectToString(*(this->m_TextEffect));
        }
        if (this->m_Underline) {
            json["Underline"] = fontUnderlineToString(*(this->m_Underline));
        }
        if (this->m_UnderlineColor) {
            this->m_UnderlineColor->toJson(&json["UnderlineColor"]);
        }
    }

    void Font::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("AllCaps") && !json["AllCaps"].is_null()) {
            this->m_AllCaps = std::make_shared< bool >(
                json["AllCaps"].get< bool >()
            );
        }
        if (json.contains("Bidi") && !json["Bidi"].is_null()) {
            this->m_Bidi = std::make_shared< bool >(
                json["Bidi"].get< bool >()
            );
        }
        if (json.contains("Bold") && !json["Bold"].is_null()) {
            this->m_Bold = std::make_shared< bool >(
                json["Bold"].get< bool >()
            );
        }
        if (json.contains("BoldBi") && !json["BoldBi"].is_null()) {
            this->m_BoldBi = std::make_shared< bool >(
                json["BoldBi"].get< bool >()
            );
        }
        if (json.contains("Border") && !json["Border"].is_null()) {
            this->m_Border = createModelInstance< aspose::words::cloud::models::Border >(L"Border, _", json["Border"]);
        }
        if (json.contains("Color") && !json["Color"].is_null()) {
            this->m_Color = createModelInstance< aspose::words::cloud::models::XmlColor >(L"XmlColor, _", json["Color"]);
        }
        if (json.contains("ComplexScript") && !json["ComplexScript"].is_null()) {
            this->m_ComplexScript = std::make_shared< bool >(
                json["ComplexScript"].get< bool >()
            );
        }
        if (json.contains("DoubleStrikeThrough") && !json["DoubleStrikeThrough"].is_null()) {
            this->m_DoubleStrikeThrough = std::make_shared< bool >(
                json["DoubleStrikeThrough"].get< bool >()
            );
        }
        if (json.contains("Emboss") && !json["Emboss"].is_null()) {
            this->m_Emboss = std::make_shared< bool >(
                json["Emboss"].get< bool >()
            );
        }
        if (json.contains("Engrave") && !json["Engrave"].is_null()) {
            this->m_Engrave = std::make_shared< bool >(
                json["Engrave"].get< bool >()
            );
        }
        if (json.contains("Hidden") && !json["Hidden"].is_null()) {
            this->m_Hidden = std::make_shared< bool >(
                json["Hidden"].get< bool >()
            );
        }
        if (json.contains("HighlightColor") && !json["HighlightColor"].is_null()) {
            this->m_HighlightColor = createModelInstance< aspose::words::cloud::models::XmlColor >(L"XmlColor, _", json["HighlightColor"]);
        }
        if (json.contains("Italic") && !json["Italic"].is_null()) {
            this->m_Italic = std::make_shared< bool >(
                json["Italic"].get< bool >()
            );
        }
        if (json.contains("ItalicBi") && !json["ItalicBi"].is_null()) {
            this->m_ItalicBi = std::make_shared< bool >(
                json["ItalicBi"].get< bool >()
            );
        }
        if (json.contains("Kerning") && !json["Kerning"].is_null()) {
            this->m_Kerning = std::make_shared< double >(
                json["Kerning"].get< double >()
            );
        }
        if (json.contains("LocaleId") && !json["LocaleId"].is_null()) {
            this->m_LocaleId = std::make_shared< int32_t >(
                json["LocaleId"].get< int32_t >()
            );
        }
        if (json.contains("LocaleIdBi") && !json["LocaleIdBi"].is_null()) {
            this->m_LocaleIdBi = std::make_shared< int32_t >(
                json["LocaleIdBi"].get< int32_t >()
            );
        }
        if (json.contains("LocaleIdFarEast") && !json["LocaleIdFarEast"].is_null()) {
            this->m_LocaleIdFarEast = std::make_shared< int32_t >(
                json["LocaleIdFarEast"].get< int32_t >()
            );
        }
        if (json.contains("Name") && !json["Name"].is_null()) {
            this->m_Name = std::make_shared< std::wstring >(
                convertUtf8( json["Name"].get< std::string >() )
            );
        }
        if (json.contains("NameAscii") && !json["NameAscii"].is_null()) {
            this->m_NameAscii = std::make_shared< std::wstring >(
                convertUtf8( json["NameAscii"].get< std::string >() )
            );
        }
        if (json.contains("NameBi") && !json["NameBi"].is_null()) {
            this->m_NameBi = std::make_shared< std::wstring >(
                convertUtf8( json["NameBi"].get< std::string >() )
            );
        }
        if (json.contains("NameFarEast") && !json["NameFarEast"].is_null()) {
            this->m_NameFarEast = std::make_shared< std::wstring >(
                convertUtf8( json["NameFarEast"].get< std::string >() )
            );
        }
        if (json.contains("NameOther") && !json["NameOther"].is_null()) {
            this->m_NameOther = std::make_shared< std::wstring >(
                convertUtf8( json["NameOther"].get< std::string >() )
            );
        }
        if (json.contains("NoProofing") && !json["NoProofing"].is_null()) {
            this->m_NoProofing = std::make_shared< bool >(
                json["NoProofing"].get< bool >()
            );
        }
        if (json.contains("Outline") && !json["Outline"].is_null()) {
            this->m_Outline = std::make_shared< bool >(
                json["Outline"].get< bool >()
            );
        }
        if (json.contains("Position") && !json["Position"].is_null()) {
            this->m_Position = std::make_shared< double >(
                json["Position"].get< double >()
            );
        }
        if (json.contains("Scaling") && !json["Scaling"].is_null()) {
            this->m_Scaling = std::make_shared< int32_t >(
                json["Scaling"].get< int32_t >()
            );
        }
        if (json.contains("Shadow") && !json["Shadow"].is_null()) {
            this->m_Shadow = std::make_shared< bool >(
                json["Shadow"].get< bool >()
            );
        }
        if (json.contains("Size") && !json["Size"].is_null()) {
            this->m_Size = std::make_shared< double >(
                json["Size"].get< double >()
            );
        }
        if (json.contains("SizeBi") && !json["SizeBi"].is_null()) {
            this->m_SizeBi = std::make_shared< double >(
                json["SizeBi"].get< double >()
            );
        }
        if (json.contains("SmallCaps") && !json["SmallCaps"].is_null()) {
            this->m_SmallCaps = std::make_shared< bool >(
                json["SmallCaps"].get< bool >()
            );
        }
        if (json.contains("Spacing") && !json["Spacing"].is_null()) {
            this->m_Spacing = std::make_shared< double >(
                json["Spacing"].get< double >()
            );
        }
        if (json.contains("StrikeThrough") && !json["StrikeThrough"].is_null()) {
            this->m_StrikeThrough = std::make_shared< bool >(
                json["StrikeThrough"].get< bool >()
            );
        }
        if (json.contains("StyleIdentifier") && !json["StyleIdentifier"].is_null()) {
            this->m_StyleIdentifier = std::make_shared< aspose::words::cloud::models::Font::StyleIdentifier >(
                fontStyleIdentifierFromString(json["StyleIdentifier"].get< std::string >())
            );
        }
        if (json.contains("StyleName") && !json["StyleName"].is_null()) {
            this->m_StyleName = std::make_shared< std::wstring >(
                convertUtf8( json["StyleName"].get< std::string >() )
            );
        }
        if (json.contains("Subscript") && !json["Subscript"].is_null()) {
            this->m_Subscript = std::make_shared< bool >(
                json["Subscript"].get< bool >()
            );
        }
        if (json.contains("Superscript") && !json["Superscript"].is_null()) {
            this->m_Superscript = std::make_shared< bool >(
                json["Superscript"].get< bool >()
            );
        }
        if (json.contains("TextEffect") && !json["TextEffect"].is_null()) {
            this->m_TextEffect = std::make_shared< aspose::words::cloud::models::Font::TextEffect >(
                fontTextEffectFromString(json["TextEffect"].get< std::string >())
            );
        }
        if (json.contains("Underline") && !json["Underline"].is_null()) {
            this->m_Underline = std::make_shared< aspose::words::cloud::models::Font::Underline >(
                fontUnderlineFromString(json["Underline"].get< std::string >())
            );
        }
        if (json.contains("UnderlineColor") && !json["UnderlineColor"].is_null()) {
            this->m_UnderlineColor = createModelInstance< aspose::words::cloud::models::XmlColor >(L"XmlColor, _", json["UnderlineColor"]);
        }
    }

    void Font::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Font::validate()
    {
        LinkElement::validate();

        if (this->m_Border != nullptr)
        {
            this->m_Border->validate();
        }



        if (this->m_Color != nullptr)
        {
            this->m_Color->validate();
        }








        if (this->m_HighlightColor != nullptr)
        {
            this->m_HighlightColor->validate();
        }






























        if (this->m_UnderlineColor != nullptr)
        {
            this->m_UnderlineColor->validate();
        }

    }

    std::shared_ptr< bool > Font::getAllCaps() const
    {
        return this->m_AllCaps;
    }

    void Font::setAllCaps(std::shared_ptr< bool > value)
    {
        this->m_AllCaps = value;
    }


    std::shared_ptr< bool > Font::getBidi() const
    {
        return this->m_Bidi;
    }

    void Font::setBidi(std::shared_ptr< bool > value)
    {
        this->m_Bidi = value;
    }


    std::shared_ptr< bool > Font::getBold() const
    {
        return this->m_Bold;
    }

    void Font::setBold(std::shared_ptr< bool > value)
    {
        this->m_Bold = value;
    }


    std::shared_ptr< bool > Font::getBoldBi() const
    {
        return this->m_BoldBi;
    }

    void Font::setBoldBi(std::shared_ptr< bool > value)
    {
        this->m_BoldBi = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Border > Font::getBorder() const
    {
        return this->m_Border;
    }

    void Font::setBorder(std::shared_ptr< aspose::words::cloud::models::Border > value)
    {
        this->m_Border = value;
    }


    std::shared_ptr< aspose::words::cloud::models::XmlColor > Font::getColor() const
    {
        return this->m_Color;
    }

    void Font::setColor(std::shared_ptr< aspose::words::cloud::models::XmlColor > value)
    {
        this->m_Color = value;
    }


    std::shared_ptr< bool > Font::getComplexScript() const
    {
        return this->m_ComplexScript;
    }

    void Font::setComplexScript(std::shared_ptr< bool > value)
    {
        this->m_ComplexScript = value;
    }


    std::shared_ptr< bool > Font::getDoubleStrikeThrough() const
    {
        return this->m_DoubleStrikeThrough;
    }

    void Font::setDoubleStrikeThrough(std::shared_ptr< bool > value)
    {
        this->m_DoubleStrikeThrough = value;
    }


    std::shared_ptr< bool > Font::getEmboss() const
    {
        return this->m_Emboss;
    }

    void Font::setEmboss(std::shared_ptr< bool > value)
    {
        this->m_Emboss = value;
    }


    std::shared_ptr< bool > Font::getEngrave() const
    {
        return this->m_Engrave;
    }

    void Font::setEngrave(std::shared_ptr< bool > value)
    {
        this->m_Engrave = value;
    }


    std::shared_ptr< bool > Font::getHidden() const
    {
        return this->m_Hidden;
    }

    void Font::setHidden(std::shared_ptr< bool > value)
    {
        this->m_Hidden = value;
    }


    std::shared_ptr< aspose::words::cloud::models::XmlColor > Font::getHighlightColor() const
    {
        return this->m_HighlightColor;
    }

    void Font::setHighlightColor(std::shared_ptr< aspose::words::cloud::models::XmlColor > value)
    {
        this->m_HighlightColor = value;
    }


    std::shared_ptr< bool > Font::getItalic() const
    {
        return this->m_Italic;
    }

    void Font::setItalic(std::shared_ptr< bool > value)
    {
        this->m_Italic = value;
    }


    std::shared_ptr< bool > Font::getItalicBi() const
    {
        return this->m_ItalicBi;
    }

    void Font::setItalicBi(std::shared_ptr< bool > value)
    {
        this->m_ItalicBi = value;
    }


    std::shared_ptr< double > Font::getKerning() const
    {
        return this->m_Kerning;
    }

    void Font::setKerning(std::shared_ptr< double > value)
    {
        this->m_Kerning = value;
    }


    std::shared_ptr< int32_t > Font::getLocaleId() const
    {
        return this->m_LocaleId;
    }

    void Font::setLocaleId(std::shared_ptr< int32_t > value)
    {
        this->m_LocaleId = value;
    }


    std::shared_ptr< int32_t > Font::getLocaleIdBi() const
    {
        return this->m_LocaleIdBi;
    }

    void Font::setLocaleIdBi(std::shared_ptr< int32_t > value)
    {
        this->m_LocaleIdBi = value;
    }


    std::shared_ptr< int32_t > Font::getLocaleIdFarEast() const
    {
        return this->m_LocaleIdFarEast;
    }

    void Font::setLocaleIdFarEast(std::shared_ptr< int32_t > value)
    {
        this->m_LocaleIdFarEast = value;
    }


    std::shared_ptr< std::wstring > Font::getName() const
    {
        return this->m_Name;
    }

    void Font::setName(std::shared_ptr< std::wstring > value)
    {
        this->m_Name = value;
    }


    std::shared_ptr< std::wstring > Font::getNameAscii() const
    {
        return this->m_NameAscii;
    }

    void Font::setNameAscii(std::shared_ptr< std::wstring > value)
    {
        this->m_NameAscii = value;
    }


    std::shared_ptr< std::wstring > Font::getNameBi() const
    {
        return this->m_NameBi;
    }

    void Font::setNameBi(std::shared_ptr< std::wstring > value)
    {
        this->m_NameBi = value;
    }


    std::shared_ptr< std::wstring > Font::getNameFarEast() const
    {
        return this->m_NameFarEast;
    }

    void Font::setNameFarEast(std::shared_ptr< std::wstring > value)
    {
        this->m_NameFarEast = value;
    }


    std::shared_ptr< std::wstring > Font::getNameOther() const
    {
        return this->m_NameOther;
    }

    void Font::setNameOther(std::shared_ptr< std::wstring > value)
    {
        this->m_NameOther = value;
    }


    std::shared_ptr< bool > Font::getNoProofing() const
    {
        return this->m_NoProofing;
    }

    void Font::setNoProofing(std::shared_ptr< bool > value)
    {
        this->m_NoProofing = value;
    }


    std::shared_ptr< bool > Font::getOutline() const
    {
        return this->m_Outline;
    }

    void Font::setOutline(std::shared_ptr< bool > value)
    {
        this->m_Outline = value;
    }


    std::shared_ptr< double > Font::getPosition() const
    {
        return this->m_Position;
    }

    void Font::setPosition(std::shared_ptr< double > value)
    {
        this->m_Position = value;
    }


    std::shared_ptr< int32_t > Font::getScaling() const
    {
        return this->m_Scaling;
    }

    void Font::setScaling(std::shared_ptr< int32_t > value)
    {
        this->m_Scaling = value;
    }


    std::shared_ptr< bool > Font::getShadow() const
    {
        return this->m_Shadow;
    }

    void Font::setShadow(std::shared_ptr< bool > value)
    {
        this->m_Shadow = value;
    }


    std::shared_ptr< double > Font::getSize() const
    {
        return this->m_Size;
    }

    void Font::setSize(std::shared_ptr< double > value)
    {
        this->m_Size = value;
    }


    std::shared_ptr< double > Font::getSizeBi() const
    {
        return this->m_SizeBi;
    }

    void Font::setSizeBi(std::shared_ptr< double > value)
    {
        this->m_SizeBi = value;
    }


    std::shared_ptr< bool > Font::getSmallCaps() const
    {
        return this->m_SmallCaps;
    }

    void Font::setSmallCaps(std::shared_ptr< bool > value)
    {
        this->m_SmallCaps = value;
    }


    std::shared_ptr< double > Font::getSpacing() const
    {
        return this->m_Spacing;
    }

    void Font::setSpacing(std::shared_ptr< double > value)
    {
        this->m_Spacing = value;
    }


    std::shared_ptr< bool > Font::getStrikeThrough() const
    {
        return this->m_StrikeThrough;
    }

    void Font::setStrikeThrough(std::shared_ptr< bool > value)
    {
        this->m_StrikeThrough = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Font::StyleIdentifier > Font::getStyleIdentifier() const
    {
        return this->m_StyleIdentifier;
    }

    void Font::setStyleIdentifier(std::shared_ptr< aspose::words::cloud::models::Font::StyleIdentifier > value)
    {
        this->m_StyleIdentifier = value;
    }


    std::shared_ptr< std::wstring > Font::getStyleName() const
    {
        return this->m_StyleName;
    }

    void Font::setStyleName(std::shared_ptr< std::wstring > value)
    {
        this->m_StyleName = value;
    }


    std::shared_ptr< bool > Font::getSubscript() const
    {
        return this->m_Subscript;
    }

    void Font::setSubscript(std::shared_ptr< bool > value)
    {
        this->m_Subscript = value;
    }


    std::shared_ptr< bool > Font::getSuperscript() const
    {
        return this->m_Superscript;
    }

    void Font::setSuperscript(std::shared_ptr< bool > value)
    {
        this->m_Superscript = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Font::TextEffect > Font::getTextEffect() const
    {
        return this->m_TextEffect;
    }

    void Font::setTextEffect(std::shared_ptr< aspose::words::cloud::models::Font::TextEffect > value)
    {
        this->m_TextEffect = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Font::Underline > Font::getUnderline() const
    {
        return this->m_Underline;
    }

    void Font::setUnderline(std::shared_ptr< aspose::words::cloud::models::Font::Underline > value)
    {
        this->m_Underline = value;
    }


    std::shared_ptr< aspose::words::cloud::models::XmlColor > Font::getUnderlineColor() const
    {
        return this->m_UnderlineColor;
    }

    void Font::setUnderlineColor(std::shared_ptr< aspose::words::cloud::models::XmlColor > value)
    {
        this->m_UnderlineColor = value;
    }



    /*
     * FontInfo implementation
     */
    void FontInfo::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_FilePath) {
            json["FilePath"] = convertUtf16(*(this->m_FilePath));
        }
        if (this->m_FontFamilyName) {
            json["FontFamilyName"] = convertUtf16(*(this->m_FontFamilyName));
        }
        if (this->m_FullFontName) {
            json["FullFontName"] = convertUtf16(*(this->m_FullFontName));
        }
        if (this->m_Version) {
            json["Version"] = convertUtf16(*(this->m_Version));
        }
    }

    void FontInfo::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("FilePath") && !json["FilePath"].is_null()) {
            this->m_FilePath = std::make_shared< std::wstring >(
                convertUtf8( json["FilePath"].get< std::string >() )
            );
        }
        if (json.contains("FontFamilyName") && !json["FontFamilyName"].is_null()) {
            this->m_FontFamilyName = std::make_shared< std::wstring >(
                convertUtf8( json["FontFamilyName"].get< std::string >() )
            );
        }
        if (json.contains("FullFontName") && !json["FullFontName"].is_null()) {
            this->m_FullFontName = std::make_shared< std::wstring >(
                convertUtf8( json["FullFontName"].get< std::string >() )
            );
        }
        if (json.contains("Version") && !json["Version"].is_null()) {
            this->m_Version = std::make_shared< std::wstring >(
                convertUtf8( json["Version"].get< std::string >() )
            );
        }
    }

    void FontInfo::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FontInfo::validate()
    {
    }

    std::shared_ptr< std::wstring > FontInfo::getFilePath() const
    {
        return this->m_FilePath;
    }

    void FontInfo::setFilePath(std::shared_ptr< std::wstring > value)
    {
        this->m_FilePath = value;
    }


    std::shared_ptr< std::wstring > FontInfo::getFontFamilyName() const
    {
        return this->m_FontFamilyName;
    }

    void FontInfo::setFontFamilyName(std::shared_ptr< std::wstring > value)
    {
        this->m_FontFamilyName = value;
    }


    std::shared_ptr< std::wstring > FontInfo::getFullFontName() const
    {
        return this->m_FullFontName;
    }

    void FontInfo::setFullFontName(std::shared_ptr< std::wstring > value)
    {
        this->m_FullFontName = value;
    }


    std::shared_ptr< std::wstring > FontInfo::getVersion() const
    {
        return this->m_Version;
    }

    void FontInfo::setVersion(std::shared_ptr< std::wstring > value)
    {
        this->m_Version = value;
    }



    /*
     * FontResponse implementation
     */
    void FontResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Font) {
            this->m_Font->toJson(&json["Font"]);
        }
    }

    void FontResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Font") && !json["Font"].is_null()) {
            this->m_Font = createModelInstance< aspose::words::cloud::models::Font >(L"Font, _", json["Font"]);
        }
    }

    void FontResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FontResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Font != nullptr)
        {
            this->m_Font->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Font > FontResponse::getFont() const
    {
        return this->m_Font;
    }

    void FontResponse::setFont(std::shared_ptr< aspose::words::cloud::models::Font > value)
    {
        this->m_Font = value;
    }



    /*
     * Footnote implementation
     */
    inline std::string footnoteFootnoteTypeToString(aspose::words::cloud::models::Footnote::FootnoteType value)
    {
        if (value == aspose::words::cloud::models::Footnote::FootnoteType::FOOTNOTE) return "Footnote";
        if (value == aspose::words::cloud::models::Footnote::FootnoteType::ENDNOTE) return "Endnote";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::Footnote::FootnoteType footnoteFootnoteTypeFromString(const std::string& value)
    {
        if (value == "Footnote") return aspose::words::cloud::models::Footnote::FootnoteType::FOOTNOTE;
        if (value == "Endnote") return aspose::words::cloud::models::Footnote::FootnoteType::ENDNOTE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void Footnote::toJson(void* jsonIfc) const
    {
        FootnoteLink::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Position) {
            this->m_Position->toJson(&json["Position"]);
        }
        if (this->m_FootnoteType) {
            json["FootnoteType"] = footnoteFootnoteTypeToString(*(this->m_FootnoteType));
        }
        if (this->m_ReferenceMark) {
            json["ReferenceMark"] = convertUtf16(*(this->m_ReferenceMark));
        }
        if (this->m_Text) {
            json["Text"] = convertUtf16(*(this->m_Text));
        }
        if (this->m_Content) {
            this->m_Content->toJson(&json["Content"]);
        }
    }

    void Footnote::fromJson(const void* jsonIfc)
    {
        FootnoteLink::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Position") && !json["Position"].is_null()) {
            this->m_Position = createModelInstance< aspose::words::cloud::models::DocumentPosition >(L"DocumentPosition, _", json["Position"]);
        }
        if (json.contains("FootnoteType") && !json["FootnoteType"].is_null()) {
            this->m_FootnoteType = std::make_shared< aspose::words::cloud::models::Footnote::FootnoteType >(
                footnoteFootnoteTypeFromString(json["FootnoteType"].get< std::string >())
            );
        }
        if (json.contains("ReferenceMark") && !json["ReferenceMark"].is_null()) {
            this->m_ReferenceMark = std::make_shared< std::wstring >(
                convertUtf8( json["ReferenceMark"].get< std::string >() )
            );
        }
        if (json.contains("Text") && !json["Text"].is_null()) {
            this->m_Text = std::make_shared< std::wstring >(
                convertUtf8( json["Text"].get< std::string >() )
            );
        }
        if (json.contains("Content") && !json["Content"].is_null()) {
            this->m_Content = createModelInstance< aspose::words::cloud::models::StoryChildNodes >(L"StoryChildNodes, _", json["Content"]);
        }
    }

    void Footnote::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Footnote::validate()
    {
        FootnoteLink::validate();

        if (this->m_Position != nullptr)
        {
            this->m_Position->validate();
        }






        if (this->m_Content != nullptr)
        {
            this->m_Content->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::DocumentPosition > Footnote::getPosition() const
    {
        return this->m_Position;
    }

    void Footnote::setPosition(std::shared_ptr< aspose::words::cloud::models::DocumentPosition > value)
    {
        this->m_Position = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Footnote::FootnoteType > Footnote::getFootnoteType() const
    {
        return this->m_FootnoteType;
    }

    void Footnote::setFootnoteType(std::shared_ptr< aspose::words::cloud::models::Footnote::FootnoteType > value)
    {
        this->m_FootnoteType = value;
    }


    std::shared_ptr< std::wstring > Footnote::getReferenceMark() const
    {
        return this->m_ReferenceMark;
    }

    void Footnote::setReferenceMark(std::shared_ptr< std::wstring > value)
    {
        this->m_ReferenceMark = value;
    }


    std::shared_ptr< std::wstring > Footnote::getText() const
    {
        return this->m_Text;
    }

    void Footnote::setText(std::shared_ptr< std::wstring > value)
    {
        this->m_Text = value;
    }


    std::shared_ptr< aspose::words::cloud::models::StoryChildNodes > Footnote::getContent() const
    {
        return this->m_Content;
    }

    void Footnote::setContent(std::shared_ptr< aspose::words::cloud::models::StoryChildNodes > value)
    {
        this->m_Content = value;
    }



    /*
     * FootnoteBase implementation
     */
    inline std::string footnoteBaseFootnoteTypeToString(aspose::words::cloud::models::FootnoteBase::FootnoteType value)
    {
        if (value == aspose::words::cloud::models::FootnoteBase::FootnoteType::FOOTNOTE) return "Footnote";
        if (value == aspose::words::cloud::models::FootnoteBase::FootnoteType::ENDNOTE) return "Endnote";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::FootnoteBase::FootnoteType footnoteBaseFootnoteTypeFromString(const std::string& value)
    {
        if (value == "Footnote") return aspose::words::cloud::models::FootnoteBase::FootnoteType::FOOTNOTE;
        if (value == "Endnote") return aspose::words::cloud::models::FootnoteBase::FootnoteType::ENDNOTE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void FootnoteBase::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Position) {
            this->m_Position->toJson(&json["Position"]);
        }
        if (this->m_FootnoteType) {
            json["FootnoteType"] = footnoteBaseFootnoteTypeToString(*(this->m_FootnoteType));
        }
        if (this->m_ReferenceMark) {
            json["ReferenceMark"] = convertUtf16(*(this->m_ReferenceMark));
        }
        if (this->m_Text) {
            json["Text"] = convertUtf16(*(this->m_Text));
        }
    }

    void FootnoteBase::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Position") && !json["Position"].is_null()) {
            this->m_Position = createModelInstance< aspose::words::cloud::models::Position >(L"Position, _", json["Position"]);
        }
        if (json.contains("FootnoteType") && !json["FootnoteType"].is_null()) {
            this->m_FootnoteType = std::make_shared< aspose::words::cloud::models::FootnoteBase::FootnoteType >(
                footnoteBaseFootnoteTypeFromString(json["FootnoteType"].get< std::string >())
            );
        }
        if (json.contains("ReferenceMark") && !json["ReferenceMark"].is_null()) {
            this->m_ReferenceMark = std::make_shared< std::wstring >(
                convertUtf8( json["ReferenceMark"].get< std::string >() )
            );
        }
        if (json.contains("Text") && !json["Text"].is_null()) {
            this->m_Text = std::make_shared< std::wstring >(
                convertUtf8( json["Text"].get< std::string >() )
            );
        }
    }

    void FootnoteBase::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FootnoteBase::validate()
    {

        if (this->m_Position != nullptr)
        {
            this->m_Position->validate();
        }




    }

    std::shared_ptr< aspose::words::cloud::models::Position > FootnoteBase::getPosition() const
    {
        return this->m_Position;
    }

    void FootnoteBase::setPosition(std::shared_ptr< aspose::words::cloud::models::Position > value)
    {
        this->m_Position = value;
    }


    std::shared_ptr< aspose::words::cloud::models::FootnoteBase::FootnoteType > FootnoteBase::getFootnoteType() const
    {
        return this->m_FootnoteType;
    }

    void FootnoteBase::setFootnoteType(std::shared_ptr< aspose::words::cloud::models::FootnoteBase::FootnoteType > value)
    {
        this->m_FootnoteType = value;
    }


    std::shared_ptr< std::wstring > FootnoteBase::getReferenceMark() const
    {
        return this->m_ReferenceMark;
    }

    void FootnoteBase::setReferenceMark(std::shared_ptr< std::wstring > value)
    {
        this->m_ReferenceMark = value;
    }


    std::shared_ptr< std::wstring > FootnoteBase::getText() const
    {
        return this->m_Text;
    }

    void FootnoteBase::setText(std::shared_ptr< std::wstring > value)
    {
        this->m_Text = value;
    }



    /*
     * FootnoteCollection implementation
     */
    void FootnoteCollection::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_List) {
            json["List"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_List)) {
                element->toJson(&json["List"].emplace_back());
            }
        }
    }

    void FootnoteCollection::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("List") && !json["List"].is_null()) {
            this->m_List = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::Footnote>> >();
            for (auto& element : json["List"]) {
                this->m_List->emplace_back(createModelInstance< aspose::words::cloud::models::Footnote >(L"Footnote, _", element));
            }
        }
    }

    void FootnoteCollection::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FootnoteCollection::validate()
    {
        LinkElement::validate();

        if (this->m_List != nullptr)
        {
            for (auto& elementList : *(this->m_List))
            {
                if (elementList != nullptr)
                {
                    elementList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Footnote>> > FootnoteCollection::getList() const
    {
        return this->m_List;
    }

    void FootnoteCollection::setList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Footnote>> > value)
    {
        this->m_List = value;
    }



    /*
     * FootnoteInsert implementation
     */
    void FootnoteInsert::toJson(void* jsonIfc) const
    {
        FootnoteBase::toJson(jsonIfc);
    }

    void FootnoteInsert::fromJson(const void* jsonIfc)
    {
        FootnoteBase::fromJson(jsonIfc);
    }

    void FootnoteInsert::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FootnoteInsert::validate()
    {
        FootnoteBase::validate();
    }




    /*
     * FootnoteLink implementation
     */
    void FootnoteLink::toJson(void* jsonIfc) const
    {
        NodeLink::toJson(jsonIfc);
    }

    void FootnoteLink::fromJson(const void* jsonIfc)
    {
        NodeLink::fromJson(jsonIfc);
    }

    void FootnoteLink::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FootnoteLink::validate()
    {
        NodeLink::validate();
    }




    /*
     * FootnoteResponse implementation
     */
    void FootnoteResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Footnote) {
            this->m_Footnote->toJson(&json["Footnote"]);
        }
    }

    void FootnoteResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Footnote") && !json["Footnote"].is_null()) {
            this->m_Footnote = createModelInstance< aspose::words::cloud::models::Footnote >(L"Footnote, _", json["Footnote"]);
        }
    }

    void FootnoteResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FootnoteResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Footnote != nullptr)
        {
            this->m_Footnote->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Footnote > FootnoteResponse::getFootnote() const
    {
        return this->m_Footnote;
    }

    void FootnoteResponse::setFootnote(std::shared_ptr< aspose::words::cloud::models::Footnote > value)
    {
        this->m_Footnote = value;
    }



    /*
     * FootnotesResponse implementation
     */
    void FootnotesResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Footnotes) {
            this->m_Footnotes->toJson(&json["Footnotes"]);
        }
    }

    void FootnotesResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Footnotes") && !json["Footnotes"].is_null()) {
            this->m_Footnotes = createModelInstance< aspose::words::cloud::models::FootnoteCollection >(L"FootnoteCollection, _", json["Footnotes"]);
        }
    }

    void FootnotesResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FootnotesResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Footnotes != nullptr)
        {
            this->m_Footnotes->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::FootnoteCollection > FootnotesResponse::getFootnotes() const
    {
        return this->m_Footnotes;
    }

    void FootnotesResponse::setFootnotes(std::shared_ptr< aspose::words::cloud::models::FootnoteCollection > value)
    {
        this->m_Footnotes = value;
    }



    /*
     * FootnotesStatData implementation
     */
    void FootnotesStatData::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ParagraphCount) {
            json["ParagraphCount"] = *(this->m_ParagraphCount);
        }
        if (this->m_WordCount) {
            json["WordCount"] = *(this->m_WordCount);
        }
    }

    void FootnotesStatData::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ParagraphCount") && !json["ParagraphCount"].is_null()) {
            this->m_ParagraphCount = std::make_shared< int32_t >(
                json["ParagraphCount"].get< int32_t >()
            );
        }
        if (json.contains("WordCount") && !json["WordCount"].is_null()) {
            this->m_WordCount = std::make_shared< int32_t >(
                json["WordCount"].get< int32_t >()
            );
        }
    }

    void FootnotesStatData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FootnotesStatData::validate()
    {
        if (this->m_ParagraphCount == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property ParagraphCount in FootnotesStatData is required.");
        }

        if (this->m_WordCount == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property WordCount in FootnotesStatData is required.");
        }

    }

    std::shared_ptr< int32_t > FootnotesStatData::getParagraphCount() const
    {
        return this->m_ParagraphCount;
    }

    void FootnotesStatData::setParagraphCount(std::shared_ptr< int32_t > value)
    {
        this->m_ParagraphCount = value;
    }


    std::shared_ptr< int32_t > FootnotesStatData::getWordCount() const
    {
        return this->m_WordCount;
    }

    void FootnotesStatData::setWordCount(std::shared_ptr< int32_t > value)
    {
        this->m_WordCount = value;
    }



    /*
     * FootnoteUpdate implementation
     */
    void FootnoteUpdate::toJson(void* jsonIfc) const
    {
        FootnoteBase::toJson(jsonIfc);
    }

    void FootnoteUpdate::fromJson(const void* jsonIfc)
    {
        FootnoteBase::fromJson(jsonIfc);
    }

    void FootnoteUpdate::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FootnoteUpdate::validate()
    {
        FootnoteBase::validate();
    }




    /*
     * FormField implementation
     */
    void FormField::toJson(void* jsonIfc) const
    {
        NodeLink::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Name) {
            json["Name"] = convertUtf16(*(this->m_Name));
        }
        if (this->m_Enabled) {
            json["Enabled"] = *(this->m_Enabled);
        }
        if (this->m_StatusText) {
            json["StatusText"] = convertUtf16(*(this->m_StatusText));
        }
        if (this->m_OwnStatus) {
            json["OwnStatus"] = *(this->m_OwnStatus);
        }
        if (this->m_HelpText) {
            json["HelpText"] = convertUtf16(*(this->m_HelpText));
        }
        if (this->m_OwnHelp) {
            json["OwnHelp"] = *(this->m_OwnHelp);
        }
        if (this->m_CalculateOnExit) {
            json["CalculateOnExit"] = *(this->m_CalculateOnExit);
        }
        if (this->m_EntryMacro) {
            json["EntryMacro"] = convertUtf16(*(this->m_EntryMacro));
        }
        if (this->m_ExitMacro) {
            json["ExitMacro"] = convertUtf16(*(this->m_ExitMacro));
        }
    }

    void FormField::fromJson(const void* jsonIfc)
    {
        NodeLink::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Name") && !json["Name"].is_null()) {
            this->m_Name = std::make_shared< std::wstring >(
                convertUtf8( json["Name"].get< std::string >() )
            );
        }
        if (json.contains("Enabled") && !json["Enabled"].is_null()) {
            this->m_Enabled = std::make_shared< bool >(
                json["Enabled"].get< bool >()
            );
        }
        if (json.contains("StatusText") && !json["StatusText"].is_null()) {
            this->m_StatusText = std::make_shared< std::wstring >(
                convertUtf8( json["StatusText"].get< std::string >() )
            );
        }
        if (json.contains("OwnStatus") && !json["OwnStatus"].is_null()) {
            this->m_OwnStatus = std::make_shared< bool >(
                json["OwnStatus"].get< bool >()
            );
        }
        if (json.contains("HelpText") && !json["HelpText"].is_null()) {
            this->m_HelpText = std::make_shared< std::wstring >(
                convertUtf8( json["HelpText"].get< std::string >() )
            );
        }
        if (json.contains("OwnHelp") && !json["OwnHelp"].is_null()) {
            this->m_OwnHelp = std::make_shared< bool >(
                json["OwnHelp"].get< bool >()
            );
        }
        if (json.contains("CalculateOnExit") && !json["CalculateOnExit"].is_null()) {
            this->m_CalculateOnExit = std::make_shared< bool >(
                json["CalculateOnExit"].get< bool >()
            );
        }
        if (json.contains("EntryMacro") && !json["EntryMacro"].is_null()) {
            this->m_EntryMacro = std::make_shared< std::wstring >(
                convertUtf8( json["EntryMacro"].get< std::string >() )
            );
        }
        if (json.contains("ExitMacro") && !json["ExitMacro"].is_null()) {
            this->m_ExitMacro = std::make_shared< std::wstring >(
                convertUtf8( json["ExitMacro"].get< std::string >() )
            );
        }
    }

    void FormField::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FormField::validate()
    {
        NodeLink::validate();
        if (this->m_Name == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Name in FormField is required.");
        }

    }

    std::shared_ptr< std::wstring > FormField::getName() const
    {
        return this->m_Name;
    }

    void FormField::setName(std::shared_ptr< std::wstring > value)
    {
        this->m_Name = value;
    }


    std::shared_ptr< bool > FormField::getEnabled() const
    {
        return this->m_Enabled;
    }

    void FormField::setEnabled(std::shared_ptr< bool > value)
    {
        this->m_Enabled = value;
    }


    std::shared_ptr< std::wstring > FormField::getStatusText() const
    {
        return this->m_StatusText;
    }

    void FormField::setStatusText(std::shared_ptr< std::wstring > value)
    {
        this->m_StatusText = value;
    }


    std::shared_ptr< bool > FormField::getOwnStatus() const
    {
        return this->m_OwnStatus;
    }

    void FormField::setOwnStatus(std::shared_ptr< bool > value)
    {
        this->m_OwnStatus = value;
    }


    std::shared_ptr< std::wstring > FormField::getHelpText() const
    {
        return this->m_HelpText;
    }

    void FormField::setHelpText(std::shared_ptr< std::wstring > value)
    {
        this->m_HelpText = value;
    }


    std::shared_ptr< bool > FormField::getOwnHelp() const
    {
        return this->m_OwnHelp;
    }

    void FormField::setOwnHelp(std::shared_ptr< bool > value)
    {
        this->m_OwnHelp = value;
    }


    std::shared_ptr< bool > FormField::getCalculateOnExit() const
    {
        return this->m_CalculateOnExit;
    }

    void FormField::setCalculateOnExit(std::shared_ptr< bool > value)
    {
        this->m_CalculateOnExit = value;
    }


    std::shared_ptr< std::wstring > FormField::getEntryMacro() const
    {
        return this->m_EntryMacro;
    }

    void FormField::setEntryMacro(std::shared_ptr< std::wstring > value)
    {
        this->m_EntryMacro = value;
    }


    std::shared_ptr< std::wstring > FormField::getExitMacro() const
    {
        return this->m_ExitMacro;
    }

    void FormField::setExitMacro(std::shared_ptr< std::wstring > value)
    {
        this->m_ExitMacro = value;
    }



    /*
     * FormFieldCheckbox implementation
     */
    void FormFieldCheckbox::toJson(void* jsonIfc) const
    {
        FormField::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_IsCheckBoxExactSize) {
            json["IsCheckBoxExactSize"] = *(this->m_IsCheckBoxExactSize);
        }
        if (this->m_CheckBoxSize) {
            json["CheckBoxSize"] = *(this->m_CheckBoxSize);
        }
        if (this->m_Checked) {
            json["Checked"] = *(this->m_Checked);
        }
    }

    void FormFieldCheckbox::fromJson(const void* jsonIfc)
    {
        FormField::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("IsCheckBoxExactSize") && !json["IsCheckBoxExactSize"].is_null()) {
            this->m_IsCheckBoxExactSize = std::make_shared< bool >(
                json["IsCheckBoxExactSize"].get< bool >()
            );
        }
        if (json.contains("CheckBoxSize") && !json["CheckBoxSize"].is_null()) {
            this->m_CheckBoxSize = std::make_shared< double >(
                json["CheckBoxSize"].get< double >()
            );
        }
        if (json.contains("Checked") && !json["Checked"].is_null()) {
            this->m_Checked = std::make_shared< bool >(
                json["Checked"].get< bool >()
            );
        }
    }

    void FormFieldCheckbox::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FormFieldCheckbox::validate()
    {
        FormField::validate();
        if (this->m_Checked == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Checked in FormFieldCheckbox is required.");
        }

    }

    std::shared_ptr< bool > FormFieldCheckbox::getIsCheckBoxExactSize() const
    {
        return this->m_IsCheckBoxExactSize;
    }

    void FormFieldCheckbox::setIsCheckBoxExactSize(std::shared_ptr< bool > value)
    {
        this->m_IsCheckBoxExactSize = value;
    }


    std::shared_ptr< double > FormFieldCheckbox::getCheckBoxSize() const
    {
        return this->m_CheckBoxSize;
    }

    void FormFieldCheckbox::setCheckBoxSize(std::shared_ptr< double > value)
    {
        this->m_CheckBoxSize = value;
    }


    std::shared_ptr< bool > FormFieldCheckbox::getChecked() const
    {
        return this->m_Checked;
    }

    void FormFieldCheckbox::setChecked(std::shared_ptr< bool > value)
    {
        this->m_Checked = value;
    }



    /*
     * FormFieldCollection implementation
     */
    void FormFieldCollection::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_List) {
            json["List"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_List)) {
                element->toJson(&json["List"].emplace_back());
            }
        }
    }

    void FormFieldCollection::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("List") && !json["List"].is_null()) {
            this->m_List = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::FormField>> >();
            for (auto& element : json["List"]) {
                this->m_List->emplace_back(createModelInstance< aspose::words::cloud::models::FormField >(L"FormField, _", element));
            }
        }
    }

    void FormFieldCollection::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FormFieldCollection::validate()
    {
        LinkElement::validate();

        if (this->m_List != nullptr)
        {
            for (auto& elementList : *(this->m_List))
            {
                if (elementList != nullptr)
                {
                    elementList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::FormField>> > FormFieldCollection::getList() const
    {
        return this->m_List;
    }

    void FormFieldCollection::setList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::FormField>> > value)
    {
        this->m_List = value;
    }



    /*
     * FormFieldDropDown implementation
     */
    void FormFieldDropDown::toJson(void* jsonIfc) const
    {
        FormField::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_DropDownItems) {
            json["DropDownItems"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_DropDownItems)) {
                json["DropDownItems"].push_back(convertUtf16(*element));
            }
        }
        if (this->m_DropDownSelectedIndex) {
            json["DropDownSelectedIndex"] = *(this->m_DropDownSelectedIndex);
        }
    }

    void FormFieldDropDown::fromJson(const void* jsonIfc)
    {
        FormField::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("DropDownItems") && !json["DropDownItems"].is_null()) {
            this->m_DropDownItems = std::make_shared< std::vector<std::shared_ptr<std::wstring>> >();
            for (auto& element : json["DropDownItems"]) {
                this->m_DropDownItems->push_back(std::make_shared< std::wstring >(convertUtf8( element.get< std::string >() )));
            }
        }
        if (json.contains("DropDownSelectedIndex") && !json["DropDownSelectedIndex"].is_null()) {
            this->m_DropDownSelectedIndex = std::make_shared< int32_t >(
                json["DropDownSelectedIndex"].get< int32_t >()
            );
        }
    }

    void FormFieldDropDown::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FormFieldDropDown::validate()
    {
        FormField::validate();
        if (this->m_DropDownItems == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property DropDownItems in FormFieldDropDown is required.");
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<std::wstring>> > FormFieldDropDown::getDropDownItems() const
    {
        return this->m_DropDownItems;
    }

    void FormFieldDropDown::setDropDownItems(std::shared_ptr< std::vector<std::shared_ptr<std::wstring>> > value)
    {
        this->m_DropDownItems = value;
    }


    std::shared_ptr< int32_t > FormFieldDropDown::getDropDownSelectedIndex() const
    {
        return this->m_DropDownSelectedIndex;
    }

    void FormFieldDropDown::setDropDownSelectedIndex(std::shared_ptr< int32_t > value)
    {
        this->m_DropDownSelectedIndex = value;
    }



    /*
     * FormFieldResponse implementation
     */
    void FormFieldResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_FormField) {
            this->m_FormField->toJson(&json["FormField"]);
        }
    }

    void FormFieldResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("FormField") && !json["FormField"].is_null()) {
            this->m_FormField = createModelInstance< aspose::words::cloud::models::FormField >(L"FormField, _", json["FormField"]);
        }
    }

    void FormFieldResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FormFieldResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_FormField != nullptr)
        {
            this->m_FormField->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::FormField > FormFieldResponse::getFormField() const
    {
        return this->m_FormField;
    }

    void FormFieldResponse::setFormField(std::shared_ptr< aspose::words::cloud::models::FormField > value)
    {
        this->m_FormField = value;
    }



    /*
     * FormFieldsResponse implementation
     */
    void FormFieldsResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_FormFields) {
            this->m_FormFields->toJson(&json["FormFields"]);
        }
    }

    void FormFieldsResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("FormFields") && !json["FormFields"].is_null()) {
            this->m_FormFields = createModelInstance< aspose::words::cloud::models::FormFieldCollection >(L"FormFieldCollection, _", json["FormFields"]);
        }
    }

    void FormFieldsResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FormFieldsResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_FormFields != nullptr)
        {
            this->m_FormFields->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::FormFieldCollection > FormFieldsResponse::getFormFields() const
    {
        return this->m_FormFields;
    }

    void FormFieldsResponse::setFormFields(std::shared_ptr< aspose::words::cloud::models::FormFieldCollection > value)
    {
        this->m_FormFields = value;
    }



    /*
     * FormFieldTextInput implementation
     */
    inline std::string formFieldTextInputTextInputTypeToString(aspose::words::cloud::models::FormFieldTextInput::TextInputType value)
    {
        if (value == aspose::words::cloud::models::FormFieldTextInput::TextInputType::REGULAR) return "Regular";
        if (value == aspose::words::cloud::models::FormFieldTextInput::TextInputType::NUMBER) return "Number";
        if (value == aspose::words::cloud::models::FormFieldTextInput::TextInputType::DATE) return "Date";
        if (value == aspose::words::cloud::models::FormFieldTextInput::TextInputType::CURRENT_DATE) return "CurrentDate";
        if (value == aspose::words::cloud::models::FormFieldTextInput::TextInputType::CURRENT_TIME) return "CurrentTime";
        if (value == aspose::words::cloud::models::FormFieldTextInput::TextInputType::CALCULATED) return "Calculated";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::FormFieldTextInput::TextInputType formFieldTextInputTextInputTypeFromString(const std::string& value)
    {
        if (value == "Regular") return aspose::words::cloud::models::FormFieldTextInput::TextInputType::REGULAR;
        if (value == "Number") return aspose::words::cloud::models::FormFieldTextInput::TextInputType::NUMBER;
        if (value == "Date") return aspose::words::cloud::models::FormFieldTextInput::TextInputType::DATE;
        if (value == "CurrentDate") return aspose::words::cloud::models::FormFieldTextInput::TextInputType::CURRENT_DATE;
        if (value == "CurrentTime") return aspose::words::cloud::models::FormFieldTextInput::TextInputType::CURRENT_TIME;
        if (value == "Calculated") return aspose::words::cloud::models::FormFieldTextInput::TextInputType::CALCULATED;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void FormFieldTextInput::toJson(void* jsonIfc) const
    {
        FormField::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_TextInputFormat) {
            json["TextInputFormat"] = convertUtf16(*(this->m_TextInputFormat));
        }
        if (this->m_TextInputType) {
            json["TextInputType"] = formFieldTextInputTextInputTypeToString(*(this->m_TextInputType));
        }
        if (this->m_TextInputDefault) {
            json["TextInputDefault"] = convertUtf16(*(this->m_TextInputDefault));
        }
        if (this->m_MaxLength) {
            json["MaxLength"] = *(this->m_MaxLength);
        }
    }

    void FormFieldTextInput::fromJson(const void* jsonIfc)
    {
        FormField::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("TextInputFormat") && !json["TextInputFormat"].is_null()) {
            this->m_TextInputFormat = std::make_shared< std::wstring >(
                convertUtf8( json["TextInputFormat"].get< std::string >() )
            );
        }
        if (json.contains("TextInputType") && !json["TextInputType"].is_null()) {
            this->m_TextInputType = std::make_shared< aspose::words::cloud::models::FormFieldTextInput::TextInputType >(
                formFieldTextInputTextInputTypeFromString(json["TextInputType"].get< std::string >())
            );
        }
        if (json.contains("TextInputDefault") && !json["TextInputDefault"].is_null()) {
            this->m_TextInputDefault = std::make_shared< std::wstring >(
                convertUtf8( json["TextInputDefault"].get< std::string >() )
            );
        }
        if (json.contains("MaxLength") && !json["MaxLength"].is_null()) {
            this->m_MaxLength = std::make_shared< int32_t >(
                json["MaxLength"].get< int32_t >()
            );
        }
    }

    void FormFieldTextInput::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void FormFieldTextInput::validate()
    {
        FormField::validate();
        if (this->m_TextInputFormat == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property TextInputFormat in FormFieldTextInput is required.");
        }

        if (this->m_TextInputDefault == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property TextInputDefault in FormFieldTextInput is required.");
        }

    }

    std::shared_ptr< std::wstring > FormFieldTextInput::getTextInputFormat() const
    {
        return this->m_TextInputFormat;
    }

    void FormFieldTextInput::setTextInputFormat(std::shared_ptr< std::wstring > value)
    {
        this->m_TextInputFormat = value;
    }


    std::shared_ptr< aspose::words::cloud::models::FormFieldTextInput::TextInputType > FormFieldTextInput::getTextInputType() const
    {
        return this->m_TextInputType;
    }

    void FormFieldTextInput::setTextInputType(std::shared_ptr< aspose::words::cloud::models::FormFieldTextInput::TextInputType > value)
    {
        this->m_TextInputType = value;
    }


    std::shared_ptr< std::wstring > FormFieldTextInput::getTextInputDefault() const
    {
        return this->m_TextInputDefault;
    }

    void FormFieldTextInput::setTextInputDefault(std::shared_ptr< std::wstring > value)
    {
        this->m_TextInputDefault = value;
    }


    std::shared_ptr< int32_t > FormFieldTextInput::getMaxLength() const
    {
        return this->m_MaxLength;
    }

    void FormFieldTextInput::setMaxLength(std::shared_ptr< int32_t > value)
    {
        this->m_MaxLength = value;
    }



    /*
     * GifSaveOptionsData implementation
     */
    void GifSaveOptionsData::toJson(void* jsonIfc) const
    {
        ImageSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void GifSaveOptionsData::fromJson(const void* jsonIfc)
    {
        ImageSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void GifSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void GifSaveOptionsData::validate()
    {
        ImageSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > GifSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * HeaderFooter implementation
     */
    void HeaderFooter::toJson(void* jsonIfc) const
    {
        HeaderFooterLink::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ChildNodes) {
            json["ChildNodes"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_ChildNodes)) {
                element->toJson(&json["ChildNodes"].emplace_back());
            }
        }
        if (this->m_Paragraphs) {
            this->m_Paragraphs->toJson(&json["Paragraphs"]);
        }
        if (this->m_DrawingObjects) {
            this->m_DrawingObjects->toJson(&json["DrawingObjects"]);
        }
    }

    void HeaderFooter::fromJson(const void* jsonIfc)
    {
        HeaderFooterLink::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ChildNodes") && !json["ChildNodes"].is_null()) {
            this->m_ChildNodes = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::NodeLink>> >();
            for (auto& element : json["ChildNodes"]) {
                this->m_ChildNodes->emplace_back(createModelInstance< aspose::words::cloud::models::NodeLink >(L"NodeLink, _", element));
            }
        }
        if (json.contains("Paragraphs") && !json["Paragraphs"].is_null()) {
            this->m_Paragraphs = createModelInstance< aspose::words::cloud::models::LinkElement >(L"LinkElement, _", json["Paragraphs"]);
        }
        if (json.contains("DrawingObjects") && !json["DrawingObjects"].is_null()) {
            this->m_DrawingObjects = createModelInstance< aspose::words::cloud::models::LinkElement >(L"LinkElement, _", json["DrawingObjects"]);
        }
    }

    void HeaderFooter::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void HeaderFooter::validate()
    {
        HeaderFooterLink::validate();

        if (this->m_ChildNodes != nullptr)
        {
            for (auto& elementChildNodes : *(this->m_ChildNodes))
            {
                if (elementChildNodes != nullptr)
                {
                    elementChildNodes->validate();
                }
            }
        }



        if (this->m_Paragraphs != nullptr)
        {
            this->m_Paragraphs->validate();
        }



        if (this->m_DrawingObjects != nullptr)
        {
            this->m_DrawingObjects->validate();
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::NodeLink>> > HeaderFooter::getChildNodes() const
    {
        return this->m_ChildNodes;
    }

    void HeaderFooter::setChildNodes(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::NodeLink>> > value)
    {
        this->m_ChildNodes = value;
    }


    std::shared_ptr< aspose::words::cloud::models::LinkElement > HeaderFooter::getParagraphs() const
    {
        return this->m_Paragraphs;
    }

    void HeaderFooter::setParagraphs(std::shared_ptr< aspose::words::cloud::models::LinkElement > value)
    {
        this->m_Paragraphs = value;
    }


    std::shared_ptr< aspose::words::cloud::models::LinkElement > HeaderFooter::getDrawingObjects() const
    {
        return this->m_DrawingObjects;
    }

    void HeaderFooter::setDrawingObjects(std::shared_ptr< aspose::words::cloud::models::LinkElement > value)
    {
        this->m_DrawingObjects = value;
    }



    /*
     * HeaderFooterLink implementation
     */
    inline std::string headerFooterLinkTypeToString(aspose::words::cloud::models::HeaderFooterLink::Type value)
    {
        if (value == aspose::words::cloud::models::HeaderFooterLink::Type::HEADER_EVEN) return "HeaderEven";
        if (value == aspose::words::cloud::models::HeaderFooterLink::Type::HEADER_PRIMARY) return "HeaderPrimary";
        if (value == aspose::words::cloud::models::HeaderFooterLink::Type::FOOTER_EVEN) return "FooterEven";
        if (value == aspose::words::cloud::models::HeaderFooterLink::Type::FOOTER_PRIMARY) return "FooterPrimary";
        if (value == aspose::words::cloud::models::HeaderFooterLink::Type::HEADER_FIRST) return "HeaderFirst";
        if (value == aspose::words::cloud::models::HeaderFooterLink::Type::FOOTER_FIRST) return "FooterFirst";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::HeaderFooterLink::Type headerFooterLinkTypeFromString(const std::string& value)
    {
        if (value == "HeaderEven") return aspose::words::cloud::models::HeaderFooterLink::Type::HEADER_EVEN;
        if (value == "HeaderPrimary") return aspose::words::cloud::models::HeaderFooterLink::Type::HEADER_PRIMARY;
        if (value == "FooterEven") return aspose::words::cloud::models::HeaderFooterLink::Type::FOOTER_EVEN;
        if (value == "FooterPrimary") return aspose::words::cloud::models::HeaderFooterLink::Type::FOOTER_PRIMARY;
        if (value == "HeaderFirst") return aspose::words::cloud::models::HeaderFooterLink::Type::HEADER_FIRST;
        if (value == "FooterFirst") return aspose::words::cloud::models::HeaderFooterLink::Type::FOOTER_FIRST;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void HeaderFooterLink::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Type) {
            json["Type"] = headerFooterLinkTypeToString(*(this->m_Type));
        }
    }

    void HeaderFooterLink::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Type") && !json["Type"].is_null()) {
            this->m_Type = std::make_shared< aspose::words::cloud::models::HeaderFooterLink::Type >(
                headerFooterLinkTypeFromString(json["Type"].get< std::string >())
            );
        }
    }

    void HeaderFooterLink::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void HeaderFooterLink::validate()
    {
        LinkElement::validate();
        if (this->m_Type == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Type in HeaderFooterLink is required.");
        }

    }

    std::shared_ptr< aspose::words::cloud::models::HeaderFooterLink::Type > HeaderFooterLink::getType() const
    {
        return this->m_Type;
    }

    void HeaderFooterLink::setType(std::shared_ptr< aspose::words::cloud::models::HeaderFooterLink::Type > value)
    {
        this->m_Type = value;
    }



    /*
     * HeaderFooterLinkCollection implementation
     */
    void HeaderFooterLinkCollection::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_List) {
            json["List"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_List)) {
                element->toJson(&json["List"].emplace_back());
            }
        }
    }

    void HeaderFooterLinkCollection::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("List") && !json["List"].is_null()) {
            this->m_List = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::HeaderFooterLink>> >();
            for (auto& element : json["List"]) {
                this->m_List->emplace_back(createModelInstance< aspose::words::cloud::models::HeaderFooterLink >(L"HeaderFooterLink, _", element));
            }
        }
    }

    void HeaderFooterLinkCollection::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void HeaderFooterLinkCollection::validate()
    {
        LinkElement::validate();

        if (this->m_List != nullptr)
        {
            for (auto& elementList : *(this->m_List))
            {
                if (elementList != nullptr)
                {
                    elementList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::HeaderFooterLink>> > HeaderFooterLinkCollection::getList() const
    {
        return this->m_List;
    }

    void HeaderFooterLinkCollection::setList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::HeaderFooterLink>> > value)
    {
        this->m_List = value;
    }



    /*
     * HeaderFooterResponse implementation
     */
    void HeaderFooterResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_HeaderFooter) {
            this->m_HeaderFooter->toJson(&json["HeaderFooter"]);
        }
    }

    void HeaderFooterResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("HeaderFooter") && !json["HeaderFooter"].is_null()) {
            this->m_HeaderFooter = createModelInstance< aspose::words::cloud::models::HeaderFooter >(L"HeaderFooter, _", json["HeaderFooter"]);
        }
    }

    void HeaderFooterResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void HeaderFooterResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_HeaderFooter != nullptr)
        {
            this->m_HeaderFooter->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::HeaderFooter > HeaderFooterResponse::getHeaderFooter() const
    {
        return this->m_HeaderFooter;
    }

    void HeaderFooterResponse::setHeaderFooter(std::shared_ptr< aspose::words::cloud::models::HeaderFooter > value)
    {
        this->m_HeaderFooter = value;
    }



    /*
     * HeaderFootersResponse implementation
     */
    void HeaderFootersResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_HeaderFooters) {
            this->m_HeaderFooters->toJson(&json["HeaderFooters"]);
        }
    }

    void HeaderFootersResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("HeaderFooters") && !json["HeaderFooters"].is_null()) {
            this->m_HeaderFooters = createModelInstance< aspose::words::cloud::models::HeaderFooterLinkCollection >(L"HeaderFooterLinkCollection, _", json["HeaderFooters"]);
        }
    }

    void HeaderFootersResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void HeaderFootersResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_HeaderFooters != nullptr)
        {
            this->m_HeaderFooters->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::HeaderFooterLinkCollection > HeaderFootersResponse::getHeaderFooters() const
    {
        return this->m_HeaderFooters;
    }

    void HeaderFootersResponse::setHeaderFooters(std::shared_ptr< aspose::words::cloud::models::HeaderFooterLinkCollection > value)
    {
        this->m_HeaderFooters = value;
    }



    /*
     * HtmlFixedSaveOptionsData implementation
     */
    inline std::string htmlFixedSaveOptionsDataFontFormatToString(aspose::words::cloud::models::HtmlFixedSaveOptionsData::FontFormat value)
    {
        if (value == aspose::words::cloud::models::HtmlFixedSaveOptionsData::FontFormat::WOFF) return "Woff";
        if (value == aspose::words::cloud::models::HtmlFixedSaveOptionsData::FontFormat::TTF) return "Ttf";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::HtmlFixedSaveOptionsData::FontFormat htmlFixedSaveOptionsDataFontFormatFromString(const std::string& value)
    {
        if (value == "Woff") return aspose::words::cloud::models::HtmlFixedSaveOptionsData::FontFormat::WOFF;
        if (value == "Ttf") return aspose::words::cloud::models::HtmlFixedSaveOptionsData::FontFormat::TTF;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string htmlFixedSaveOptionsDataPageHorizontalAlignmentToString(aspose::words::cloud::models::HtmlFixedSaveOptionsData::PageHorizontalAlignment value)
    {
        if (value == aspose::words::cloud::models::HtmlFixedSaveOptionsData::PageHorizontalAlignment::LEFT) return "Left";
        if (value == aspose::words::cloud::models::HtmlFixedSaveOptionsData::PageHorizontalAlignment::CENTER) return "Center";
        if (value == aspose::words::cloud::models::HtmlFixedSaveOptionsData::PageHorizontalAlignment::RIGHT) return "Right";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::HtmlFixedSaveOptionsData::PageHorizontalAlignment htmlFixedSaveOptionsDataPageHorizontalAlignmentFromString(const std::string& value)
    {
        if (value == "Left") return aspose::words::cloud::models::HtmlFixedSaveOptionsData::PageHorizontalAlignment::LEFT;
        if (value == "Center") return aspose::words::cloud::models::HtmlFixedSaveOptionsData::PageHorizontalAlignment::CENTER;
        if (value == "Right") return aspose::words::cloud::models::HtmlFixedSaveOptionsData::PageHorizontalAlignment::RIGHT;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void HtmlFixedSaveOptionsData::toJson(void* jsonIfc) const
    {
        FixedPageSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_CssClassNamesPrefix) {
            json["CssClassNamesPrefix"] = convertUtf16(*(this->m_CssClassNamesPrefix));
        }
        if (this->m_Encoding) {
            json["Encoding"] = convertUtf16(*(this->m_Encoding));
        }
        if (this->m_ExportEmbeddedCss) {
            json["ExportEmbeddedCss"] = *(this->m_ExportEmbeddedCss);
        }
        if (this->m_ExportEmbeddedFonts) {
            json["ExportEmbeddedFonts"] = *(this->m_ExportEmbeddedFonts);
        }
        if (this->m_ExportEmbeddedImages) {
            json["ExportEmbeddedImages"] = *(this->m_ExportEmbeddedImages);
        }
        if (this->m_ExportFormFields) {
            json["ExportFormFields"] = *(this->m_ExportFormFields);
        }
        if (this->m_FontFormat) {
            json["FontFormat"] = htmlFixedSaveOptionsDataFontFormatToString(*(this->m_FontFormat));
        }
        if (this->m_PageHorizontalAlignment) {
            json["PageHorizontalAlignment"] = htmlFixedSaveOptionsDataPageHorizontalAlignmentToString(*(this->m_PageHorizontalAlignment));
        }
        if (this->m_PageMargins) {
            json["PageMargins"] = *(this->m_PageMargins);
        }
        if (this->m_ResourcesFolder) {
            json["ResourcesFolder"] = convertUtf16(*(this->m_ResourcesFolder));
        }
        if (this->m_ResourcesFolderAlias) {
            json["ResourcesFolderAlias"] = convertUtf16(*(this->m_ResourcesFolderAlias));
        }
        if (this->m_SaveFontFaceCssSeparately) {
            json["SaveFontFaceCssSeparately"] = *(this->m_SaveFontFaceCssSeparately);
        }
        if (this->m_ShowPageBorder) {
            json["ShowPageBorder"] = *(this->m_ShowPageBorder);
        }
        if (this->m_UseTargetMachineFonts) {
            json["UseTargetMachineFonts"] = *(this->m_UseTargetMachineFonts);
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void HtmlFixedSaveOptionsData::fromJson(const void* jsonIfc)
    {
        FixedPageSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("CssClassNamesPrefix") && !json["CssClassNamesPrefix"].is_null()) {
            this->m_CssClassNamesPrefix = std::make_shared< std::wstring >(
                convertUtf8( json["CssClassNamesPrefix"].get< std::string >() )
            );
        }
        if (json.contains("Encoding") && !json["Encoding"].is_null()) {
            this->m_Encoding = std::make_shared< std::wstring >(
                convertUtf8( json["Encoding"].get< std::string >() )
            );
        }
        if (json.contains("ExportEmbeddedCss") && !json["ExportEmbeddedCss"].is_null()) {
            this->m_ExportEmbeddedCss = std::make_shared< bool >(
                json["ExportEmbeddedCss"].get< bool >()
            );
        }
        if (json.contains("ExportEmbeddedFonts") && !json["ExportEmbeddedFonts"].is_null()) {
            this->m_ExportEmbeddedFonts = std::make_shared< bool >(
                json["ExportEmbeddedFonts"].get< bool >()
            );
        }
        if (json.contains("ExportEmbeddedImages") && !json["ExportEmbeddedImages"].is_null()) {
            this->m_ExportEmbeddedImages = std::make_shared< bool >(
                json["ExportEmbeddedImages"].get< bool >()
            );
        }
        if (json.contains("ExportFormFields") && !json["ExportFormFields"].is_null()) {
            this->m_ExportFormFields = std::make_shared< bool >(
                json["ExportFormFields"].get< bool >()
            );
        }
        if (json.contains("FontFormat") && !json["FontFormat"].is_null()) {
            this->m_FontFormat = std::make_shared< aspose::words::cloud::models::HtmlFixedSaveOptionsData::FontFormat >(
                htmlFixedSaveOptionsDataFontFormatFromString(json["FontFormat"].get< std::string >())
            );
        }
        if (json.contains("PageHorizontalAlignment") && !json["PageHorizontalAlignment"].is_null()) {
            this->m_PageHorizontalAlignment = std::make_shared< aspose::words::cloud::models::HtmlFixedSaveOptionsData::PageHorizontalAlignment >(
                htmlFixedSaveOptionsDataPageHorizontalAlignmentFromString(json["PageHorizontalAlignment"].get< std::string >())
            );
        }
        if (json.contains("PageMargins") && !json["PageMargins"].is_null()) {
            this->m_PageMargins = std::make_shared< double >(
                json["PageMargins"].get< double >()
            );
        }
        if (json.contains("ResourcesFolder") && !json["ResourcesFolder"].is_null()) {
            this->m_ResourcesFolder = std::make_shared< std::wstring >(
                convertUtf8( json["ResourcesFolder"].get< std::string >() )
            );
        }
        if (json.contains("ResourcesFolderAlias") && !json["ResourcesFolderAlias"].is_null()) {
            this->m_ResourcesFolderAlias = std::make_shared< std::wstring >(
                convertUtf8( json["ResourcesFolderAlias"].get< std::string >() )
            );
        }
        if (json.contains("SaveFontFaceCssSeparately") && !json["SaveFontFaceCssSeparately"].is_null()) {
            this->m_SaveFontFaceCssSeparately = std::make_shared< bool >(
                json["SaveFontFaceCssSeparately"].get< bool >()
            );
        }
        if (json.contains("ShowPageBorder") && !json["ShowPageBorder"].is_null()) {
            this->m_ShowPageBorder = std::make_shared< bool >(
                json["ShowPageBorder"].get< bool >()
            );
        }
        if (json.contains("UseTargetMachineFonts") && !json["UseTargetMachineFonts"].is_null()) {
            this->m_UseTargetMachineFonts = std::make_shared< bool >(
                json["UseTargetMachineFonts"].get< bool >()
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void HtmlFixedSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void HtmlFixedSaveOptionsData::validate()
    {
        FixedPageSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > HtmlFixedSaveOptionsData::getCssClassNamesPrefix() const
    {
        return this->m_CssClassNamesPrefix;
    }

    void HtmlFixedSaveOptionsData::setCssClassNamesPrefix(std::shared_ptr< std::wstring > value)
    {
        this->m_CssClassNamesPrefix = value;
    }


    std::shared_ptr< std::wstring > HtmlFixedSaveOptionsData::getEncoding() const
    {
        return this->m_Encoding;
    }

    void HtmlFixedSaveOptionsData::setEncoding(std::shared_ptr< std::wstring > value)
    {
        this->m_Encoding = value;
    }


    std::shared_ptr< bool > HtmlFixedSaveOptionsData::getExportEmbeddedCss() const
    {
        return this->m_ExportEmbeddedCss;
    }

    void HtmlFixedSaveOptionsData::setExportEmbeddedCss(std::shared_ptr< bool > value)
    {
        this->m_ExportEmbeddedCss = value;
    }


    std::shared_ptr< bool > HtmlFixedSaveOptionsData::getExportEmbeddedFonts() const
    {
        return this->m_ExportEmbeddedFonts;
    }

    void HtmlFixedSaveOptionsData::setExportEmbeddedFonts(std::shared_ptr< bool > value)
    {
        this->m_ExportEmbeddedFonts = value;
    }


    std::shared_ptr< bool > HtmlFixedSaveOptionsData::getExportEmbeddedImages() const
    {
        return this->m_ExportEmbeddedImages;
    }

    void HtmlFixedSaveOptionsData::setExportEmbeddedImages(std::shared_ptr< bool > value)
    {
        this->m_ExportEmbeddedImages = value;
    }


    std::shared_ptr< bool > HtmlFixedSaveOptionsData::getExportFormFields() const
    {
        return this->m_ExportFormFields;
    }

    void HtmlFixedSaveOptionsData::setExportFormFields(std::shared_ptr< bool > value)
    {
        this->m_ExportFormFields = value;
    }


    std::shared_ptr< aspose::words::cloud::models::HtmlFixedSaveOptionsData::FontFormat > HtmlFixedSaveOptionsData::getFontFormat() const
    {
        return this->m_FontFormat;
    }

    void HtmlFixedSaveOptionsData::setFontFormat(std::shared_ptr< aspose::words::cloud::models::HtmlFixedSaveOptionsData::FontFormat > value)
    {
        this->m_FontFormat = value;
    }


    std::shared_ptr< aspose::words::cloud::models::HtmlFixedSaveOptionsData::PageHorizontalAlignment > HtmlFixedSaveOptionsData::getPageHorizontalAlignment() const
    {
        return this->m_PageHorizontalAlignment;
    }

    void HtmlFixedSaveOptionsData::setPageHorizontalAlignment(std::shared_ptr< aspose::words::cloud::models::HtmlFixedSaveOptionsData::PageHorizontalAlignment > value)
    {
        this->m_PageHorizontalAlignment = value;
    }


    std::shared_ptr< double > HtmlFixedSaveOptionsData::getPageMargins() const
    {
        return this->m_PageMargins;
    }

    void HtmlFixedSaveOptionsData::setPageMargins(std::shared_ptr< double > value)
    {
        this->m_PageMargins = value;
    }


    std::shared_ptr< std::wstring > HtmlFixedSaveOptionsData::getResourcesFolder() const
    {
        return this->m_ResourcesFolder;
    }

    void HtmlFixedSaveOptionsData::setResourcesFolder(std::shared_ptr< std::wstring > value)
    {
        this->m_ResourcesFolder = value;
    }


    std::shared_ptr< std::wstring > HtmlFixedSaveOptionsData::getResourcesFolderAlias() const
    {
        return this->m_ResourcesFolderAlias;
    }

    void HtmlFixedSaveOptionsData::setResourcesFolderAlias(std::shared_ptr< std::wstring > value)
    {
        this->m_ResourcesFolderAlias = value;
    }


    std::shared_ptr< bool > HtmlFixedSaveOptionsData::getSaveFontFaceCssSeparately() const
    {
        return this->m_SaveFontFaceCssSeparately;
    }

    void HtmlFixedSaveOptionsData::setSaveFontFaceCssSeparately(std::shared_ptr< bool > value)
    {
        this->m_SaveFontFaceCssSeparately = value;
    }


    std::shared_ptr< bool > HtmlFixedSaveOptionsData::getShowPageBorder() const
    {
        return this->m_ShowPageBorder;
    }

    void HtmlFixedSaveOptionsData::setShowPageBorder(std::shared_ptr< bool > value)
    {
        this->m_ShowPageBorder = value;
    }


    std::shared_ptr< bool > HtmlFixedSaveOptionsData::getUseTargetMachineFonts() const
    {
        return this->m_UseTargetMachineFonts;
    }

    void HtmlFixedSaveOptionsData::setUseTargetMachineFonts(std::shared_ptr< bool > value)
    {
        this->m_UseTargetMachineFonts = value;
    }


    std::shared_ptr< std::wstring > HtmlFixedSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * HtmlSaveOptionsData implementation
     */
    inline std::string htmlSaveOptionsDataCssStyleSheetTypeToString(aspose::words::cloud::models::HtmlSaveOptionsData::CssStyleSheetType value)
    {
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::CssStyleSheetType::INLINE) return "Inline";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::CssStyleSheetType::EMBEDDED) return "Embedded";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::CssStyleSheetType::EXTERNAL) return "External";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::HtmlSaveOptionsData::CssStyleSheetType htmlSaveOptionsDataCssStyleSheetTypeFromString(const std::string& value)
    {
        if (value == "Inline") return aspose::words::cloud::models::HtmlSaveOptionsData::CssStyleSheetType::INLINE;
        if (value == "Embedded") return aspose::words::cloud::models::HtmlSaveOptionsData::CssStyleSheetType::EMBEDDED;
        if (value == "External") return aspose::words::cloud::models::HtmlSaveOptionsData::CssStyleSheetType::EXTERNAL;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string htmlSaveOptionsDataDocumentSplitCriteriaToString(aspose::words::cloud::models::HtmlSaveOptionsData::DocumentSplitCriteria value)
    {
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::DocumentSplitCriteria::NONE) return "None";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::DocumentSplitCriteria::PAGE_BREAK) return "PageBreak";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::DocumentSplitCriteria::COLUMN_BREAK) return "ColumnBreak";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::DocumentSplitCriteria::SECTION_BREAK) return "SectionBreak";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::DocumentSplitCriteria::HEADING_PARAGRAPH) return "HeadingParagraph";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::HtmlSaveOptionsData::DocumentSplitCriteria htmlSaveOptionsDataDocumentSplitCriteriaFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::HtmlSaveOptionsData::DocumentSplitCriteria::NONE;
        if (value == "PageBreak") return aspose::words::cloud::models::HtmlSaveOptionsData::DocumentSplitCriteria::PAGE_BREAK;
        if (value == "ColumnBreak") return aspose::words::cloud::models::HtmlSaveOptionsData::DocumentSplitCriteria::COLUMN_BREAK;
        if (value == "SectionBreak") return aspose::words::cloud::models::HtmlSaveOptionsData::DocumentSplitCriteria::SECTION_BREAK;
        if (value == "HeadingParagraph") return aspose::words::cloud::models::HtmlSaveOptionsData::DocumentSplitCriteria::HEADING_PARAGRAPH;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string htmlSaveOptionsDataExportHeadersFootersModeToString(aspose::words::cloud::models::HtmlSaveOptionsData::ExportHeadersFootersMode value)
    {
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::ExportHeadersFootersMode::NONE) return "None";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::ExportHeadersFootersMode::PER_SECTION) return "PerSection";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::ExportHeadersFootersMode::FIRST_SECTION_HEADER_LAST_SECTION_FOOTER) return "FirstSectionHeaderLastSectionFooter";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::ExportHeadersFootersMode::FIRST_PAGE_HEADER_FOOTER_PER_SECTION) return "FirstPageHeaderFooterPerSection";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::HtmlSaveOptionsData::ExportHeadersFootersMode htmlSaveOptionsDataExportHeadersFootersModeFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::HtmlSaveOptionsData::ExportHeadersFootersMode::NONE;
        if (value == "PerSection") return aspose::words::cloud::models::HtmlSaveOptionsData::ExportHeadersFootersMode::PER_SECTION;
        if (value == "FirstSectionHeaderLastSectionFooter") return aspose::words::cloud::models::HtmlSaveOptionsData::ExportHeadersFootersMode::FIRST_SECTION_HEADER_LAST_SECTION_FOOTER;
        if (value == "FirstPageHeaderFooterPerSection") return aspose::words::cloud::models::HtmlSaveOptionsData::ExportHeadersFootersMode::FIRST_PAGE_HEADER_FOOTER_PER_SECTION;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string htmlSaveOptionsDataExportListLabelsToString(aspose::words::cloud::models::HtmlSaveOptionsData::ExportListLabels value)
    {
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::ExportListLabels::AUTO) return "Auto";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::ExportListLabels::AS_INLINE_TEXT) return "AsInlineText";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::ExportListLabels::BY_HTML_TAGS) return "ByHtmlTags";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::HtmlSaveOptionsData::ExportListLabels htmlSaveOptionsDataExportListLabelsFromString(const std::string& value)
    {
        if (value == "Auto") return aspose::words::cloud::models::HtmlSaveOptionsData::ExportListLabels::AUTO;
        if (value == "AsInlineText") return aspose::words::cloud::models::HtmlSaveOptionsData::ExportListLabels::AS_INLINE_TEXT;
        if (value == "ByHtmlTags") return aspose::words::cloud::models::HtmlSaveOptionsData::ExportListLabels::BY_HTML_TAGS;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string htmlSaveOptionsDataHtmlVersionToString(aspose::words::cloud::models::HtmlSaveOptionsData::HtmlVersion value)
    {
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::HtmlVersion::XHTML) return "Xhtml";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::HtmlVersion::HTML5) return "Html5";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::HtmlSaveOptionsData::HtmlVersion htmlSaveOptionsDataHtmlVersionFromString(const std::string& value)
    {
        if (value == "Xhtml") return aspose::words::cloud::models::HtmlSaveOptionsData::HtmlVersion::XHTML;
        if (value == "Html5") return aspose::words::cloud::models::HtmlSaveOptionsData::HtmlVersion::HTML5;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string htmlSaveOptionsDataMetafileFormatToString(aspose::words::cloud::models::HtmlSaveOptionsData::MetafileFormat value)
    {
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::MetafileFormat::PNG) return "Png";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::MetafileFormat::SVG) return "Svg";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::MetafileFormat::EMF_OR_WMF) return "EmfOrWmf";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::HtmlSaveOptionsData::MetafileFormat htmlSaveOptionsDataMetafileFormatFromString(const std::string& value)
    {
        if (value == "Png") return aspose::words::cloud::models::HtmlSaveOptionsData::MetafileFormat::PNG;
        if (value == "Svg") return aspose::words::cloud::models::HtmlSaveOptionsData::MetafileFormat::SVG;
        if (value == "EmfOrWmf") return aspose::words::cloud::models::HtmlSaveOptionsData::MetafileFormat::EMF_OR_WMF;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string htmlSaveOptionsDataOfficeMathOutputModeToString(aspose::words::cloud::models::HtmlSaveOptionsData::OfficeMathOutputMode value)
    {
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::OfficeMathOutputMode::IMAGE) return "Image";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::OfficeMathOutputMode::MATH_ML) return "MathML";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::OfficeMathOutputMode::TEXT) return "Text";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::HtmlSaveOptionsData::OfficeMathOutputMode htmlSaveOptionsDataOfficeMathOutputModeFromString(const std::string& value)
    {
        if (value == "Image") return aspose::words::cloud::models::HtmlSaveOptionsData::OfficeMathOutputMode::IMAGE;
        if (value == "MathML") return aspose::words::cloud::models::HtmlSaveOptionsData::OfficeMathOutputMode::MATH_ML;
        if (value == "Text") return aspose::words::cloud::models::HtmlSaveOptionsData::OfficeMathOutputMode::TEXT;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string htmlSaveOptionsDataTableWidthOutputModeToString(aspose::words::cloud::models::HtmlSaveOptionsData::TableWidthOutputMode value)
    {
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::TableWidthOutputMode::ALL) return "All";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::TableWidthOutputMode::RELATIVE_ONLY) return "RelativeOnly";
        if (value == aspose::words::cloud::models::HtmlSaveOptionsData::TableWidthOutputMode::NONE) return "None";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::HtmlSaveOptionsData::TableWidthOutputMode htmlSaveOptionsDataTableWidthOutputModeFromString(const std::string& value)
    {
        if (value == "All") return aspose::words::cloud::models::HtmlSaveOptionsData::TableWidthOutputMode::ALL;
        if (value == "RelativeOnly") return aspose::words::cloud::models::HtmlSaveOptionsData::TableWidthOutputMode::RELATIVE_ONLY;
        if (value == "None") return aspose::words::cloud::models::HtmlSaveOptionsData::TableWidthOutputMode::NONE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void HtmlSaveOptionsData::toJson(void* jsonIfc) const
    {
        SaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_AllowNegativeIndent) {
            json["AllowNegativeIndent"] = *(this->m_AllowNegativeIndent);
        }
        if (this->m_CssClassNamePrefix) {
            json["CssClassNamePrefix"] = convertUtf16(*(this->m_CssClassNamePrefix));
        }
        if (this->m_CssStyleSheetFileName) {
            json["CssStyleSheetFileName"] = convertUtf16(*(this->m_CssStyleSheetFileName));
        }
        if (this->m_CssStyleSheetType) {
            json["CssStyleSheetType"] = htmlSaveOptionsDataCssStyleSheetTypeToString(*(this->m_CssStyleSheetType));
        }
        if (this->m_DocumentSplitCriteria) {
            json["DocumentSplitCriteria"] = htmlSaveOptionsDataDocumentSplitCriteriaToString(*(this->m_DocumentSplitCriteria));
        }
        if (this->m_DocumentSplitHeadingLevel) {
            json["DocumentSplitHeadingLevel"] = *(this->m_DocumentSplitHeadingLevel);
        }
        if (this->m_Encoding) {
            json["Encoding"] = convertUtf16(*(this->m_Encoding));
        }
        if (this->m_ExportDocumentProperties) {
            json["ExportDocumentProperties"] = *(this->m_ExportDocumentProperties);
        }
        if (this->m_ExportDropDownFormFieldAsText) {
            json["ExportDropDownFormFieldAsText"] = *(this->m_ExportDropDownFormFieldAsText);
        }
        if (this->m_ExportFontResources) {
            json["ExportFontResources"] = *(this->m_ExportFontResources);
        }
        if (this->m_ExportFontsAsBase64) {
            json["ExportFontsAsBase64"] = *(this->m_ExportFontsAsBase64);
        }
        if (this->m_ExportHeadersFootersMode) {
            json["ExportHeadersFootersMode"] = htmlSaveOptionsDataExportHeadersFootersModeToString(*(this->m_ExportHeadersFootersMode));
        }
        if (this->m_ExportImagesAsBase64) {
            json["ExportImagesAsBase64"] = *(this->m_ExportImagesAsBase64);
        }
        if (this->m_ExportLanguageInformation) {
            json["ExportLanguageInformation"] = *(this->m_ExportLanguageInformation);
        }
        if (this->m_ExportListLabels) {
            json["ExportListLabels"] = htmlSaveOptionsDataExportListLabelsToString(*(this->m_ExportListLabels));
        }
        if (this->m_ExportOriginalUrlForLinkedImages) {
            json["ExportOriginalUrlForLinkedImages"] = *(this->m_ExportOriginalUrlForLinkedImages);
        }
        if (this->m_ExportPageMargins) {
            json["ExportPageMargins"] = *(this->m_ExportPageMargins);
        }
        if (this->m_ExportPageSetup) {
            json["ExportPageSetup"] = *(this->m_ExportPageSetup);
        }
        if (this->m_ExportRelativeFontSize) {
            json["ExportRelativeFontSize"] = *(this->m_ExportRelativeFontSize);
        }
        if (this->m_ExportRoundtripInformation) {
            json["ExportRoundtripInformation"] = *(this->m_ExportRoundtripInformation);
        }
        if (this->m_ExportTextInputFormFieldAsText) {
            json["ExportTextInputFormFieldAsText"] = *(this->m_ExportTextInputFormFieldAsText);
        }
        if (this->m_ExportTocPageNumbers) {
            json["ExportTocPageNumbers"] = *(this->m_ExportTocPageNumbers);
        }
        if (this->m_ExportXhtmlTransitional) {
            json["ExportXhtmlTransitional"] = *(this->m_ExportXhtmlTransitional);
        }
        if (this->m_FontResourcesSubsettingSizeThreshold) {
            json["FontResourcesSubsettingSizeThreshold"] = *(this->m_FontResourcesSubsettingSizeThreshold);
        }
        if (this->m_FontsFolder) {
            json["FontsFolder"] = convertUtf16(*(this->m_FontsFolder));
        }
        if (this->m_FontsFolderAlias) {
            json["FontsFolderAlias"] = convertUtf16(*(this->m_FontsFolderAlias));
        }
        if (this->m_HtmlVersion) {
            json["HtmlVersion"] = htmlSaveOptionsDataHtmlVersionToString(*(this->m_HtmlVersion));
        }
        if (this->m_ImageResolution) {
            json["ImageResolution"] = *(this->m_ImageResolution);
        }
        if (this->m_ImagesFolder) {
            json["ImagesFolder"] = convertUtf16(*(this->m_ImagesFolder));
        }
        if (this->m_ImagesFolderAlias) {
            json["ImagesFolderAlias"] = convertUtf16(*(this->m_ImagesFolderAlias));
        }
        if (this->m_MetafileFormat) {
            json["MetafileFormat"] = htmlSaveOptionsDataMetafileFormatToString(*(this->m_MetafileFormat));
        }
        if (this->m_OfficeMathOutputMode) {
            json["OfficeMathOutputMode"] = htmlSaveOptionsDataOfficeMathOutputModeToString(*(this->m_OfficeMathOutputMode));
        }
        if (this->m_PrettyFormat) {
            json["PrettyFormat"] = *(this->m_PrettyFormat);
        }
        if (this->m_ResolveFontNames) {
            json["ResolveFontNames"] = *(this->m_ResolveFontNames);
        }
        if (this->m_ResourceFolder) {
            json["ResourceFolder"] = convertUtf16(*(this->m_ResourceFolder));
        }
        if (this->m_ResourceFolderAlias) {
            json["ResourceFolderAlias"] = convertUtf16(*(this->m_ResourceFolderAlias));
        }
        if (this->m_ScaleImageToShapeSize) {
            json["ScaleImageToShapeSize"] = *(this->m_ScaleImageToShapeSize);
        }
        if (this->m_TableWidthOutputMode) {
            json["TableWidthOutputMode"] = htmlSaveOptionsDataTableWidthOutputModeToString(*(this->m_TableWidthOutputMode));
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void HtmlSaveOptionsData::fromJson(const void* jsonIfc)
    {
        SaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("AllowNegativeIndent") && !json["AllowNegativeIndent"].is_null()) {
            this->m_AllowNegativeIndent = std::make_shared< bool >(
                json["AllowNegativeIndent"].get< bool >()
            );
        }
        if (json.contains("CssClassNamePrefix") && !json["CssClassNamePrefix"].is_null()) {
            this->m_CssClassNamePrefix = std::make_shared< std::wstring >(
                convertUtf8( json["CssClassNamePrefix"].get< std::string >() )
            );
        }
        if (json.contains("CssStyleSheetFileName") && !json["CssStyleSheetFileName"].is_null()) {
            this->m_CssStyleSheetFileName = std::make_shared< std::wstring >(
                convertUtf8( json["CssStyleSheetFileName"].get< std::string >() )
            );
        }
        if (json.contains("CssStyleSheetType") && !json["CssStyleSheetType"].is_null()) {
            this->m_CssStyleSheetType = std::make_shared< aspose::words::cloud::models::HtmlSaveOptionsData::CssStyleSheetType >(
                htmlSaveOptionsDataCssStyleSheetTypeFromString(json["CssStyleSheetType"].get< std::string >())
            );
        }
        if (json.contains("DocumentSplitCriteria") && !json["DocumentSplitCriteria"].is_null()) {
            this->m_DocumentSplitCriteria = std::make_shared< aspose::words::cloud::models::HtmlSaveOptionsData::DocumentSplitCriteria >(
                htmlSaveOptionsDataDocumentSplitCriteriaFromString(json["DocumentSplitCriteria"].get< std::string >())
            );
        }
        if (json.contains("DocumentSplitHeadingLevel") && !json["DocumentSplitHeadingLevel"].is_null()) {
            this->m_DocumentSplitHeadingLevel = std::make_shared< int32_t >(
                json["DocumentSplitHeadingLevel"].get< int32_t >()
            );
        }
        if (json.contains("Encoding") && !json["Encoding"].is_null()) {
            this->m_Encoding = std::make_shared< std::wstring >(
                convertUtf8( json["Encoding"].get< std::string >() )
            );
        }
        if (json.contains("ExportDocumentProperties") && !json["ExportDocumentProperties"].is_null()) {
            this->m_ExportDocumentProperties = std::make_shared< bool >(
                json["ExportDocumentProperties"].get< bool >()
            );
        }
        if (json.contains("ExportDropDownFormFieldAsText") && !json["ExportDropDownFormFieldAsText"].is_null()) {
            this->m_ExportDropDownFormFieldAsText = std::make_shared< bool >(
                json["ExportDropDownFormFieldAsText"].get< bool >()
            );
        }
        if (json.contains("ExportFontResources") && !json["ExportFontResources"].is_null()) {
            this->m_ExportFontResources = std::make_shared< bool >(
                json["ExportFontResources"].get< bool >()
            );
        }
        if (json.contains("ExportFontsAsBase64") && !json["ExportFontsAsBase64"].is_null()) {
            this->m_ExportFontsAsBase64 = std::make_shared< bool >(
                json["ExportFontsAsBase64"].get< bool >()
            );
        }
        if (json.contains("ExportHeadersFootersMode") && !json["ExportHeadersFootersMode"].is_null()) {
            this->m_ExportHeadersFootersMode = std::make_shared< aspose::words::cloud::models::HtmlSaveOptionsData::ExportHeadersFootersMode >(
                htmlSaveOptionsDataExportHeadersFootersModeFromString(json["ExportHeadersFootersMode"].get< std::string >())
            );
        }
        if (json.contains("ExportImagesAsBase64") && !json["ExportImagesAsBase64"].is_null()) {
            this->m_ExportImagesAsBase64 = std::make_shared< bool >(
                json["ExportImagesAsBase64"].get< bool >()
            );
        }
        if (json.contains("ExportLanguageInformation") && !json["ExportLanguageInformation"].is_null()) {
            this->m_ExportLanguageInformation = std::make_shared< bool >(
                json["ExportLanguageInformation"].get< bool >()
            );
        }
        if (json.contains("ExportListLabels") && !json["ExportListLabels"].is_null()) {
            this->m_ExportListLabels = std::make_shared< aspose::words::cloud::models::HtmlSaveOptionsData::ExportListLabels >(
                htmlSaveOptionsDataExportListLabelsFromString(json["ExportListLabels"].get< std::string >())
            );
        }
        if (json.contains("ExportOriginalUrlForLinkedImages") && !json["ExportOriginalUrlForLinkedImages"].is_null()) {
            this->m_ExportOriginalUrlForLinkedImages = std::make_shared< bool >(
                json["ExportOriginalUrlForLinkedImages"].get< bool >()
            );
        }
        if (json.contains("ExportPageMargins") && !json["ExportPageMargins"].is_null()) {
            this->m_ExportPageMargins = std::make_shared< bool >(
                json["ExportPageMargins"].get< bool >()
            );
        }
        if (json.contains("ExportPageSetup") && !json["ExportPageSetup"].is_null()) {
            this->m_ExportPageSetup = std::make_shared< bool >(
                json["ExportPageSetup"].get< bool >()
            );
        }
        if (json.contains("ExportRelativeFontSize") && !json["ExportRelativeFontSize"].is_null()) {
            this->m_ExportRelativeFontSize = std::make_shared< bool >(
                json["ExportRelativeFontSize"].get< bool >()
            );
        }
        if (json.contains("ExportRoundtripInformation") && !json["ExportRoundtripInformation"].is_null()) {
            this->m_ExportRoundtripInformation = std::make_shared< bool >(
                json["ExportRoundtripInformation"].get< bool >()
            );
        }
        if (json.contains("ExportTextInputFormFieldAsText") && !json["ExportTextInputFormFieldAsText"].is_null()) {
            this->m_ExportTextInputFormFieldAsText = std::make_shared< bool >(
                json["ExportTextInputFormFieldAsText"].get< bool >()
            );
        }
        if (json.contains("ExportTocPageNumbers") && !json["ExportTocPageNumbers"].is_null()) {
            this->m_ExportTocPageNumbers = std::make_shared< bool >(
                json["ExportTocPageNumbers"].get< bool >()
            );
        }
        if (json.contains("ExportXhtmlTransitional") && !json["ExportXhtmlTransitional"].is_null()) {
            this->m_ExportXhtmlTransitional = std::make_shared< bool >(
                json["ExportXhtmlTransitional"].get< bool >()
            );
        }
        if (json.contains("FontResourcesSubsettingSizeThreshold") && !json["FontResourcesSubsettingSizeThreshold"].is_null()) {
            this->m_FontResourcesSubsettingSizeThreshold = std::make_shared< int32_t >(
                json["FontResourcesSubsettingSizeThreshold"].get< int32_t >()
            );
        }
        if (json.contains("FontsFolder") && !json["FontsFolder"].is_null()) {
            this->m_FontsFolder = std::make_shared< std::wstring >(
                convertUtf8( json["FontsFolder"].get< std::string >() )
            );
        }
        if (json.contains("FontsFolderAlias") && !json["FontsFolderAlias"].is_null()) {
            this->m_FontsFolderAlias = std::make_shared< std::wstring >(
                convertUtf8( json["FontsFolderAlias"].get< std::string >() )
            );
        }
        if (json.contains("HtmlVersion") && !json["HtmlVersion"].is_null()) {
            this->m_HtmlVersion = std::make_shared< aspose::words::cloud::models::HtmlSaveOptionsData::HtmlVersion >(
                htmlSaveOptionsDataHtmlVersionFromString(json["HtmlVersion"].get< std::string >())
            );
        }
        if (json.contains("ImageResolution") && !json["ImageResolution"].is_null()) {
            this->m_ImageResolution = std::make_shared< int32_t >(
                json["ImageResolution"].get< int32_t >()
            );
        }
        if (json.contains("ImagesFolder") && !json["ImagesFolder"].is_null()) {
            this->m_ImagesFolder = std::make_shared< std::wstring >(
                convertUtf8( json["ImagesFolder"].get< std::string >() )
            );
        }
        if (json.contains("ImagesFolderAlias") && !json["ImagesFolderAlias"].is_null()) {
            this->m_ImagesFolderAlias = std::make_shared< std::wstring >(
                convertUtf8( json["ImagesFolderAlias"].get< std::string >() )
            );
        }
        if (json.contains("MetafileFormat") && !json["MetafileFormat"].is_null()) {
            this->m_MetafileFormat = std::make_shared< aspose::words::cloud::models::HtmlSaveOptionsData::MetafileFormat >(
                htmlSaveOptionsDataMetafileFormatFromString(json["MetafileFormat"].get< std::string >())
            );
        }
        if (json.contains("OfficeMathOutputMode") && !json["OfficeMathOutputMode"].is_null()) {
            this->m_OfficeMathOutputMode = std::make_shared< aspose::words::cloud::models::HtmlSaveOptionsData::OfficeMathOutputMode >(
                htmlSaveOptionsDataOfficeMathOutputModeFromString(json["OfficeMathOutputMode"].get< std::string >())
            );
        }
        if (json.contains("PrettyFormat") && !json["PrettyFormat"].is_null()) {
            this->m_PrettyFormat = std::make_shared< bool >(
                json["PrettyFormat"].get< bool >()
            );
        }
        if (json.contains("ResolveFontNames") && !json["ResolveFontNames"].is_null()) {
            this->m_ResolveFontNames = std::make_shared< bool >(
                json["ResolveFontNames"].get< bool >()
            );
        }
        if (json.contains("ResourceFolder") && !json["ResourceFolder"].is_null()) {
            this->m_ResourceFolder = std::make_shared< std::wstring >(
                convertUtf8( json["ResourceFolder"].get< std::string >() )
            );
        }
        if (json.contains("ResourceFolderAlias") && !json["ResourceFolderAlias"].is_null()) {
            this->m_ResourceFolderAlias = std::make_shared< std::wstring >(
                convertUtf8( json["ResourceFolderAlias"].get< std::string >() )
            );
        }
        if (json.contains("ScaleImageToShapeSize") && !json["ScaleImageToShapeSize"].is_null()) {
            this->m_ScaleImageToShapeSize = std::make_shared< bool >(
                json["ScaleImageToShapeSize"].get< bool >()
            );
        }
        if (json.contains("TableWidthOutputMode") && !json["TableWidthOutputMode"].is_null()) {
            this->m_TableWidthOutputMode = std::make_shared< aspose::words::cloud::models::HtmlSaveOptionsData::TableWidthOutputMode >(
                htmlSaveOptionsDataTableWidthOutputModeFromString(json["TableWidthOutputMode"].get< std::string >())
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void HtmlSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void HtmlSaveOptionsData::validate()
    {
        SaveOptionsData::validate();
    }

    std::shared_ptr< bool > HtmlSaveOptionsData::getAllowNegativeIndent() const
    {
        return this->m_AllowNegativeIndent;
    }

    void HtmlSaveOptionsData::setAllowNegativeIndent(std::shared_ptr< bool > value)
    {
        this->m_AllowNegativeIndent = value;
    }


    std::shared_ptr< std::wstring > HtmlSaveOptionsData::getCssClassNamePrefix() const
    {
        return this->m_CssClassNamePrefix;
    }

    void HtmlSaveOptionsData::setCssClassNamePrefix(std::shared_ptr< std::wstring > value)
    {
        this->m_CssClassNamePrefix = value;
    }


    std::shared_ptr< std::wstring > HtmlSaveOptionsData::getCssStyleSheetFileName() const
    {
        return this->m_CssStyleSheetFileName;
    }

    void HtmlSaveOptionsData::setCssStyleSheetFileName(std::shared_ptr< std::wstring > value)
    {
        this->m_CssStyleSheetFileName = value;
    }


    std::shared_ptr< aspose::words::cloud::models::HtmlSaveOptionsData::CssStyleSheetType > HtmlSaveOptionsData::getCssStyleSheetType() const
    {
        return this->m_CssStyleSheetType;
    }

    void HtmlSaveOptionsData::setCssStyleSheetType(std::shared_ptr< aspose::words::cloud::models::HtmlSaveOptionsData::CssStyleSheetType > value)
    {
        this->m_CssStyleSheetType = value;
    }


    std::shared_ptr< aspose::words::cloud::models::HtmlSaveOptionsData::DocumentSplitCriteria > HtmlSaveOptionsData::getDocumentSplitCriteria() const
    {
        return this->m_DocumentSplitCriteria;
    }

    void HtmlSaveOptionsData::setDocumentSplitCriteria(std::shared_ptr< aspose::words::cloud::models::HtmlSaveOptionsData::DocumentSplitCriteria > value)
    {
        this->m_DocumentSplitCriteria = value;
    }


    std::shared_ptr< int32_t > HtmlSaveOptionsData::getDocumentSplitHeadingLevel() const
    {
        return this->m_DocumentSplitHeadingLevel;
    }

    void HtmlSaveOptionsData::setDocumentSplitHeadingLevel(std::shared_ptr< int32_t > value)
    {
        this->m_DocumentSplitHeadingLevel = value;
    }


    std::shared_ptr< std::wstring > HtmlSaveOptionsData::getEncoding() const
    {
        return this->m_Encoding;
    }

    void HtmlSaveOptionsData::setEncoding(std::shared_ptr< std::wstring > value)
    {
        this->m_Encoding = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getExportDocumentProperties() const
    {
        return this->m_ExportDocumentProperties;
    }

    void HtmlSaveOptionsData::setExportDocumentProperties(std::shared_ptr< bool > value)
    {
        this->m_ExportDocumentProperties = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getExportDropDownFormFieldAsText() const
    {
        return this->m_ExportDropDownFormFieldAsText;
    }

    void HtmlSaveOptionsData::setExportDropDownFormFieldAsText(std::shared_ptr< bool > value)
    {
        this->m_ExportDropDownFormFieldAsText = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getExportFontResources() const
    {
        return this->m_ExportFontResources;
    }

    void HtmlSaveOptionsData::setExportFontResources(std::shared_ptr< bool > value)
    {
        this->m_ExportFontResources = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getExportFontsAsBase64() const
    {
        return this->m_ExportFontsAsBase64;
    }

    void HtmlSaveOptionsData::setExportFontsAsBase64(std::shared_ptr< bool > value)
    {
        this->m_ExportFontsAsBase64 = value;
    }


    std::shared_ptr< aspose::words::cloud::models::HtmlSaveOptionsData::ExportHeadersFootersMode > HtmlSaveOptionsData::getExportHeadersFootersMode() const
    {
        return this->m_ExportHeadersFootersMode;
    }

    void HtmlSaveOptionsData::setExportHeadersFootersMode(std::shared_ptr< aspose::words::cloud::models::HtmlSaveOptionsData::ExportHeadersFootersMode > value)
    {
        this->m_ExportHeadersFootersMode = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getExportImagesAsBase64() const
    {
        return this->m_ExportImagesAsBase64;
    }

    void HtmlSaveOptionsData::setExportImagesAsBase64(std::shared_ptr< bool > value)
    {
        this->m_ExportImagesAsBase64 = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getExportLanguageInformation() const
    {
        return this->m_ExportLanguageInformation;
    }

    void HtmlSaveOptionsData::setExportLanguageInformation(std::shared_ptr< bool > value)
    {
        this->m_ExportLanguageInformation = value;
    }


    std::shared_ptr< aspose::words::cloud::models::HtmlSaveOptionsData::ExportListLabels > HtmlSaveOptionsData::getExportListLabels() const
    {
        return this->m_ExportListLabels;
    }

    void HtmlSaveOptionsData::setExportListLabels(std::shared_ptr< aspose::words::cloud::models::HtmlSaveOptionsData::ExportListLabels > value)
    {
        this->m_ExportListLabels = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getExportOriginalUrlForLinkedImages() const
    {
        return this->m_ExportOriginalUrlForLinkedImages;
    }

    void HtmlSaveOptionsData::setExportOriginalUrlForLinkedImages(std::shared_ptr< bool > value)
    {
        this->m_ExportOriginalUrlForLinkedImages = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getExportPageMargins() const
    {
        return this->m_ExportPageMargins;
    }

    void HtmlSaveOptionsData::setExportPageMargins(std::shared_ptr< bool > value)
    {
        this->m_ExportPageMargins = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getExportPageSetup() const
    {
        return this->m_ExportPageSetup;
    }

    void HtmlSaveOptionsData::setExportPageSetup(std::shared_ptr< bool > value)
    {
        this->m_ExportPageSetup = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getExportRelativeFontSize() const
    {
        return this->m_ExportRelativeFontSize;
    }

    void HtmlSaveOptionsData::setExportRelativeFontSize(std::shared_ptr< bool > value)
    {
        this->m_ExportRelativeFontSize = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getExportRoundtripInformation() const
    {
        return this->m_ExportRoundtripInformation;
    }

    void HtmlSaveOptionsData::setExportRoundtripInformation(std::shared_ptr< bool > value)
    {
        this->m_ExportRoundtripInformation = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getExportTextInputFormFieldAsText() const
    {
        return this->m_ExportTextInputFormFieldAsText;
    }

    void HtmlSaveOptionsData::setExportTextInputFormFieldAsText(std::shared_ptr< bool > value)
    {
        this->m_ExportTextInputFormFieldAsText = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getExportTocPageNumbers() const
    {
        return this->m_ExportTocPageNumbers;
    }

    void HtmlSaveOptionsData::setExportTocPageNumbers(std::shared_ptr< bool > value)
    {
        this->m_ExportTocPageNumbers = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getExportXhtmlTransitional() const
    {
        return this->m_ExportXhtmlTransitional;
    }

    void HtmlSaveOptionsData::setExportXhtmlTransitional(std::shared_ptr< bool > value)
    {
        this->m_ExportXhtmlTransitional = value;
    }


    std::shared_ptr< int32_t > HtmlSaveOptionsData::getFontResourcesSubsettingSizeThreshold() const
    {
        return this->m_FontResourcesSubsettingSizeThreshold;
    }

    void HtmlSaveOptionsData::setFontResourcesSubsettingSizeThreshold(std::shared_ptr< int32_t > value)
    {
        this->m_FontResourcesSubsettingSizeThreshold = value;
    }


    std::shared_ptr< std::wstring > HtmlSaveOptionsData::getFontsFolder() const
    {
        return this->m_FontsFolder;
    }

    void HtmlSaveOptionsData::setFontsFolder(std::shared_ptr< std::wstring > value)
    {
        this->m_FontsFolder = value;
    }


    std::shared_ptr< std::wstring > HtmlSaveOptionsData::getFontsFolderAlias() const
    {
        return this->m_FontsFolderAlias;
    }

    void HtmlSaveOptionsData::setFontsFolderAlias(std::shared_ptr< std::wstring > value)
    {
        this->m_FontsFolderAlias = value;
    }


    std::shared_ptr< aspose::words::cloud::models::HtmlSaveOptionsData::HtmlVersion > HtmlSaveOptionsData::getHtmlVersion() const
    {
        return this->m_HtmlVersion;
    }

    void HtmlSaveOptionsData::setHtmlVersion(std::shared_ptr< aspose::words::cloud::models::HtmlSaveOptionsData::HtmlVersion > value)
    {
        this->m_HtmlVersion = value;
    }


    std::shared_ptr< int32_t > HtmlSaveOptionsData::getImageResolution() const
    {
        return this->m_ImageResolution;
    }

    void HtmlSaveOptionsData::setImageResolution(std::shared_ptr< int32_t > value)
    {
        this->m_ImageResolution = value;
    }


    std::shared_ptr< std::wstring > HtmlSaveOptionsData::getImagesFolder() const
    {
        return this->m_ImagesFolder;
    }

    void HtmlSaveOptionsData::setImagesFolder(std::shared_ptr< std::wstring > value)
    {
        this->m_ImagesFolder = value;
    }


    std::shared_ptr< std::wstring > HtmlSaveOptionsData::getImagesFolderAlias() const
    {
        return this->m_ImagesFolderAlias;
    }

    void HtmlSaveOptionsData::setImagesFolderAlias(std::shared_ptr< std::wstring > value)
    {
        this->m_ImagesFolderAlias = value;
    }


    std::shared_ptr< aspose::words::cloud::models::HtmlSaveOptionsData::MetafileFormat > HtmlSaveOptionsData::getMetafileFormat() const
    {
        return this->m_MetafileFormat;
    }

    void HtmlSaveOptionsData::setMetafileFormat(std::shared_ptr< aspose::words::cloud::models::HtmlSaveOptionsData::MetafileFormat > value)
    {
        this->m_MetafileFormat = value;
    }


    std::shared_ptr< aspose::words::cloud::models::HtmlSaveOptionsData::OfficeMathOutputMode > HtmlSaveOptionsData::getOfficeMathOutputMode() const
    {
        return this->m_OfficeMathOutputMode;
    }

    void HtmlSaveOptionsData::setOfficeMathOutputMode(std::shared_ptr< aspose::words::cloud::models::HtmlSaveOptionsData::OfficeMathOutputMode > value)
    {
        this->m_OfficeMathOutputMode = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getPrettyFormat() const
    {
        return this->m_PrettyFormat;
    }

    void HtmlSaveOptionsData::setPrettyFormat(std::shared_ptr< bool > value)
    {
        this->m_PrettyFormat = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getResolveFontNames() const
    {
        return this->m_ResolveFontNames;
    }

    void HtmlSaveOptionsData::setResolveFontNames(std::shared_ptr< bool > value)
    {
        this->m_ResolveFontNames = value;
    }


    std::shared_ptr< std::wstring > HtmlSaveOptionsData::getResourceFolder() const
    {
        return this->m_ResourceFolder;
    }

    void HtmlSaveOptionsData::setResourceFolder(std::shared_ptr< std::wstring > value)
    {
        this->m_ResourceFolder = value;
    }


    std::shared_ptr< std::wstring > HtmlSaveOptionsData::getResourceFolderAlias() const
    {
        return this->m_ResourceFolderAlias;
    }

    void HtmlSaveOptionsData::setResourceFolderAlias(std::shared_ptr< std::wstring > value)
    {
        this->m_ResourceFolderAlias = value;
    }


    std::shared_ptr< bool > HtmlSaveOptionsData::getScaleImageToShapeSize() const
    {
        return this->m_ScaleImageToShapeSize;
    }

    void HtmlSaveOptionsData::setScaleImageToShapeSize(std::shared_ptr< bool > value)
    {
        this->m_ScaleImageToShapeSize = value;
    }


    std::shared_ptr< aspose::words::cloud::models::HtmlSaveOptionsData::TableWidthOutputMode > HtmlSaveOptionsData::getTableWidthOutputMode() const
    {
        return this->m_TableWidthOutputMode;
    }

    void HtmlSaveOptionsData::setTableWidthOutputMode(std::shared_ptr< aspose::words::cloud::models::HtmlSaveOptionsData::TableWidthOutputMode > value)
    {
        this->m_TableWidthOutputMode = value;
    }


    std::shared_ptr< std::wstring > HtmlSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * Hyperlink implementation
     */
    void Hyperlink::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_DisplayText) {
            json["DisplayText"] = convertUtf16(*(this->m_DisplayText));
        }
        if (this->m_Value) {
            json["Value"] = convertUtf16(*(this->m_Value));
        }
    }

    void Hyperlink::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("DisplayText") && !json["DisplayText"].is_null()) {
            this->m_DisplayText = std::make_shared< std::wstring >(
                convertUtf8( json["DisplayText"].get< std::string >() )
            );
        }
        if (json.contains("Value") && !json["Value"].is_null()) {
            this->m_Value = std::make_shared< std::wstring >(
                convertUtf8( json["Value"].get< std::string >() )
            );
        }
    }

    void Hyperlink::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Hyperlink::validate()
    {
        LinkElement::validate();
    }

    std::shared_ptr< std::wstring > Hyperlink::getDisplayText() const
    {
        return this->m_DisplayText;
    }

    void Hyperlink::setDisplayText(std::shared_ptr< std::wstring > value)
    {
        this->m_DisplayText = value;
    }


    std::shared_ptr< std::wstring > Hyperlink::getValue() const
    {
        return this->m_Value;
    }

    void Hyperlink::setValue(std::shared_ptr< std::wstring > value)
    {
        this->m_Value = value;
    }



    /*
     * HyperlinkResponse implementation
     */
    void HyperlinkResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Hyperlink) {
            this->m_Hyperlink->toJson(&json["Hyperlink"]);
        }
    }

    void HyperlinkResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Hyperlink") && !json["Hyperlink"].is_null()) {
            this->m_Hyperlink = createModelInstance< aspose::words::cloud::models::Hyperlink >(L"Hyperlink, _", json["Hyperlink"]);
        }
    }

    void HyperlinkResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void HyperlinkResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Hyperlink != nullptr)
        {
            this->m_Hyperlink->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Hyperlink > HyperlinkResponse::getHyperlink() const
    {
        return this->m_Hyperlink;
    }

    void HyperlinkResponse::setHyperlink(std::shared_ptr< aspose::words::cloud::models::Hyperlink > value)
    {
        this->m_Hyperlink = value;
    }



    /*
     * Hyperlinks implementation
     */
    void Hyperlinks::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_HyperlinkList) {
            json["HyperlinkList"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_HyperlinkList)) {
                element->toJson(&json["HyperlinkList"].emplace_back());
            }
        }
    }

    void Hyperlinks::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("HyperlinkList") && !json["HyperlinkList"].is_null()) {
            this->m_HyperlinkList = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::Hyperlink>> >();
            for (auto& element : json["HyperlinkList"]) {
                this->m_HyperlinkList->emplace_back(createModelInstance< aspose::words::cloud::models::Hyperlink >(L"Hyperlink, _", element));
            }
        }
    }

    void Hyperlinks::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Hyperlinks::validate()
    {
        LinkElement::validate();

        if (this->m_HyperlinkList != nullptr)
        {
            for (auto& elementHyperlinkList : *(this->m_HyperlinkList))
            {
                if (elementHyperlinkList != nullptr)
                {
                    elementHyperlinkList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Hyperlink>> > Hyperlinks::getHyperlinkList() const
    {
        return this->m_HyperlinkList;
    }

    void Hyperlinks::setHyperlinkList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Hyperlink>> > value)
    {
        this->m_HyperlinkList = value;
    }



    /*
     * HyperlinksResponse implementation
     */
    void HyperlinksResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Hyperlinks) {
            this->m_Hyperlinks->toJson(&json["Hyperlinks"]);
        }
    }

    void HyperlinksResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Hyperlinks") && !json["Hyperlinks"].is_null()) {
            this->m_Hyperlinks = createModelInstance< aspose::words::cloud::models::Hyperlinks >(L"Hyperlinks, _", json["Hyperlinks"]);
        }
    }

    void HyperlinksResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void HyperlinksResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Hyperlinks != nullptr)
        {
            this->m_Hyperlinks->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Hyperlinks > HyperlinksResponse::getHyperlinks() const
    {
        return this->m_Hyperlinks;
    }

    void HyperlinksResponse::setHyperlinks(std::shared_ptr< aspose::words::cloud::models::Hyperlinks > value)
    {
        this->m_Hyperlinks = value;
    }



    /*
     * ImageEntry implementation
     */
    void ImageEntry::toJson(void* jsonIfc) const
    {
        BaseEntry::toJson(jsonIfc);
    }

    void ImageEntry::fromJson(const void* jsonIfc)
    {
        BaseEntry::fromJson(jsonIfc);
    }

    void ImageEntry::getFileReferences(std::vector< FileReference* >& result)
    {
        BaseEntry::getFileReferences(result);
    }

    void ImageEntry::validate()
    {
        BaseEntry::validate();
    }




    /*
     * ImageEntryList implementation
     */
    void ImageEntryList::toJson(void* jsonIfc) const
    {
        BaseEntryList::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_AppendEachImageOnNewPage) {
            json["AppendEachImageOnNewPage"] = *(this->m_AppendEachImageOnNewPage);
        }
        if (this->m_ImageEntries) {
            json["ImageEntries"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_ImageEntries)) {
                element->toJson(&json["ImageEntries"].emplace_back());
            }
        }
    }

    void ImageEntryList::fromJson(const void* jsonIfc)
    {
        BaseEntryList::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("AppendEachImageOnNewPage") && !json["AppendEachImageOnNewPage"].is_null()) {
            this->m_AppendEachImageOnNewPage = std::make_shared< bool >(
                json["AppendEachImageOnNewPage"].get< bool >()
            );
        }
        if (json.contains("ImageEntries") && !json["ImageEntries"].is_null()) {
            this->m_ImageEntries = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::ImageEntry>> >();
            for (auto& element : json["ImageEntries"]) {
                this->m_ImageEntries->emplace_back(createModelInstance< aspose::words::cloud::models::ImageEntry >(L"ImageEntry, _", element));
            }
        }
    }

    void ImageEntryList::getFileReferences(std::vector< FileReference* >& result)
    {
        BaseEntryList::getFileReferences(result);
        if (getImageEntries() != nullptr)
        {
            for (auto& element : *getImageEntries())
            {
                element->getFileReferences(result);
            }
        }

    }

    void ImageEntryList::validate()
    {
        BaseEntryList::validate();
        if (this->m_ImageEntries == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property ImageEntries in ImageEntryList is required.");
        }

        for (auto& elementImageEntries : *(this->m_ImageEntries))
        {
            if (elementImageEntries != nullptr)
            {
                elementImageEntries->validate();
            }
        }


        if (this->m_ImageEntries != nullptr)
        {
            for (auto& elementImageEntries : *(this->m_ImageEntries))
            {
                if (elementImageEntries != nullptr)
                {
                    elementImageEntries->validate();
                }
            }
        }

    }

    std::shared_ptr< bool > ImageEntryList::getAppendEachImageOnNewPage() const
    {
        return this->m_AppendEachImageOnNewPage;
    }

    void ImageEntryList::setAppendEachImageOnNewPage(std::shared_ptr< bool > value)
    {
        this->m_AppendEachImageOnNewPage = value;
    }


    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::ImageEntry>> > ImageEntryList::getImageEntries() const
    {
        return this->m_ImageEntries;
    }

    void ImageEntryList::setImageEntries(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::ImageEntry>> > value)
    {
        this->m_ImageEntries = value;
    }



    /*
     * ImageSaveOptionsData implementation
     */
    inline std::string imageSaveOptionsDataImageColorModeToString(aspose::words::cloud::models::ImageSaveOptionsData::ImageColorMode value)
    {
        if (value == aspose::words::cloud::models::ImageSaveOptionsData::ImageColorMode::NONE) return "None";
        if (value == aspose::words::cloud::models::ImageSaveOptionsData::ImageColorMode::GRAYSCALE) return "Grayscale";
        if (value == aspose::words::cloud::models::ImageSaveOptionsData::ImageColorMode::BLACK_AND_WHITE) return "BlackAndWhite";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ImageSaveOptionsData::ImageColorMode imageSaveOptionsDataImageColorModeFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::ImageSaveOptionsData::ImageColorMode::NONE;
        if (value == "Grayscale") return aspose::words::cloud::models::ImageSaveOptionsData::ImageColorMode::GRAYSCALE;
        if (value == "BlackAndWhite") return aspose::words::cloud::models::ImageSaveOptionsData::ImageColorMode::BLACK_AND_WHITE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string imageSaveOptionsDataPixelFormatToString(aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat value)
    {
        if (value == aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT16_BPP_RGB555) return "Format16BppRgb555";
        if (value == aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT16_BPP_RGB565) return "Format16BppRgb565";
        if (value == aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT16_BPP_ARGB1555) return "Format16BppArgb1555";
        if (value == aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT24_BPP_RGB) return "Format24BppRgb";
        if (value == aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT32_BPP_RGB) return "Format32BppRgb";
        if (value == aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT32_BPP_ARGB) return "Format32BppArgb";
        if (value == aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT32_BPP_P_ARGB) return "Format32BppPArgb";
        if (value == aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT48_BPP_RGB) return "Format48BppRgb";
        if (value == aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT64_BPP_ARGB) return "Format64BppArgb";
        if (value == aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT64_BPP_P_ARGB) return "Format64BppPArgb";
        if (value == aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT1BPP_INDEXED) return "Format1bppIndexed";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat imageSaveOptionsDataPixelFormatFromString(const std::string& value)
    {
        if (value == "Format16BppRgb555") return aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT16_BPP_RGB555;
        if (value == "Format16BppRgb565") return aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT16_BPP_RGB565;
        if (value == "Format16BppArgb1555") return aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT16_BPP_ARGB1555;
        if (value == "Format24BppRgb") return aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT24_BPP_RGB;
        if (value == "Format32BppRgb") return aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT32_BPP_RGB;
        if (value == "Format32BppArgb") return aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT32_BPP_ARGB;
        if (value == "Format32BppPArgb") return aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT32_BPP_P_ARGB;
        if (value == "Format48BppRgb") return aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT48_BPP_RGB;
        if (value == "Format64BppArgb") return aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT64_BPP_ARGB;
        if (value == "Format64BppPArgb") return aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT64_BPP_P_ARGB;
        if (value == "Format1bppIndexed") return aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat::FORMAT1BPP_INDEXED;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void ImageSaveOptionsData::toJson(void* jsonIfc) const
    {
        FixedPageSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_HorizontalResolution) {
            json["HorizontalResolution"] = *(this->m_HorizontalResolution);
        }
        if (this->m_ImageBrightness) {
            json["ImageBrightness"] = *(this->m_ImageBrightness);
        }
        if (this->m_ImageColorMode) {
            json["ImageColorMode"] = imageSaveOptionsDataImageColorModeToString(*(this->m_ImageColorMode));
        }
        if (this->m_ImageContrast) {
            json["ImageContrast"] = *(this->m_ImageContrast);
        }
        if (this->m_PaperColor) {
            json["PaperColor"] = convertUtf16(*(this->m_PaperColor));
        }
        if (this->m_PixelFormat) {
            json["PixelFormat"] = imageSaveOptionsDataPixelFormatToString(*(this->m_PixelFormat));
        }
        if (this->m_Resolution) {
            json["Resolution"] = *(this->m_Resolution);
        }
        if (this->m_Scale) {
            json["Scale"] = *(this->m_Scale);
        }
        if (this->m_UseAntiAliasing) {
            json["UseAntiAliasing"] = *(this->m_UseAntiAliasing);
        }
        if (this->m_UseHighQualityRendering) {
            json["UseHighQualityRendering"] = *(this->m_UseHighQualityRendering);
        }
        if (this->m_VerticalResolution) {
            json["VerticalResolution"] = *(this->m_VerticalResolution);
        }
        if (this->m_ImageHeight) {
            json["ImageHeight"] = *(this->m_ImageHeight);
        }
        if (this->m_ImageWidth) {
            json["ImageWidth"] = *(this->m_ImageWidth);
        }
        if (this->m_UseGdiEmfRenderer) {
            json["UseGdiEmfRenderer"] = *(this->m_UseGdiEmfRenderer);
        }
    }

    void ImageSaveOptionsData::fromJson(const void* jsonIfc)
    {
        FixedPageSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("HorizontalResolution") && !json["HorizontalResolution"].is_null()) {
            this->m_HorizontalResolution = std::make_shared< double >(
                json["HorizontalResolution"].get< double >()
            );
        }
        if (json.contains("ImageBrightness") && !json["ImageBrightness"].is_null()) {
            this->m_ImageBrightness = std::make_shared< double >(
                json["ImageBrightness"].get< double >()
            );
        }
        if (json.contains("ImageColorMode") && !json["ImageColorMode"].is_null()) {
            this->m_ImageColorMode = std::make_shared< aspose::words::cloud::models::ImageSaveOptionsData::ImageColorMode >(
                imageSaveOptionsDataImageColorModeFromString(json["ImageColorMode"].get< std::string >())
            );
        }
        if (json.contains("ImageContrast") && !json["ImageContrast"].is_null()) {
            this->m_ImageContrast = std::make_shared< double >(
                json["ImageContrast"].get< double >()
            );
        }
        if (json.contains("PaperColor") && !json["PaperColor"].is_null()) {
            this->m_PaperColor = std::make_shared< std::wstring >(
                convertUtf8( json["PaperColor"].get< std::string >() )
            );
        }
        if (json.contains("PixelFormat") && !json["PixelFormat"].is_null()) {
            this->m_PixelFormat = std::make_shared< aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat >(
                imageSaveOptionsDataPixelFormatFromString(json["PixelFormat"].get< std::string >())
            );
        }
        if (json.contains("Resolution") && !json["Resolution"].is_null()) {
            this->m_Resolution = std::make_shared< double >(
                json["Resolution"].get< double >()
            );
        }
        if (json.contains("Scale") && !json["Scale"].is_null()) {
            this->m_Scale = std::make_shared< double >(
                json["Scale"].get< double >()
            );
        }
        if (json.contains("UseAntiAliasing") && !json["UseAntiAliasing"].is_null()) {
            this->m_UseAntiAliasing = std::make_shared< bool >(
                json["UseAntiAliasing"].get< bool >()
            );
        }
        if (json.contains("UseHighQualityRendering") && !json["UseHighQualityRendering"].is_null()) {
            this->m_UseHighQualityRendering = std::make_shared< bool >(
                json["UseHighQualityRendering"].get< bool >()
            );
        }
        if (json.contains("VerticalResolution") && !json["VerticalResolution"].is_null()) {
            this->m_VerticalResolution = std::make_shared< double >(
                json["VerticalResolution"].get< double >()
            );
        }
        if (json.contains("ImageHeight") && !json["ImageHeight"].is_null()) {
            this->m_ImageHeight = std::make_shared< int32_t >(
                json["ImageHeight"].get< int32_t >()
            );
        }
        if (json.contains("ImageWidth") && !json["ImageWidth"].is_null()) {
            this->m_ImageWidth = std::make_shared< int32_t >(
                json["ImageWidth"].get< int32_t >()
            );
        }
        if (json.contains("UseGdiEmfRenderer") && !json["UseGdiEmfRenderer"].is_null()) {
            this->m_UseGdiEmfRenderer = std::make_shared< bool >(
                json["UseGdiEmfRenderer"].get< bool >()
            );
        }
    }

    void ImageSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ImageSaveOptionsData::validate()
    {
        FixedPageSaveOptionsData::validate();
    }

    std::shared_ptr< double > ImageSaveOptionsData::getHorizontalResolution() const
    {
        return this->m_HorizontalResolution;
    }

    void ImageSaveOptionsData::setHorizontalResolution(std::shared_ptr< double > value)
    {
        this->m_HorizontalResolution = value;
    }


    std::shared_ptr< double > ImageSaveOptionsData::getImageBrightness() const
    {
        return this->m_ImageBrightness;
    }

    void ImageSaveOptionsData::setImageBrightness(std::shared_ptr< double > value)
    {
        this->m_ImageBrightness = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ImageSaveOptionsData::ImageColorMode > ImageSaveOptionsData::getImageColorMode() const
    {
        return this->m_ImageColorMode;
    }

    void ImageSaveOptionsData::setImageColorMode(std::shared_ptr< aspose::words::cloud::models::ImageSaveOptionsData::ImageColorMode > value)
    {
        this->m_ImageColorMode = value;
    }


    std::shared_ptr< double > ImageSaveOptionsData::getImageContrast() const
    {
        return this->m_ImageContrast;
    }

    void ImageSaveOptionsData::setImageContrast(std::shared_ptr< double > value)
    {
        this->m_ImageContrast = value;
    }


    std::shared_ptr< std::wstring > ImageSaveOptionsData::getPaperColor() const
    {
        return this->m_PaperColor;
    }

    void ImageSaveOptionsData::setPaperColor(std::shared_ptr< std::wstring > value)
    {
        this->m_PaperColor = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat > ImageSaveOptionsData::getPixelFormat() const
    {
        return this->m_PixelFormat;
    }

    void ImageSaveOptionsData::setPixelFormat(std::shared_ptr< aspose::words::cloud::models::ImageSaveOptionsData::PixelFormat > value)
    {
        this->m_PixelFormat = value;
    }


    std::shared_ptr< double > ImageSaveOptionsData::getResolution() const
    {
        return this->m_Resolution;
    }

    void ImageSaveOptionsData::setResolution(std::shared_ptr< double > value)
    {
        this->m_Resolution = value;
    }


    std::shared_ptr< double > ImageSaveOptionsData::getScale() const
    {
        return this->m_Scale;
    }

    void ImageSaveOptionsData::setScale(std::shared_ptr< double > value)
    {
        this->m_Scale = value;
    }


    std::shared_ptr< bool > ImageSaveOptionsData::getUseAntiAliasing() const
    {
        return this->m_UseAntiAliasing;
    }

    void ImageSaveOptionsData::setUseAntiAliasing(std::shared_ptr< bool > value)
    {
        this->m_UseAntiAliasing = value;
    }


    std::shared_ptr< bool > ImageSaveOptionsData::getUseHighQualityRendering() const
    {
        return this->m_UseHighQualityRendering;
    }

    void ImageSaveOptionsData::setUseHighQualityRendering(std::shared_ptr< bool > value)
    {
        this->m_UseHighQualityRendering = value;
    }


    std::shared_ptr< double > ImageSaveOptionsData::getVerticalResolution() const
    {
        return this->m_VerticalResolution;
    }

    void ImageSaveOptionsData::setVerticalResolution(std::shared_ptr< double > value)
    {
        this->m_VerticalResolution = value;
    }


    std::shared_ptr< int32_t > ImageSaveOptionsData::getImageHeight() const
    {
        return this->m_ImageHeight;
    }

    void ImageSaveOptionsData::setImageHeight(std::shared_ptr< int32_t > value)
    {
        this->m_ImageHeight = value;
    }


    std::shared_ptr< int32_t > ImageSaveOptionsData::getImageWidth() const
    {
        return this->m_ImageWidth;
    }

    void ImageSaveOptionsData::setImageWidth(std::shared_ptr< int32_t > value)
    {
        this->m_ImageWidth = value;
    }


    std::shared_ptr< bool > ImageSaveOptionsData::getUseGdiEmfRenderer() const
    {
        return this->m_UseGdiEmfRenderer;
    }

    void ImageSaveOptionsData::setUseGdiEmfRenderer(std::shared_ptr< bool > value)
    {
        this->m_UseGdiEmfRenderer = value;
    }



    /*
     * InfoAdditionalItem implementation
     */
    void InfoAdditionalItem::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Key) {
            json["Key"] = convertUtf16(*(this->m_Key));
        }
        if (this->m_Value) {
            json["Value"] = convertUtf16(*(this->m_Value));
        }
    }

    void InfoAdditionalItem::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Key") && !json["Key"].is_null()) {
            this->m_Key = std::make_shared< std::wstring >(
                convertUtf8( json["Key"].get< std::string >() )
            );
        }
        if (json.contains("Value") && !json["Value"].is_null()) {
            this->m_Value = std::make_shared< std::wstring >(
                convertUtf8( json["Value"].get< std::string >() )
            );
        }
    }

    void InfoAdditionalItem::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void InfoAdditionalItem::validate()
    {
    }

    std::shared_ptr< std::wstring > InfoAdditionalItem::getKey() const
    {
        return this->m_Key;
    }

    void InfoAdditionalItem::setKey(std::shared_ptr< std::wstring > value)
    {
        this->m_Key = value;
    }


    std::shared_ptr< std::wstring > InfoAdditionalItem::getValue() const
    {
        return this->m_Value;
    }

    void InfoAdditionalItem::setValue(std::shared_ptr< std::wstring > value)
    {
        this->m_Value = value;
    }



    /*
     * InfoResponse implementation
     */
    void InfoResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_AdditionalInfo) {
            json["AdditionalInfo"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_AdditionalInfo)) {
                element->toJson(&json["AdditionalInfo"].emplace_back());
            }
        }
        if (this->m_Name) {
            json["Name"] = convertUtf16(*(this->m_Name));
        }
        if (this->m_Version) {
            json["Version"] = convertUtf16(*(this->m_Version));
        }
    }

    void InfoResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("AdditionalInfo") && !json["AdditionalInfo"].is_null()) {
            this->m_AdditionalInfo = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::InfoAdditionalItem>> >();
            for (auto& element : json["AdditionalInfo"]) {
                this->m_AdditionalInfo->emplace_back(createModelInstance< aspose::words::cloud::models::InfoAdditionalItem >(L"InfoAdditionalItem, _", element));
            }
        }
        if (json.contains("Name") && !json["Name"].is_null()) {
            this->m_Name = std::make_shared< std::wstring >(
                convertUtf8( json["Name"].get< std::string >() )
            );
        }
        if (json.contains("Version") && !json["Version"].is_null()) {
            this->m_Version = std::make_shared< std::wstring >(
                convertUtf8( json["Version"].get< std::string >() )
            );
        }
    }

    void InfoResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void InfoResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_AdditionalInfo != nullptr)
        {
            for (auto& elementAdditionalInfo : *(this->m_AdditionalInfo))
            {
                if (elementAdditionalInfo != nullptr)
                {
                    elementAdditionalInfo->validate();
                }
            }
        }



    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::InfoAdditionalItem>> > InfoResponse::getAdditionalInfo() const
    {
        return this->m_AdditionalInfo;
    }

    void InfoResponse::setAdditionalInfo(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::InfoAdditionalItem>> > value)
    {
        this->m_AdditionalInfo = value;
    }


    std::shared_ptr< std::wstring > InfoResponse::getName() const
    {
        return this->m_Name;
    }

    void InfoResponse::setName(std::shared_ptr< std::wstring > value)
    {
        this->m_Name = value;
    }


    std::shared_ptr< std::wstring > InfoResponse::getVersion() const
    {
        return this->m_Version;
    }

    void InfoResponse::setVersion(std::shared_ptr< std::wstring > value)
    {
        this->m_Version = value;
    }



    /*
     * JpegSaveOptionsData implementation
     */
    void JpegSaveOptionsData::toJson(void* jsonIfc) const
    {
        ImageSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void JpegSaveOptionsData::fromJson(const void* jsonIfc)
    {
        ImageSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void JpegSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void JpegSaveOptionsData::validate()
    {
        ImageSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > JpegSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * JsonDataLoadOptions implementation
     */
    inline std::string jsonDataLoadOptionsSimpleValueParseModeToString(aspose::words::cloud::models::JsonDataLoadOptions::SimpleValueParseMode value)
    {
        if (value == aspose::words::cloud::models::JsonDataLoadOptions::SimpleValueParseMode::LOOSE) return "Loose";
        if (value == aspose::words::cloud::models::JsonDataLoadOptions::SimpleValueParseMode::STRICT) return "Strict";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::JsonDataLoadOptions::SimpleValueParseMode jsonDataLoadOptionsSimpleValueParseModeFromString(const std::string& value)
    {
        if (value == "Loose") return aspose::words::cloud::models::JsonDataLoadOptions::SimpleValueParseMode::LOOSE;
        if (value == "Strict") return aspose::words::cloud::models::JsonDataLoadOptions::SimpleValueParseMode::STRICT;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void JsonDataLoadOptions::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_AlwaysGenerateRootObject) {
            json["AlwaysGenerateRootObject"] = *(this->m_AlwaysGenerateRootObject);
        }
        if (this->m_ExactDateTimeParseFormats) {
            json["ExactDateTimeParseFormats"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_ExactDateTimeParseFormats)) {
                json["ExactDateTimeParseFormats"].push_back(convertUtf16(*element));
            }
        }
        if (this->m_SimpleValueParseMode) {
            json["SimpleValueParseMode"] = jsonDataLoadOptionsSimpleValueParseModeToString(*(this->m_SimpleValueParseMode));
        }
    }

    void JsonDataLoadOptions::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("AlwaysGenerateRootObject") && !json["AlwaysGenerateRootObject"].is_null()) {
            this->m_AlwaysGenerateRootObject = std::make_shared< bool >(
                json["AlwaysGenerateRootObject"].get< bool >()
            );
        }
        if (json.contains("ExactDateTimeParseFormats") && !json["ExactDateTimeParseFormats"].is_null()) {
            this->m_ExactDateTimeParseFormats = std::make_shared< std::vector<std::shared_ptr<std::wstring>> >();
            for (auto& element : json["ExactDateTimeParseFormats"]) {
                this->m_ExactDateTimeParseFormats->push_back(std::make_shared< std::wstring >(convertUtf8( element.get< std::string >() )));
            }
        }
        if (json.contains("SimpleValueParseMode") && !json["SimpleValueParseMode"].is_null()) {
            this->m_SimpleValueParseMode = std::make_shared< aspose::words::cloud::models::JsonDataLoadOptions::SimpleValueParseMode >(
                jsonDataLoadOptionsSimpleValueParseModeFromString(json["SimpleValueParseMode"].get< std::string >())
            );
        }
    }

    void JsonDataLoadOptions::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void JsonDataLoadOptions::validate()
    {
        if (this->m_AlwaysGenerateRootObject == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property AlwaysGenerateRootObject in JsonDataLoadOptions is required.");
        }

        if (this->m_SimpleValueParseMode == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property SimpleValueParseMode in JsonDataLoadOptions is required.");
        }

    }

    std::shared_ptr< bool > JsonDataLoadOptions::getAlwaysGenerateRootObject() const
    {
        return this->m_AlwaysGenerateRootObject;
    }

    void JsonDataLoadOptions::setAlwaysGenerateRootObject(std::shared_ptr< bool > value)
    {
        this->m_AlwaysGenerateRootObject = value;
    }


    std::shared_ptr< std::vector<std::shared_ptr<std::wstring>> > JsonDataLoadOptions::getExactDateTimeParseFormats() const
    {
        return this->m_ExactDateTimeParseFormats;
    }

    void JsonDataLoadOptions::setExactDateTimeParseFormats(std::shared_ptr< std::vector<std::shared_ptr<std::wstring>> > value)
    {
        this->m_ExactDateTimeParseFormats = value;
    }


    std::shared_ptr< aspose::words::cloud::models::JsonDataLoadOptions::SimpleValueParseMode > JsonDataLoadOptions::getSimpleValueParseMode() const
    {
        return this->m_SimpleValueParseMode;
    }

    void JsonDataLoadOptions::setSimpleValueParseMode(std::shared_ptr< aspose::words::cloud::models::JsonDataLoadOptions::SimpleValueParseMode > value)
    {
        this->m_SimpleValueParseMode = value;
    }



    /*
     * Link implementation
     */
    void Link::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Href) {
            json["Href"] = convertUtf16(*(this->m_Href));
        }
        if (this->m_Rel) {
            json["Rel"] = convertUtf16(*(this->m_Rel));
        }
        if (this->m_Title) {
            json["Title"] = convertUtf16(*(this->m_Title));
        }
        if (this->m_Type) {
            json["Type"] = convertUtf16(*(this->m_Type));
        }
    }

    void Link::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Href") && !json["Href"].is_null()) {
            this->m_Href = std::make_shared< std::wstring >(
                convertUtf8( json["Href"].get< std::string >() )
            );
        }
        if (json.contains("Rel") && !json["Rel"].is_null()) {
            this->m_Rel = std::make_shared< std::wstring >(
                convertUtf8( json["Rel"].get< std::string >() )
            );
        }
        if (json.contains("Title") && !json["Title"].is_null()) {
            this->m_Title = std::make_shared< std::wstring >(
                convertUtf8( json["Title"].get< std::string >() )
            );
        }
        if (json.contains("Type") && !json["Type"].is_null()) {
            this->m_Type = std::make_shared< std::wstring >(
                convertUtf8( json["Type"].get< std::string >() )
            );
        }
    }

    void Link::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Link::validate()
    {
    }

    std::shared_ptr< std::wstring > Link::getHref() const
    {
        return this->m_Href;
    }

    void Link::setHref(std::shared_ptr< std::wstring > value)
    {
        this->m_Href = value;
    }


    std::shared_ptr< std::wstring > Link::getRel() const
    {
        return this->m_Rel;
    }

    void Link::setRel(std::shared_ptr< std::wstring > value)
    {
        this->m_Rel = value;
    }


    std::shared_ptr< std::wstring > Link::getTitle() const
    {
        return this->m_Title;
    }

    void Link::setTitle(std::shared_ptr< std::wstring > value)
    {
        this->m_Title = value;
    }


    std::shared_ptr< std::wstring > Link::getType() const
    {
        return this->m_Type;
    }

    void Link::setType(std::shared_ptr< std::wstring > value)
    {
        this->m_Type = value;
    }



    /*
     * LinkElement implementation
     */
    void LinkElement::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Link) {
            this->m_Link->toJson(&json["Link"]);
        }
    }

    void LinkElement::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Link") && !json["Link"].is_null()) {
            this->m_Link = createModelInstance< aspose::words::cloud::models::WordsApiLink >(L"WordsApiLink, _", json["Link"]);
        }
    }

    void LinkElement::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void LinkElement::validate()
    {

        if (this->m_Link != nullptr)
        {
            this->m_Link->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::WordsApiLink > LinkElement::getLink() const
    {
        return this->m_Link;
    }

    void LinkElement::setLink(std::shared_ptr< aspose::words::cloud::models::WordsApiLink > value)
    {
        this->m_Link = value;
    }



    /*
     * ListFormat implementation
     */
    void ListFormat::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ListLevelNumber) {
            json["ListLevelNumber"] = *(this->m_ListLevelNumber);
        }
        if (this->m_ListId) {
            json["ListId"] = *(this->m_ListId);
        }
        if (this->m_IsListItem) {
            json["IsListItem"] = *(this->m_IsListItem);
        }
    }

    void ListFormat::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ListLevelNumber") && !json["ListLevelNumber"].is_null()) {
            this->m_ListLevelNumber = std::make_shared< int32_t >(
                json["ListLevelNumber"].get< int32_t >()
            );
        }
        if (json.contains("ListId") && !json["ListId"].is_null()) {
            this->m_ListId = std::make_shared< int32_t >(
                json["ListId"].get< int32_t >()
            );
        }
        if (json.contains("IsListItem") && !json["IsListItem"].is_null()) {
            this->m_IsListItem = std::make_shared< bool >(
                json["IsListItem"].get< bool >()
            );
        }
    }

    void ListFormat::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ListFormat::validate()
    {
        LinkElement::validate();
        if (this->m_ListLevelNumber == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property ListLevelNumber in ListFormat is required.");
        }

        if (this->m_IsListItem == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property IsListItem in ListFormat is required.");
        }

    }

    std::shared_ptr< int32_t > ListFormat::getListLevelNumber() const
    {
        return this->m_ListLevelNumber;
    }

    void ListFormat::setListLevelNumber(std::shared_ptr< int32_t > value)
    {
        this->m_ListLevelNumber = value;
    }


    std::shared_ptr< int32_t > ListFormat::getListId() const
    {
        return this->m_ListId;
    }

    void ListFormat::setListId(std::shared_ptr< int32_t > value)
    {
        this->m_ListId = value;
    }


    std::shared_ptr< bool > ListFormat::getIsListItem() const
    {
        return this->m_IsListItem;
    }

    void ListFormat::setIsListItem(std::shared_ptr< bool > value)
    {
        this->m_IsListItem = value;
    }



    /*
     * ListFormatUpdate implementation
     */
    void ListFormatUpdate::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ListLevelNumber) {
            json["ListLevelNumber"] = *(this->m_ListLevelNumber);
        }
        if (this->m_ListId) {
            json["ListId"] = *(this->m_ListId);
        }
    }

    void ListFormatUpdate::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ListLevelNumber") && !json["ListLevelNumber"].is_null()) {
            this->m_ListLevelNumber = std::make_shared< int32_t >(
                json["ListLevelNumber"].get< int32_t >()
            );
        }
        if (json.contains("ListId") && !json["ListId"].is_null()) {
            this->m_ListId = std::make_shared< int32_t >(
                json["ListId"].get< int32_t >()
            );
        }
    }

    void ListFormatUpdate::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ListFormatUpdate::validate()
    {
    }

    std::shared_ptr< int32_t > ListFormatUpdate::getListLevelNumber() const
    {
        return this->m_ListLevelNumber;
    }

    void ListFormatUpdate::setListLevelNumber(std::shared_ptr< int32_t > value)
    {
        this->m_ListLevelNumber = value;
    }


    std::shared_ptr< int32_t > ListFormatUpdate::getListId() const
    {
        return this->m_ListId;
    }

    void ListFormatUpdate::setListId(std::shared_ptr< int32_t > value)
    {
        this->m_ListId = value;
    }



    /*
     * ListInfo implementation
     */
    void ListInfo::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ListId) {
            json["ListId"] = *(this->m_ListId);
        }
        if (this->m_IsMultiLevel) {
            json["IsMultiLevel"] = *(this->m_IsMultiLevel);
        }
        if (this->m_IsRestartAtEachSection) {
            json["IsRestartAtEachSection"] = *(this->m_IsRestartAtEachSection);
        }
        if (this->m_IsListStyleDefinition) {
            json["IsListStyleDefinition"] = *(this->m_IsListStyleDefinition);
        }
        if (this->m_IsListStyleReference) {
            json["IsListStyleReference"] = *(this->m_IsListStyleReference);
        }
        if (this->m_Style) {
            this->m_Style->toJson(&json["Style"]);
        }
        if (this->m_ListLevels) {
            this->m_ListLevels->toJson(&json["ListLevels"]);
        }
    }

    void ListInfo::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ListId") && !json["ListId"].is_null()) {
            this->m_ListId = std::make_shared< int32_t >(
                json["ListId"].get< int32_t >()
            );
        }
        if (json.contains("IsMultiLevel") && !json["IsMultiLevel"].is_null()) {
            this->m_IsMultiLevel = std::make_shared< bool >(
                json["IsMultiLevel"].get< bool >()
            );
        }
        if (json.contains("IsRestartAtEachSection") && !json["IsRestartAtEachSection"].is_null()) {
            this->m_IsRestartAtEachSection = std::make_shared< bool >(
                json["IsRestartAtEachSection"].get< bool >()
            );
        }
        if (json.contains("IsListStyleDefinition") && !json["IsListStyleDefinition"].is_null()) {
            this->m_IsListStyleDefinition = std::make_shared< bool >(
                json["IsListStyleDefinition"].get< bool >()
            );
        }
        if (json.contains("IsListStyleReference") && !json["IsListStyleReference"].is_null()) {
            this->m_IsListStyleReference = std::make_shared< bool >(
                json["IsListStyleReference"].get< bool >()
            );
        }
        if (json.contains("Style") && !json["Style"].is_null()) {
            this->m_Style = createModelInstance< aspose::words::cloud::models::Style >(L"Style, _", json["Style"]);
        }
        if (json.contains("ListLevels") && !json["ListLevels"].is_null()) {
            this->m_ListLevels = createModelInstance< aspose::words::cloud::models::ListLevels >(L"ListLevels, _", json["ListLevels"]);
        }
    }

    void ListInfo::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ListInfo::validate()
    {
        LinkElement::validate();
        if (this->m_ListId == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property ListId in ListInfo is required.");
        }

        if (this->m_IsMultiLevel == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property IsMultiLevel in ListInfo is required.");
        }

        if (this->m_IsRestartAtEachSection == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property IsRestartAtEachSection in ListInfo is required.");
        }

        if (this->m_IsListStyleDefinition == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property IsListStyleDefinition in ListInfo is required.");
        }

        if (this->m_IsListStyleReference == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property IsListStyleReference in ListInfo is required.");
        }


        if (this->m_Style != nullptr)
        {
            this->m_Style->validate();
        }



        if (this->m_ListLevels != nullptr)
        {
            this->m_ListLevels->validate();
        }

    }

    std::shared_ptr< int32_t > ListInfo::getListId() const
    {
        return this->m_ListId;
    }

    void ListInfo::setListId(std::shared_ptr< int32_t > value)
    {
        this->m_ListId = value;
    }


    std::shared_ptr< bool > ListInfo::getIsMultiLevel() const
    {
        return this->m_IsMultiLevel;
    }

    void ListInfo::setIsMultiLevel(std::shared_ptr< bool > value)
    {
        this->m_IsMultiLevel = value;
    }


    std::shared_ptr< bool > ListInfo::getIsRestartAtEachSection() const
    {
        return this->m_IsRestartAtEachSection;
    }

    void ListInfo::setIsRestartAtEachSection(std::shared_ptr< bool > value)
    {
        this->m_IsRestartAtEachSection = value;
    }


    std::shared_ptr< bool > ListInfo::getIsListStyleDefinition() const
    {
        return this->m_IsListStyleDefinition;
    }

    void ListInfo::setIsListStyleDefinition(std::shared_ptr< bool > value)
    {
        this->m_IsListStyleDefinition = value;
    }


    std::shared_ptr< bool > ListInfo::getIsListStyleReference() const
    {
        return this->m_IsListStyleReference;
    }

    void ListInfo::setIsListStyleReference(std::shared_ptr< bool > value)
    {
        this->m_IsListStyleReference = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Style > ListInfo::getStyle() const
    {
        return this->m_Style;
    }

    void ListInfo::setStyle(std::shared_ptr< aspose::words::cloud::models::Style > value)
    {
        this->m_Style = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ListLevels > ListInfo::getListLevels() const
    {
        return this->m_ListLevels;
    }

    void ListInfo::setListLevels(std::shared_ptr< aspose::words::cloud::models::ListLevels > value)
    {
        this->m_ListLevels = value;
    }



    /*
     * ListInsert implementation
     */
    inline std::string listInsertTemplateToString(aspose::words::cloud::models::ListInsert::Template value)
    {
        if (value == aspose::words::cloud::models::ListInsert::Template::BULLET_DEFAULT) return "BulletDefault";
        if (value == aspose::words::cloud::models::ListInsert::Template::BULLET_DISK) return "BulletDisk";
        if (value == aspose::words::cloud::models::ListInsert::Template::BULLET_CIRCLE) return "BulletCircle";
        if (value == aspose::words::cloud::models::ListInsert::Template::BULLET_SQUARE) return "BulletSquare";
        if (value == aspose::words::cloud::models::ListInsert::Template::BULLET_DIAMONDS) return "BulletDiamonds";
        if (value == aspose::words::cloud::models::ListInsert::Template::BULLET_ARROW_HEAD) return "BulletArrowHead";
        if (value == aspose::words::cloud::models::ListInsert::Template::BULLET_TICK) return "BulletTick";
        if (value == aspose::words::cloud::models::ListInsert::Template::NUMBER_DEFAULT) return "NumberDefault";
        if (value == aspose::words::cloud::models::ListInsert::Template::NUMBER_ARABIC_DOT) return "NumberArabicDot";
        if (value == aspose::words::cloud::models::ListInsert::Template::NUMBER_ARABIC_PARENTHESIS) return "NumberArabicParenthesis";
        if (value == aspose::words::cloud::models::ListInsert::Template::NUMBER_UPPERCASE_ROMAN_DOT) return "NumberUppercaseRomanDot";
        if (value == aspose::words::cloud::models::ListInsert::Template::NUMBER_UPPERCASE_LETTER_DOT) return "NumberUppercaseLetterDot";
        if (value == aspose::words::cloud::models::ListInsert::Template::NUMBER_LOWERCASE_LETTER_PARENTHESIS) return "NumberLowercaseLetterParenthesis";
        if (value == aspose::words::cloud::models::ListInsert::Template::NUMBER_LOWERCASE_LETTER_DOT) return "NumberLowercaseLetterDot";
        if (value == aspose::words::cloud::models::ListInsert::Template::NUMBER_LOWERCASE_ROMAN_DOT) return "NumberLowercaseRomanDot";
        if (value == aspose::words::cloud::models::ListInsert::Template::OUTLINE_NUMBERS) return "OutlineNumbers";
        if (value == aspose::words::cloud::models::ListInsert::Template::OUTLINE_LEGAL) return "OutlineLegal";
        if (value == aspose::words::cloud::models::ListInsert::Template::OUTLINE_BULLETS) return "OutlineBullets";
        if (value == aspose::words::cloud::models::ListInsert::Template::OUTLINE_HEADINGS_ARTICLE_SECTION) return "OutlineHeadingsArticleSection";
        if (value == aspose::words::cloud::models::ListInsert::Template::OUTLINE_HEADINGS_LEGAL) return "OutlineHeadingsLegal";
        if (value == aspose::words::cloud::models::ListInsert::Template::OUTLINE_HEADINGS_NUMBERS) return "OutlineHeadingsNumbers";
        if (value == aspose::words::cloud::models::ListInsert::Template::OUTLINE_HEADINGS_CHAPTER) return "OutlineHeadingsChapter";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ListInsert::Template listInsertTemplateFromString(const std::string& value)
    {
        if (value == "BulletDefault") return aspose::words::cloud::models::ListInsert::Template::BULLET_DEFAULT;
        if (value == "BulletDisk") return aspose::words::cloud::models::ListInsert::Template::BULLET_DISK;
        if (value == "BulletCircle") return aspose::words::cloud::models::ListInsert::Template::BULLET_CIRCLE;
        if (value == "BulletSquare") return aspose::words::cloud::models::ListInsert::Template::BULLET_SQUARE;
        if (value == "BulletDiamonds") return aspose::words::cloud::models::ListInsert::Template::BULLET_DIAMONDS;
        if (value == "BulletArrowHead") return aspose::words::cloud::models::ListInsert::Template::BULLET_ARROW_HEAD;
        if (value == "BulletTick") return aspose::words::cloud::models::ListInsert::Template::BULLET_TICK;
        if (value == "NumberDefault") return aspose::words::cloud::models::ListInsert::Template::NUMBER_DEFAULT;
        if (value == "NumberArabicDot") return aspose::words::cloud::models::ListInsert::Template::NUMBER_ARABIC_DOT;
        if (value == "NumberArabicParenthesis") return aspose::words::cloud::models::ListInsert::Template::NUMBER_ARABIC_PARENTHESIS;
        if (value == "NumberUppercaseRomanDot") return aspose::words::cloud::models::ListInsert::Template::NUMBER_UPPERCASE_ROMAN_DOT;
        if (value == "NumberUppercaseLetterDot") return aspose::words::cloud::models::ListInsert::Template::NUMBER_UPPERCASE_LETTER_DOT;
        if (value == "NumberLowercaseLetterParenthesis") return aspose::words::cloud::models::ListInsert::Template::NUMBER_LOWERCASE_LETTER_PARENTHESIS;
        if (value == "NumberLowercaseLetterDot") return aspose::words::cloud::models::ListInsert::Template::NUMBER_LOWERCASE_LETTER_DOT;
        if (value == "NumberLowercaseRomanDot") return aspose::words::cloud::models::ListInsert::Template::NUMBER_LOWERCASE_ROMAN_DOT;
        if (value == "OutlineNumbers") return aspose::words::cloud::models::ListInsert::Template::OUTLINE_NUMBERS;
        if (value == "OutlineLegal") return aspose::words::cloud::models::ListInsert::Template::OUTLINE_LEGAL;
        if (value == "OutlineBullets") return aspose::words::cloud::models::ListInsert::Template::OUTLINE_BULLETS;
        if (value == "OutlineHeadingsArticleSection") return aspose::words::cloud::models::ListInsert::Template::OUTLINE_HEADINGS_ARTICLE_SECTION;
        if (value == "OutlineHeadingsLegal") return aspose::words::cloud::models::ListInsert::Template::OUTLINE_HEADINGS_LEGAL;
        if (value == "OutlineHeadingsNumbers") return aspose::words::cloud::models::ListInsert::Template::OUTLINE_HEADINGS_NUMBERS;
        if (value == "OutlineHeadingsChapter") return aspose::words::cloud::models::ListInsert::Template::OUTLINE_HEADINGS_CHAPTER;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void ListInsert::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Template) {
            json["Template"] = listInsertTemplateToString(*(this->m_Template));
        }
    }

    void ListInsert::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Template") && !json["Template"].is_null()) {
            this->m_Template = std::make_shared< aspose::words::cloud::models::ListInsert::Template >(
                listInsertTemplateFromString(json["Template"].get< std::string >())
            );
        }
    }

    void ListInsert::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ListInsert::validate()
    {
        if (this->m_Template == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Template in ListInsert is required.");
        }

    }

    std::shared_ptr< aspose::words::cloud::models::ListInsert::Template > ListInsert::getTemplate() const
    {
        return this->m_Template;
    }

    void ListInsert::setTemplate(std::shared_ptr< aspose::words::cloud::models::ListInsert::Template > value)
    {
        this->m_Template = value;
    }



    /*
     * ListLevel implementation
     */
    inline std::string listLevelNumberStyleToString(aspose::words::cloud::models::ListLevel::NumberStyle value)
    {
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::ARABIC) return "Arabic";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::UPPERCASE_ROMAN) return "UppercaseRoman";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::LOWERCASE_ROMAN) return "LowercaseRoman";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::UPPERCASE_LETTER) return "UppercaseLetter";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::LOWERCASE_LETTER) return "LowercaseLetter";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::ORDINAL) return "Ordinal";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::NUMBER) return "Number";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::ORDINAL_TEXT) return "OrdinalText";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::HEX) return "Hex";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::CHICAGO_MANUAL) return "ChicagoManual";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::KANJI) return "Kanji";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::KANJI_DIGIT) return "KanjiDigit";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::AIUEO_HALF_WIDTH) return "AiueoHalfWidth";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::IROHA_HALF_WIDTH) return "IrohaHalfWidth";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::ARABIC_FULL_WIDTH) return "ArabicFullWidth";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::ARABIC_HALF_WIDTH) return "ArabicHalfWidth";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::KANJI_TRADITIONAL) return "KanjiTraditional";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::KANJI_TRADITIONAL2) return "KanjiTraditional2";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::NUMBER_IN_CIRCLE) return "NumberInCircle";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::DECIMAL_FULL_WIDTH) return "DecimalFullWidth";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::AIUEO) return "Aiueo";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::IROHA) return "Iroha";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::LEADING_ZERO) return "LeadingZero";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::BULLET) return "Bullet";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::GANADA) return "Ganada";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::CHOSUNG) return "Chosung";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::G_B1) return "GB1";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::G_B2) return "GB2";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::G_B3) return "GB3";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::G_B4) return "GB4";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::ZODIAC1) return "Zodiac1";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::ZODIAC2) return "Zodiac2";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::ZODIAC3) return "Zodiac3";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::TRAD_CHIN_NUM1) return "TradChinNum1";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::TRAD_CHIN_NUM2) return "TradChinNum2";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::TRAD_CHIN_NUM3) return "TradChinNum3";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::TRAD_CHIN_NUM4) return "TradChinNum4";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::SIMP_CHIN_NUM1) return "SimpChinNum1";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::SIMP_CHIN_NUM2) return "SimpChinNum2";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::SIMP_CHIN_NUM3) return "SimpChinNum3";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::SIMP_CHIN_NUM4) return "SimpChinNum4";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::HANJA_READ) return "HanjaRead";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::HANJA_READ_DIGIT) return "HanjaReadDigit";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::HANGUL) return "Hangul";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::HANJA) return "Hanja";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::HEBREW1) return "Hebrew1";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::ARABIC1) return "Arabic1";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::HEBREW2) return "Hebrew2";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::ARABIC2) return "Arabic2";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::HINDI_LETTER1) return "HindiLetter1";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::HINDI_LETTER2) return "HindiLetter2";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::HINDI_ARABIC) return "HindiArabic";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::HINDI_CARDINAL_TEXT) return "HindiCardinalText";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::THAI_LETTER) return "ThaiLetter";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::THAI_ARABIC) return "ThaiArabic";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::THAI_CARDINAL_TEXT) return "ThaiCardinalText";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::VIET_CARDINAL_TEXT) return "VietCardinalText";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::NUMBER_IN_DASH) return "NumberInDash";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::LOWERCASE_RUSSIAN) return "LowercaseRussian";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::UPPERCASE_RUSSIAN) return "UppercaseRussian";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::NONE) return "None";
        if (value == aspose::words::cloud::models::ListLevel::NumberStyle::CUSTOM) return "Custom";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ListLevel::NumberStyle listLevelNumberStyleFromString(const std::string& value)
    {
        if (value == "Arabic") return aspose::words::cloud::models::ListLevel::NumberStyle::ARABIC;
        if (value == "UppercaseRoman") return aspose::words::cloud::models::ListLevel::NumberStyle::UPPERCASE_ROMAN;
        if (value == "LowercaseRoman") return aspose::words::cloud::models::ListLevel::NumberStyle::LOWERCASE_ROMAN;
        if (value == "UppercaseLetter") return aspose::words::cloud::models::ListLevel::NumberStyle::UPPERCASE_LETTER;
        if (value == "LowercaseLetter") return aspose::words::cloud::models::ListLevel::NumberStyle::LOWERCASE_LETTER;
        if (value == "Ordinal") return aspose::words::cloud::models::ListLevel::NumberStyle::ORDINAL;
        if (value == "Number") return aspose::words::cloud::models::ListLevel::NumberStyle::NUMBER;
        if (value == "OrdinalText") return aspose::words::cloud::models::ListLevel::NumberStyle::ORDINAL_TEXT;
        if (value == "Hex") return aspose::words::cloud::models::ListLevel::NumberStyle::HEX;
        if (value == "ChicagoManual") return aspose::words::cloud::models::ListLevel::NumberStyle::CHICAGO_MANUAL;
        if (value == "Kanji") return aspose::words::cloud::models::ListLevel::NumberStyle::KANJI;
        if (value == "KanjiDigit") return aspose::words::cloud::models::ListLevel::NumberStyle::KANJI_DIGIT;
        if (value == "AiueoHalfWidth") return aspose::words::cloud::models::ListLevel::NumberStyle::AIUEO_HALF_WIDTH;
        if (value == "IrohaHalfWidth") return aspose::words::cloud::models::ListLevel::NumberStyle::IROHA_HALF_WIDTH;
        if (value == "ArabicFullWidth") return aspose::words::cloud::models::ListLevel::NumberStyle::ARABIC_FULL_WIDTH;
        if (value == "ArabicHalfWidth") return aspose::words::cloud::models::ListLevel::NumberStyle::ARABIC_HALF_WIDTH;
        if (value == "KanjiTraditional") return aspose::words::cloud::models::ListLevel::NumberStyle::KANJI_TRADITIONAL;
        if (value == "KanjiTraditional2") return aspose::words::cloud::models::ListLevel::NumberStyle::KANJI_TRADITIONAL2;
        if (value == "NumberInCircle") return aspose::words::cloud::models::ListLevel::NumberStyle::NUMBER_IN_CIRCLE;
        if (value == "DecimalFullWidth") return aspose::words::cloud::models::ListLevel::NumberStyle::DECIMAL_FULL_WIDTH;
        if (value == "Aiueo") return aspose::words::cloud::models::ListLevel::NumberStyle::AIUEO;
        if (value == "Iroha") return aspose::words::cloud::models::ListLevel::NumberStyle::IROHA;
        if (value == "LeadingZero") return aspose::words::cloud::models::ListLevel::NumberStyle::LEADING_ZERO;
        if (value == "Bullet") return aspose::words::cloud::models::ListLevel::NumberStyle::BULLET;
        if (value == "Ganada") return aspose::words::cloud::models::ListLevel::NumberStyle::GANADA;
        if (value == "Chosung") return aspose::words::cloud::models::ListLevel::NumberStyle::CHOSUNG;
        if (value == "GB1") return aspose::words::cloud::models::ListLevel::NumberStyle::G_B1;
        if (value == "GB2") return aspose::words::cloud::models::ListLevel::NumberStyle::G_B2;
        if (value == "GB3") return aspose::words::cloud::models::ListLevel::NumberStyle::G_B3;
        if (value == "GB4") return aspose::words::cloud::models::ListLevel::NumberStyle::G_B4;
        if (value == "Zodiac1") return aspose::words::cloud::models::ListLevel::NumberStyle::ZODIAC1;
        if (value == "Zodiac2") return aspose::words::cloud::models::ListLevel::NumberStyle::ZODIAC2;
        if (value == "Zodiac3") return aspose::words::cloud::models::ListLevel::NumberStyle::ZODIAC3;
        if (value == "TradChinNum1") return aspose::words::cloud::models::ListLevel::NumberStyle::TRAD_CHIN_NUM1;
        if (value == "TradChinNum2") return aspose::words::cloud::models::ListLevel::NumberStyle::TRAD_CHIN_NUM2;
        if (value == "TradChinNum3") return aspose::words::cloud::models::ListLevel::NumberStyle::TRAD_CHIN_NUM3;
        if (value == "TradChinNum4") return aspose::words::cloud::models::ListLevel::NumberStyle::TRAD_CHIN_NUM4;
        if (value == "SimpChinNum1") return aspose::words::cloud::models::ListLevel::NumberStyle::SIMP_CHIN_NUM1;
        if (value == "SimpChinNum2") return aspose::words::cloud::models::ListLevel::NumberStyle::SIMP_CHIN_NUM2;
        if (value == "SimpChinNum3") return aspose::words::cloud::models::ListLevel::NumberStyle::SIMP_CHIN_NUM3;
        if (value == "SimpChinNum4") return aspose::words::cloud::models::ListLevel::NumberStyle::SIMP_CHIN_NUM4;
        if (value == "HanjaRead") return aspose::words::cloud::models::ListLevel::NumberStyle::HANJA_READ;
        if (value == "HanjaReadDigit") return aspose::words::cloud::models::ListLevel::NumberStyle::HANJA_READ_DIGIT;
        if (value == "Hangul") return aspose::words::cloud::models::ListLevel::NumberStyle::HANGUL;
        if (value == "Hanja") return aspose::words::cloud::models::ListLevel::NumberStyle::HANJA;
        if (value == "Hebrew1") return aspose::words::cloud::models::ListLevel::NumberStyle::HEBREW1;
        if (value == "Arabic1") return aspose::words::cloud::models::ListLevel::NumberStyle::ARABIC1;
        if (value == "Hebrew2") return aspose::words::cloud::models::ListLevel::NumberStyle::HEBREW2;
        if (value == "Arabic2") return aspose::words::cloud::models::ListLevel::NumberStyle::ARABIC2;
        if (value == "HindiLetter1") return aspose::words::cloud::models::ListLevel::NumberStyle::HINDI_LETTER1;
        if (value == "HindiLetter2") return aspose::words::cloud::models::ListLevel::NumberStyle::HINDI_LETTER2;
        if (value == "HindiArabic") return aspose::words::cloud::models::ListLevel::NumberStyle::HINDI_ARABIC;
        if (value == "HindiCardinalText") return aspose::words::cloud::models::ListLevel::NumberStyle::HINDI_CARDINAL_TEXT;
        if (value == "ThaiLetter") return aspose::words::cloud::models::ListLevel::NumberStyle::THAI_LETTER;
        if (value == "ThaiArabic") return aspose::words::cloud::models::ListLevel::NumberStyle::THAI_ARABIC;
        if (value == "ThaiCardinalText") return aspose::words::cloud::models::ListLevel::NumberStyle::THAI_CARDINAL_TEXT;
        if (value == "VietCardinalText") return aspose::words::cloud::models::ListLevel::NumberStyle::VIET_CARDINAL_TEXT;
        if (value == "NumberInDash") return aspose::words::cloud::models::ListLevel::NumberStyle::NUMBER_IN_DASH;
        if (value == "LowercaseRussian") return aspose::words::cloud::models::ListLevel::NumberStyle::LOWERCASE_RUSSIAN;
        if (value == "UppercaseRussian") return aspose::words::cloud::models::ListLevel::NumberStyle::UPPERCASE_RUSSIAN;
        if (value == "None") return aspose::words::cloud::models::ListLevel::NumberStyle::NONE;
        if (value == "Custom") return aspose::words::cloud::models::ListLevel::NumberStyle::CUSTOM;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string listLevelAlignmentToString(aspose::words::cloud::models::ListLevel::Alignment value)
    {
        if (value == aspose::words::cloud::models::ListLevel::Alignment::LEFT) return "Left";
        if (value == aspose::words::cloud::models::ListLevel::Alignment::CENTER) return "Center";
        if (value == aspose::words::cloud::models::ListLevel::Alignment::RIGHT) return "Right";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ListLevel::Alignment listLevelAlignmentFromString(const std::string& value)
    {
        if (value == "Left") return aspose::words::cloud::models::ListLevel::Alignment::LEFT;
        if (value == "Center") return aspose::words::cloud::models::ListLevel::Alignment::CENTER;
        if (value == "Right") return aspose::words::cloud::models::ListLevel::Alignment::RIGHT;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string listLevelTrailingCharacterToString(aspose::words::cloud::models::ListLevel::TrailingCharacter value)
    {
        if (value == aspose::words::cloud::models::ListLevel::TrailingCharacter::TAB) return "Tab";
        if (value == aspose::words::cloud::models::ListLevel::TrailingCharacter::SPACE) return "Space";
        if (value == aspose::words::cloud::models::ListLevel::TrailingCharacter::NOTHING) return "Nothing";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ListLevel::TrailingCharacter listLevelTrailingCharacterFromString(const std::string& value)
    {
        if (value == "Tab") return aspose::words::cloud::models::ListLevel::TrailingCharacter::TAB;
        if (value == "Space") return aspose::words::cloud::models::ListLevel::TrailingCharacter::SPACE;
        if (value == "Nothing") return aspose::words::cloud::models::ListLevel::TrailingCharacter::NOTHING;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void ListLevel::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_StartAt) {
            json["StartAt"] = *(this->m_StartAt);
        }
        if (this->m_NumberStyle) {
            json["NumberStyle"] = listLevelNumberStyleToString(*(this->m_NumberStyle));
        }
        if (this->m_NumberFormat) {
            json["NumberFormat"] = convertUtf16(*(this->m_NumberFormat));
        }
        if (this->m_Alignment) {
            json["Alignment"] = listLevelAlignmentToString(*(this->m_Alignment));
        }
        if (this->m_IsLegal) {
            json["IsLegal"] = *(this->m_IsLegal);
        }
        if (this->m_RestartAfterLevel) {
            json["RestartAfterLevel"] = *(this->m_RestartAfterLevel);
        }
        if (this->m_TrailingCharacter) {
            json["TrailingCharacter"] = listLevelTrailingCharacterToString(*(this->m_TrailingCharacter));
        }
        if (this->m_Font) {
            this->m_Font->toJson(&json["Font"]);
        }
        if (this->m_TabPosition) {
            json["TabPosition"] = *(this->m_TabPosition);
        }
        if (this->m_NumberPosition) {
            json["NumberPosition"] = *(this->m_NumberPosition);
        }
        if (this->m_TextPosition) {
            json["TextPosition"] = *(this->m_TextPosition);
        }
        if (this->m_LinkedStyle) {
            this->m_LinkedStyle->toJson(&json["LinkedStyle"]);
        }
    }

    void ListLevel::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("StartAt") && !json["StartAt"].is_null()) {
            this->m_StartAt = std::make_shared< int32_t >(
                json["StartAt"].get< int32_t >()
            );
        }
        if (json.contains("NumberStyle") && !json["NumberStyle"].is_null()) {
            this->m_NumberStyle = std::make_shared< aspose::words::cloud::models::ListLevel::NumberStyle >(
                listLevelNumberStyleFromString(json["NumberStyle"].get< std::string >())
            );
        }
        if (json.contains("NumberFormat") && !json["NumberFormat"].is_null()) {
            this->m_NumberFormat = std::make_shared< std::wstring >(
                convertUtf8( json["NumberFormat"].get< std::string >() )
            );
        }
        if (json.contains("Alignment") && !json["Alignment"].is_null()) {
            this->m_Alignment = std::make_shared< aspose::words::cloud::models::ListLevel::Alignment >(
                listLevelAlignmentFromString(json["Alignment"].get< std::string >())
            );
        }
        if (json.contains("IsLegal") && !json["IsLegal"].is_null()) {
            this->m_IsLegal = std::make_shared< bool >(
                json["IsLegal"].get< bool >()
            );
        }
        if (json.contains("RestartAfterLevel") && !json["RestartAfterLevel"].is_null()) {
            this->m_RestartAfterLevel = std::make_shared< int32_t >(
                json["RestartAfterLevel"].get< int32_t >()
            );
        }
        if (json.contains("TrailingCharacter") && !json["TrailingCharacter"].is_null()) {
            this->m_TrailingCharacter = std::make_shared< aspose::words::cloud::models::ListLevel::TrailingCharacter >(
                listLevelTrailingCharacterFromString(json["TrailingCharacter"].get< std::string >())
            );
        }
        if (json.contains("Font") && !json["Font"].is_null()) {
            this->m_Font = createModelInstance< aspose::words::cloud::models::Font >(L"Font, _", json["Font"]);
        }
        if (json.contains("TabPosition") && !json["TabPosition"].is_null()) {
            this->m_TabPosition = std::make_shared< double >(
                json["TabPosition"].get< double >()
            );
        }
        if (json.contains("NumberPosition") && !json["NumberPosition"].is_null()) {
            this->m_NumberPosition = std::make_shared< double >(
                json["NumberPosition"].get< double >()
            );
        }
        if (json.contains("TextPosition") && !json["TextPosition"].is_null()) {
            this->m_TextPosition = std::make_shared< double >(
                json["TextPosition"].get< double >()
            );
        }
        if (json.contains("LinkedStyle") && !json["LinkedStyle"].is_null()) {
            this->m_LinkedStyle = createModelInstance< aspose::words::cloud::models::Style >(L"Style, _", json["LinkedStyle"]);
        }
    }

    void ListLevel::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ListLevel::validate()
    {
        LinkElement::validate();
        if (this->m_StartAt == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property StartAt in ListLevel is required.");
        }

        if (this->m_NumberStyle == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property NumberStyle in ListLevel is required.");
        }

        if (this->m_Alignment == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Alignment in ListLevel is required.");
        }

        if (this->m_IsLegal == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property IsLegal in ListLevel is required.");
        }

        if (this->m_RestartAfterLevel == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property RestartAfterLevel in ListLevel is required.");
        }

        if (this->m_TrailingCharacter == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property TrailingCharacter in ListLevel is required.");
        }

        if (this->m_TabPosition == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property TabPosition in ListLevel is required.");
        }

        if (this->m_NumberPosition == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property NumberPosition in ListLevel is required.");
        }

        if (this->m_TextPosition == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property TextPosition in ListLevel is required.");
        }


        if (this->m_Font != nullptr)
        {
            this->m_Font->validate();
        }






        if (this->m_LinkedStyle != nullptr)
        {
            this->m_LinkedStyle->validate();
        }

    }

    std::shared_ptr< int32_t > ListLevel::getStartAt() const
    {
        return this->m_StartAt;
    }

    void ListLevel::setStartAt(std::shared_ptr< int32_t > value)
    {
        this->m_StartAt = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ListLevel::NumberStyle > ListLevel::getNumberStyle() const
    {
        return this->m_NumberStyle;
    }

    void ListLevel::setNumberStyle(std::shared_ptr< aspose::words::cloud::models::ListLevel::NumberStyle > value)
    {
        this->m_NumberStyle = value;
    }


    std::shared_ptr< std::wstring > ListLevel::getNumberFormat() const
    {
        return this->m_NumberFormat;
    }

    void ListLevel::setNumberFormat(std::shared_ptr< std::wstring > value)
    {
        this->m_NumberFormat = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ListLevel::Alignment > ListLevel::getAlignment() const
    {
        return this->m_Alignment;
    }

    void ListLevel::setAlignment(std::shared_ptr< aspose::words::cloud::models::ListLevel::Alignment > value)
    {
        this->m_Alignment = value;
    }


    std::shared_ptr< bool > ListLevel::getIsLegal() const
    {
        return this->m_IsLegal;
    }

    void ListLevel::setIsLegal(std::shared_ptr< bool > value)
    {
        this->m_IsLegal = value;
    }


    std::shared_ptr< int32_t > ListLevel::getRestartAfterLevel() const
    {
        return this->m_RestartAfterLevel;
    }

    void ListLevel::setRestartAfterLevel(std::shared_ptr< int32_t > value)
    {
        this->m_RestartAfterLevel = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ListLevel::TrailingCharacter > ListLevel::getTrailingCharacter() const
    {
        return this->m_TrailingCharacter;
    }

    void ListLevel::setTrailingCharacter(std::shared_ptr< aspose::words::cloud::models::ListLevel::TrailingCharacter > value)
    {
        this->m_TrailingCharacter = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Font > ListLevel::getFont() const
    {
        return this->m_Font;
    }

    void ListLevel::setFont(std::shared_ptr< aspose::words::cloud::models::Font > value)
    {
        this->m_Font = value;
    }


    std::shared_ptr< double > ListLevel::getTabPosition() const
    {
        return this->m_TabPosition;
    }

    void ListLevel::setTabPosition(std::shared_ptr< double > value)
    {
        this->m_TabPosition = value;
    }


    std::shared_ptr< double > ListLevel::getNumberPosition() const
    {
        return this->m_NumberPosition;
    }

    void ListLevel::setNumberPosition(std::shared_ptr< double > value)
    {
        this->m_NumberPosition = value;
    }


    std::shared_ptr< double > ListLevel::getTextPosition() const
    {
        return this->m_TextPosition;
    }

    void ListLevel::setTextPosition(std::shared_ptr< double > value)
    {
        this->m_TextPosition = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Style > ListLevel::getLinkedStyle() const
    {
        return this->m_LinkedStyle;
    }

    void ListLevel::setLinkedStyle(std::shared_ptr< aspose::words::cloud::models::Style > value)
    {
        this->m_LinkedStyle = value;
    }



    /*
     * ListLevels implementation
     */
    void ListLevels::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ListLevel) {
            json["ListLevel"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_ListLevel)) {
                element->toJson(&json["ListLevel"].emplace_back());
            }
        }
    }

    void ListLevels::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ListLevel") && !json["ListLevel"].is_null()) {
            this->m_ListLevel = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::ListLevel>> >();
            for (auto& element : json["ListLevel"]) {
                this->m_ListLevel->emplace_back(createModelInstance< aspose::words::cloud::models::ListLevel >(L"ListLevel, _", element));
            }
        }
    }

    void ListLevels::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ListLevels::validate()
    {
        LinkElement::validate();

        if (this->m_ListLevel != nullptr)
        {
            for (auto& elementListLevel : *(this->m_ListLevel))
            {
                if (elementListLevel != nullptr)
                {
                    elementListLevel->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::ListLevel>> > ListLevels::getListLevel() const
    {
        return this->m_ListLevel;
    }

    void ListLevels::setListLevel(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::ListLevel>> > value)
    {
        this->m_ListLevel = value;
    }



    /*
     * ListLevelUpdate implementation
     */
    inline std::string listLevelUpdateNumberStyleToString(aspose::words::cloud::models::ListLevelUpdate::NumberStyle value)
    {
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ARABIC) return "Arabic";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::UPPERCASE_ROMAN) return "UppercaseRoman";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::LOWERCASE_ROMAN) return "LowercaseRoman";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::UPPERCASE_LETTER) return "UppercaseLetter";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::LOWERCASE_LETTER) return "LowercaseLetter";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ORDINAL) return "Ordinal";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::NUMBER) return "Number";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ORDINAL_TEXT) return "OrdinalText";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HEX) return "Hex";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::CHICAGO_MANUAL) return "ChicagoManual";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::KANJI) return "Kanji";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::KANJI_DIGIT) return "KanjiDigit";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::AIUEO_HALF_WIDTH) return "AiueoHalfWidth";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::IROHA_HALF_WIDTH) return "IrohaHalfWidth";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ARABIC_FULL_WIDTH) return "ArabicFullWidth";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ARABIC_HALF_WIDTH) return "ArabicHalfWidth";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::KANJI_TRADITIONAL) return "KanjiTraditional";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::KANJI_TRADITIONAL2) return "KanjiTraditional2";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::NUMBER_IN_CIRCLE) return "NumberInCircle";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::DECIMAL_FULL_WIDTH) return "DecimalFullWidth";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::AIUEO) return "Aiueo";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::IROHA) return "Iroha";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::LEADING_ZERO) return "LeadingZero";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::BULLET) return "Bullet";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::GANADA) return "Ganada";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::CHOSUNG) return "Chosung";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::G_B1) return "GB1";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::G_B2) return "GB2";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::G_B3) return "GB3";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::G_B4) return "GB4";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ZODIAC1) return "Zodiac1";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ZODIAC2) return "Zodiac2";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ZODIAC3) return "Zodiac3";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::TRAD_CHIN_NUM1) return "TradChinNum1";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::TRAD_CHIN_NUM2) return "TradChinNum2";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::TRAD_CHIN_NUM3) return "TradChinNum3";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::TRAD_CHIN_NUM4) return "TradChinNum4";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::SIMP_CHIN_NUM1) return "SimpChinNum1";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::SIMP_CHIN_NUM2) return "SimpChinNum2";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::SIMP_CHIN_NUM3) return "SimpChinNum3";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::SIMP_CHIN_NUM4) return "SimpChinNum4";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HANJA_READ) return "HanjaRead";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HANJA_READ_DIGIT) return "HanjaReadDigit";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HANGUL) return "Hangul";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HANJA) return "Hanja";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HEBREW1) return "Hebrew1";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ARABIC1) return "Arabic1";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HEBREW2) return "Hebrew2";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ARABIC2) return "Arabic2";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HINDI_LETTER1) return "HindiLetter1";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HINDI_LETTER2) return "HindiLetter2";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HINDI_ARABIC) return "HindiArabic";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HINDI_CARDINAL_TEXT) return "HindiCardinalText";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::THAI_LETTER) return "ThaiLetter";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::THAI_ARABIC) return "ThaiArabic";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::THAI_CARDINAL_TEXT) return "ThaiCardinalText";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::VIET_CARDINAL_TEXT) return "VietCardinalText";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::NUMBER_IN_DASH) return "NumberInDash";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::LOWERCASE_RUSSIAN) return "LowercaseRussian";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::UPPERCASE_RUSSIAN) return "UppercaseRussian";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::NONE) return "None";
        if (value == aspose::words::cloud::models::ListLevelUpdate::NumberStyle::CUSTOM) return "Custom";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ListLevelUpdate::NumberStyle listLevelUpdateNumberStyleFromString(const std::string& value)
    {
        if (value == "Arabic") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ARABIC;
        if (value == "UppercaseRoman") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::UPPERCASE_ROMAN;
        if (value == "LowercaseRoman") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::LOWERCASE_ROMAN;
        if (value == "UppercaseLetter") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::UPPERCASE_LETTER;
        if (value == "LowercaseLetter") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::LOWERCASE_LETTER;
        if (value == "Ordinal") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ORDINAL;
        if (value == "Number") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::NUMBER;
        if (value == "OrdinalText") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ORDINAL_TEXT;
        if (value == "Hex") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HEX;
        if (value == "ChicagoManual") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::CHICAGO_MANUAL;
        if (value == "Kanji") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::KANJI;
        if (value == "KanjiDigit") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::KANJI_DIGIT;
        if (value == "AiueoHalfWidth") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::AIUEO_HALF_WIDTH;
        if (value == "IrohaHalfWidth") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::IROHA_HALF_WIDTH;
        if (value == "ArabicFullWidth") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ARABIC_FULL_WIDTH;
        if (value == "ArabicHalfWidth") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ARABIC_HALF_WIDTH;
        if (value == "KanjiTraditional") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::KANJI_TRADITIONAL;
        if (value == "KanjiTraditional2") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::KANJI_TRADITIONAL2;
        if (value == "NumberInCircle") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::NUMBER_IN_CIRCLE;
        if (value == "DecimalFullWidth") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::DECIMAL_FULL_WIDTH;
        if (value == "Aiueo") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::AIUEO;
        if (value == "Iroha") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::IROHA;
        if (value == "LeadingZero") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::LEADING_ZERO;
        if (value == "Bullet") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::BULLET;
        if (value == "Ganada") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::GANADA;
        if (value == "Chosung") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::CHOSUNG;
        if (value == "GB1") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::G_B1;
        if (value == "GB2") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::G_B2;
        if (value == "GB3") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::G_B3;
        if (value == "GB4") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::G_B4;
        if (value == "Zodiac1") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ZODIAC1;
        if (value == "Zodiac2") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ZODIAC2;
        if (value == "Zodiac3") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ZODIAC3;
        if (value == "TradChinNum1") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::TRAD_CHIN_NUM1;
        if (value == "TradChinNum2") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::TRAD_CHIN_NUM2;
        if (value == "TradChinNum3") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::TRAD_CHIN_NUM3;
        if (value == "TradChinNum4") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::TRAD_CHIN_NUM4;
        if (value == "SimpChinNum1") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::SIMP_CHIN_NUM1;
        if (value == "SimpChinNum2") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::SIMP_CHIN_NUM2;
        if (value == "SimpChinNum3") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::SIMP_CHIN_NUM3;
        if (value == "SimpChinNum4") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::SIMP_CHIN_NUM4;
        if (value == "HanjaRead") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HANJA_READ;
        if (value == "HanjaReadDigit") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HANJA_READ_DIGIT;
        if (value == "Hangul") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HANGUL;
        if (value == "Hanja") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HANJA;
        if (value == "Hebrew1") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HEBREW1;
        if (value == "Arabic1") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ARABIC1;
        if (value == "Hebrew2") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HEBREW2;
        if (value == "Arabic2") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::ARABIC2;
        if (value == "HindiLetter1") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HINDI_LETTER1;
        if (value == "HindiLetter2") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HINDI_LETTER2;
        if (value == "HindiArabic") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HINDI_ARABIC;
        if (value == "HindiCardinalText") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::HINDI_CARDINAL_TEXT;
        if (value == "ThaiLetter") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::THAI_LETTER;
        if (value == "ThaiArabic") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::THAI_ARABIC;
        if (value == "ThaiCardinalText") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::THAI_CARDINAL_TEXT;
        if (value == "VietCardinalText") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::VIET_CARDINAL_TEXT;
        if (value == "NumberInDash") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::NUMBER_IN_DASH;
        if (value == "LowercaseRussian") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::LOWERCASE_RUSSIAN;
        if (value == "UppercaseRussian") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::UPPERCASE_RUSSIAN;
        if (value == "None") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::NONE;
        if (value == "Custom") return aspose::words::cloud::models::ListLevelUpdate::NumberStyle::CUSTOM;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string listLevelUpdateAlignmentToString(aspose::words::cloud::models::ListLevelUpdate::Alignment value)
    {
        if (value == aspose::words::cloud::models::ListLevelUpdate::Alignment::LEFT) return "Left";
        if (value == aspose::words::cloud::models::ListLevelUpdate::Alignment::CENTER) return "Center";
        if (value == aspose::words::cloud::models::ListLevelUpdate::Alignment::RIGHT) return "Right";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ListLevelUpdate::Alignment listLevelUpdateAlignmentFromString(const std::string& value)
    {
        if (value == "Left") return aspose::words::cloud::models::ListLevelUpdate::Alignment::LEFT;
        if (value == "Center") return aspose::words::cloud::models::ListLevelUpdate::Alignment::CENTER;
        if (value == "Right") return aspose::words::cloud::models::ListLevelUpdate::Alignment::RIGHT;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string listLevelUpdateTrailingCharacterToString(aspose::words::cloud::models::ListLevelUpdate::TrailingCharacter value)
    {
        if (value == aspose::words::cloud::models::ListLevelUpdate::TrailingCharacter::TAB) return "Tab";
        if (value == aspose::words::cloud::models::ListLevelUpdate::TrailingCharacter::SPACE) return "Space";
        if (value == aspose::words::cloud::models::ListLevelUpdate::TrailingCharacter::NOTHING) return "Nothing";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ListLevelUpdate::TrailingCharacter listLevelUpdateTrailingCharacterFromString(const std::string& value)
    {
        if (value == "Tab") return aspose::words::cloud::models::ListLevelUpdate::TrailingCharacter::TAB;
        if (value == "Space") return aspose::words::cloud::models::ListLevelUpdate::TrailingCharacter::SPACE;
        if (value == "Nothing") return aspose::words::cloud::models::ListLevelUpdate::TrailingCharacter::NOTHING;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void ListLevelUpdate::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_StartAt) {
            json["StartAt"] = *(this->m_StartAt);
        }
        if (this->m_NumberStyle) {
            json["NumberStyle"] = listLevelUpdateNumberStyleToString(*(this->m_NumberStyle));
        }
        if (this->m_NumberFormat) {
            json["NumberFormat"] = convertUtf16(*(this->m_NumberFormat));
        }
        if (this->m_Alignment) {
            json["Alignment"] = listLevelUpdateAlignmentToString(*(this->m_Alignment));
        }
        if (this->m_IsLegal) {
            json["IsLegal"] = *(this->m_IsLegal);
        }
        if (this->m_RestartAfterLevel) {
            json["RestartAfterLevel"] = *(this->m_RestartAfterLevel);
        }
        if (this->m_TrailingCharacter) {
            json["TrailingCharacter"] = listLevelUpdateTrailingCharacterToString(*(this->m_TrailingCharacter));
        }
        if (this->m_TabPosition) {
            json["TabPosition"] = *(this->m_TabPosition);
        }
        if (this->m_NumberPosition) {
            json["NumberPosition"] = *(this->m_NumberPosition);
        }
        if (this->m_TextPosition) {
            json["TextPosition"] = *(this->m_TextPosition);
        }
    }

    void ListLevelUpdate::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("StartAt") && !json["StartAt"].is_null()) {
            this->m_StartAt = std::make_shared< int32_t >(
                json["StartAt"].get< int32_t >()
            );
        }
        if (json.contains("NumberStyle") && !json["NumberStyle"].is_null()) {
            this->m_NumberStyle = std::make_shared< aspose::words::cloud::models::ListLevelUpdate::NumberStyle >(
                listLevelUpdateNumberStyleFromString(json["NumberStyle"].get< std::string >())
            );
        }
        if (json.contains("NumberFormat") && !json["NumberFormat"].is_null()) {
            this->m_NumberFormat = std::make_shared< std::wstring >(
                convertUtf8( json["NumberFormat"].get< std::string >() )
            );
        }
        if (json.contains("Alignment") && !json["Alignment"].is_null()) {
            this->m_Alignment = std::make_shared< aspose::words::cloud::models::ListLevelUpdate::Alignment >(
                listLevelUpdateAlignmentFromString(json["Alignment"].get< std::string >())
            );
        }
        if (json.contains("IsLegal") && !json["IsLegal"].is_null()) {
            this->m_IsLegal = std::make_shared< bool >(
                json["IsLegal"].get< bool >()
            );
        }
        if (json.contains("RestartAfterLevel") && !json["RestartAfterLevel"].is_null()) {
            this->m_RestartAfterLevel = std::make_shared< int32_t >(
                json["RestartAfterLevel"].get< int32_t >()
            );
        }
        if (json.contains("TrailingCharacter") && !json["TrailingCharacter"].is_null()) {
            this->m_TrailingCharacter = std::make_shared< aspose::words::cloud::models::ListLevelUpdate::TrailingCharacter >(
                listLevelUpdateTrailingCharacterFromString(json["TrailingCharacter"].get< std::string >())
            );
        }
        if (json.contains("TabPosition") && !json["TabPosition"].is_null()) {
            this->m_TabPosition = std::make_shared< double >(
                json["TabPosition"].get< double >()
            );
        }
        if (json.contains("NumberPosition") && !json["NumberPosition"].is_null()) {
            this->m_NumberPosition = std::make_shared< double >(
                json["NumberPosition"].get< double >()
            );
        }
        if (json.contains("TextPosition") && !json["TextPosition"].is_null()) {
            this->m_TextPosition = std::make_shared< double >(
                json["TextPosition"].get< double >()
            );
        }
    }

    void ListLevelUpdate::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ListLevelUpdate::validate()
    {
    }

    std::shared_ptr< int32_t > ListLevelUpdate::getStartAt() const
    {
        return this->m_StartAt;
    }

    void ListLevelUpdate::setStartAt(std::shared_ptr< int32_t > value)
    {
        this->m_StartAt = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ListLevelUpdate::NumberStyle > ListLevelUpdate::getNumberStyle() const
    {
        return this->m_NumberStyle;
    }

    void ListLevelUpdate::setNumberStyle(std::shared_ptr< aspose::words::cloud::models::ListLevelUpdate::NumberStyle > value)
    {
        this->m_NumberStyle = value;
    }


    std::shared_ptr< std::wstring > ListLevelUpdate::getNumberFormat() const
    {
        return this->m_NumberFormat;
    }

    void ListLevelUpdate::setNumberFormat(std::shared_ptr< std::wstring > value)
    {
        this->m_NumberFormat = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ListLevelUpdate::Alignment > ListLevelUpdate::getAlignment() const
    {
        return this->m_Alignment;
    }

    void ListLevelUpdate::setAlignment(std::shared_ptr< aspose::words::cloud::models::ListLevelUpdate::Alignment > value)
    {
        this->m_Alignment = value;
    }


    std::shared_ptr< bool > ListLevelUpdate::getIsLegal() const
    {
        return this->m_IsLegal;
    }

    void ListLevelUpdate::setIsLegal(std::shared_ptr< bool > value)
    {
        this->m_IsLegal = value;
    }


    std::shared_ptr< int32_t > ListLevelUpdate::getRestartAfterLevel() const
    {
        return this->m_RestartAfterLevel;
    }

    void ListLevelUpdate::setRestartAfterLevel(std::shared_ptr< int32_t > value)
    {
        this->m_RestartAfterLevel = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ListLevelUpdate::TrailingCharacter > ListLevelUpdate::getTrailingCharacter() const
    {
        return this->m_TrailingCharacter;
    }

    void ListLevelUpdate::setTrailingCharacter(std::shared_ptr< aspose::words::cloud::models::ListLevelUpdate::TrailingCharacter > value)
    {
        this->m_TrailingCharacter = value;
    }


    std::shared_ptr< double > ListLevelUpdate::getTabPosition() const
    {
        return this->m_TabPosition;
    }

    void ListLevelUpdate::setTabPosition(std::shared_ptr< double > value)
    {
        this->m_TabPosition = value;
    }


    std::shared_ptr< double > ListLevelUpdate::getNumberPosition() const
    {
        return this->m_NumberPosition;
    }

    void ListLevelUpdate::setNumberPosition(std::shared_ptr< double > value)
    {
        this->m_NumberPosition = value;
    }


    std::shared_ptr< double > ListLevelUpdate::getTextPosition() const
    {
        return this->m_TextPosition;
    }

    void ListLevelUpdate::setTextPosition(std::shared_ptr< double > value)
    {
        this->m_TextPosition = value;
    }



    /*
     * ListResponse implementation
     */
    void ListResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_List) {
            this->m_List->toJson(&json["List"]);
        }
    }

    void ListResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("List") && !json["List"].is_null()) {
            this->m_List = createModelInstance< aspose::words::cloud::models::ListInfo >(L"ListInfo, _", json["List"]);
        }
    }

    void ListResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ListResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_List != nullptr)
        {
            this->m_List->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::ListInfo > ListResponse::getList() const
    {
        return this->m_List;
    }

    void ListResponse::setList(std::shared_ptr< aspose::words::cloud::models::ListInfo > value)
    {
        this->m_List = value;
    }



    /*
     * Lists implementation
     */
    void Lists::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ListInfo) {
            json["ListInfo"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_ListInfo)) {
                element->toJson(&json["ListInfo"].emplace_back());
            }
        }
    }

    void Lists::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ListInfo") && !json["ListInfo"].is_null()) {
            this->m_ListInfo = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::ListInfo>> >();
            for (auto& element : json["ListInfo"]) {
                this->m_ListInfo->emplace_back(createModelInstance< aspose::words::cloud::models::ListInfo >(L"ListInfo, _", element));
            }
        }
    }

    void Lists::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Lists::validate()
    {
        LinkElement::validate();

        if (this->m_ListInfo != nullptr)
        {
            for (auto& elementListInfo : *(this->m_ListInfo))
            {
                if (elementListInfo != nullptr)
                {
                    elementListInfo->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::ListInfo>> > Lists::getListInfo() const
    {
        return this->m_ListInfo;
    }

    void Lists::setListInfo(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::ListInfo>> > value)
    {
        this->m_ListInfo = value;
    }



    /*
     * ListsResponse implementation
     */
    void ListsResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Lists) {
            this->m_Lists->toJson(&json["Lists"]);
        }
    }

    void ListsResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Lists") && !json["Lists"].is_null()) {
            this->m_Lists = createModelInstance< aspose::words::cloud::models::Lists >(L"Lists, _", json["Lists"]);
        }
    }

    void ListsResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ListsResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Lists != nullptr)
        {
            this->m_Lists->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Lists > ListsResponse::getLists() const
    {
        return this->m_Lists;
    }

    void ListsResponse::setLists(std::shared_ptr< aspose::words::cloud::models::Lists > value)
    {
        this->m_Lists = value;
    }



    /*
     * ListUpdate implementation
     */
    void ListUpdate::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_IsRestartAtEachSection) {
            json["IsRestartAtEachSection"] = *(this->m_IsRestartAtEachSection);
        }
    }

    void ListUpdate::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("IsRestartAtEachSection") && !json["IsRestartAtEachSection"].is_null()) {
            this->m_IsRestartAtEachSection = std::make_shared< bool >(
                json["IsRestartAtEachSection"].get< bool >()
            );
        }
    }

    void ListUpdate::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ListUpdate::validate()
    {
    }

    std::shared_ptr< bool > ListUpdate::getIsRestartAtEachSection() const
    {
        return this->m_IsRestartAtEachSection;
    }

    void ListUpdate::setIsRestartAtEachSection(std::shared_ptr< bool > value)
    {
        this->m_IsRestartAtEachSection = value;
    }



    /*
     * LoadWebDocumentData implementation
     */
    void LoadWebDocumentData::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveOptions) {
            this->m_SaveOptions->toJson(&json["SaveOptions"]);
        }
        if (this->m_LoadingDocumentUrl) {
            json["LoadingDocumentUrl"] = convertUtf16(*(this->m_LoadingDocumentUrl));
        }
    }

    void LoadWebDocumentData::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveOptions") && !json["SaveOptions"].is_null()) {
            this->m_SaveOptions = createModelInstance< aspose::words::cloud::models::SaveOptionsData >(L"SaveOptionsData, _", json["SaveOptions"]);
        }
        if (json.contains("LoadingDocumentUrl") && !json["LoadingDocumentUrl"].is_null()) {
            this->m_LoadingDocumentUrl = std::make_shared< std::wstring >(
                convertUtf8( json["LoadingDocumentUrl"].get< std::string >() )
            );
        }
    }

    void LoadWebDocumentData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void LoadWebDocumentData::validate()
    {
        if (this->m_LoadingDocumentUrl == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property LoadingDocumentUrl in LoadWebDocumentData is required.");
        }


        if (this->m_SaveOptions != nullptr)
        {
            this->m_SaveOptions->validate();
        }


    }

    std::shared_ptr< aspose::words::cloud::models::SaveOptionsData > LoadWebDocumentData::getSaveOptions() const
    {
        return this->m_SaveOptions;
    }

    void LoadWebDocumentData::setSaveOptions(std::shared_ptr< aspose::words::cloud::models::SaveOptionsData > value)
    {
        this->m_SaveOptions = value;
    }


    std::shared_ptr< std::wstring > LoadWebDocumentData::getLoadingDocumentUrl() const
    {
        return this->m_LoadingDocumentUrl;
    }

    void LoadWebDocumentData::setLoadingDocumentUrl(std::shared_ptr< std::wstring > value)
    {
        this->m_LoadingDocumentUrl = value;
    }



    /*
     * MarkdownSaveOptionsData implementation
     */
    inline std::string markdownSaveOptionsDataTableContentAlignmentToString(aspose::words::cloud::models::MarkdownSaveOptionsData::TableContentAlignment value)
    {
        if (value == aspose::words::cloud::models::MarkdownSaveOptionsData::TableContentAlignment::AUTO) return "Auto";
        if (value == aspose::words::cloud::models::MarkdownSaveOptionsData::TableContentAlignment::LEFT) return "Left";
        if (value == aspose::words::cloud::models::MarkdownSaveOptionsData::TableContentAlignment::CENTER) return "Center";
        if (value == aspose::words::cloud::models::MarkdownSaveOptionsData::TableContentAlignment::RIGHT) return "Right";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::MarkdownSaveOptionsData::TableContentAlignment markdownSaveOptionsDataTableContentAlignmentFromString(const std::string& value)
    {
        if (value == "Auto") return aspose::words::cloud::models::MarkdownSaveOptionsData::TableContentAlignment::AUTO;
        if (value == "Left") return aspose::words::cloud::models::MarkdownSaveOptionsData::TableContentAlignment::LEFT;
        if (value == "Center") return aspose::words::cloud::models::MarkdownSaveOptionsData::TableContentAlignment::CENTER;
        if (value == "Right") return aspose::words::cloud::models::MarkdownSaveOptionsData::TableContentAlignment::RIGHT;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void MarkdownSaveOptionsData::toJson(void* jsonIfc) const
    {
        TxtSaveOptionsBaseData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_TableContentAlignment) {
            json["TableContentAlignment"] = markdownSaveOptionsDataTableContentAlignmentToString(*(this->m_TableContentAlignment));
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void MarkdownSaveOptionsData::fromJson(const void* jsonIfc)
    {
        TxtSaveOptionsBaseData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("TableContentAlignment") && !json["TableContentAlignment"].is_null()) {
            this->m_TableContentAlignment = std::make_shared< aspose::words::cloud::models::MarkdownSaveOptionsData::TableContentAlignment >(
                markdownSaveOptionsDataTableContentAlignmentFromString(json["TableContentAlignment"].get< std::string >())
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void MarkdownSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void MarkdownSaveOptionsData::validate()
    {
        TxtSaveOptionsBaseData::validate();
    }

    std::shared_ptr< aspose::words::cloud::models::MarkdownSaveOptionsData::TableContentAlignment > MarkdownSaveOptionsData::getTableContentAlignment() const
    {
        return this->m_TableContentAlignment;
    }

    void MarkdownSaveOptionsData::setTableContentAlignment(std::shared_ptr< aspose::words::cloud::models::MarkdownSaveOptionsData::TableContentAlignment > value)
    {
        this->m_TableContentAlignment = value;
    }


    std::shared_ptr< std::wstring > MarkdownSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * MetafileRenderingOptionsData implementation
     */
    inline std::string metafileRenderingOptionsDataEmfPlusDualRenderingModeToString(aspose::words::cloud::models::MetafileRenderingOptionsData::EmfPlusDualRenderingMode value)
    {
        if (value == aspose::words::cloud::models::MetafileRenderingOptionsData::EmfPlusDualRenderingMode::EMF_PLUS_WITH_FALLBACK) return "EmfPlusWithFallback";
        if (value == aspose::words::cloud::models::MetafileRenderingOptionsData::EmfPlusDualRenderingMode::EMF_PLUS) return "EmfPlus";
        if (value == aspose::words::cloud::models::MetafileRenderingOptionsData::EmfPlusDualRenderingMode::EMF) return "Emf";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::MetafileRenderingOptionsData::EmfPlusDualRenderingMode metafileRenderingOptionsDataEmfPlusDualRenderingModeFromString(const std::string& value)
    {
        if (value == "EmfPlusWithFallback") return aspose::words::cloud::models::MetafileRenderingOptionsData::EmfPlusDualRenderingMode::EMF_PLUS_WITH_FALLBACK;
        if (value == "EmfPlus") return aspose::words::cloud::models::MetafileRenderingOptionsData::EmfPlusDualRenderingMode::EMF_PLUS;
        if (value == "Emf") return aspose::words::cloud::models::MetafileRenderingOptionsData::EmfPlusDualRenderingMode::EMF;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string metafileRenderingOptionsDataRenderingModeToString(aspose::words::cloud::models::MetafileRenderingOptionsData::RenderingMode value)
    {
        if (value == aspose::words::cloud::models::MetafileRenderingOptionsData::RenderingMode::VECTOR_WITH_FALLBACK) return "VectorWithFallback";
        if (value == aspose::words::cloud::models::MetafileRenderingOptionsData::RenderingMode::VECTOR) return "Vector";
        if (value == aspose::words::cloud::models::MetafileRenderingOptionsData::RenderingMode::BITMAP) return "Bitmap";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::MetafileRenderingOptionsData::RenderingMode metafileRenderingOptionsDataRenderingModeFromString(const std::string& value)
    {
        if (value == "VectorWithFallback") return aspose::words::cloud::models::MetafileRenderingOptionsData::RenderingMode::VECTOR_WITH_FALLBACK;
        if (value == "Vector") return aspose::words::cloud::models::MetafileRenderingOptionsData::RenderingMode::VECTOR;
        if (value == "Bitmap") return aspose::words::cloud::models::MetafileRenderingOptionsData::RenderingMode::BITMAP;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void MetafileRenderingOptionsData::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_EmfPlusDualRenderingMode) {
            json["EmfPlusDualRenderingMode"] = metafileRenderingOptionsDataEmfPlusDualRenderingModeToString(*(this->m_EmfPlusDualRenderingMode));
        }
        if (this->m_EmulateRasterOperations) {
            json["EmulateRasterOperations"] = *(this->m_EmulateRasterOperations);
        }
        if (this->m_EmulateRenderingToSizeOnPage) {
            json["EmulateRenderingToSizeOnPage"] = *(this->m_EmulateRenderingToSizeOnPage);
        }
        if (this->m_EmulateRenderingToSizeOnPageResolution) {
            json["EmulateRenderingToSizeOnPageResolution"] = *(this->m_EmulateRenderingToSizeOnPageResolution);
        }
        if (this->m_RenderingMode) {
            json["RenderingMode"] = metafileRenderingOptionsDataRenderingModeToString(*(this->m_RenderingMode));
        }
        if (this->m_UseEmfEmbeddedToWmf) {
            json["UseEmfEmbeddedToWmf"] = *(this->m_UseEmfEmbeddedToWmf);
        }
    }

    void MetafileRenderingOptionsData::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("EmfPlusDualRenderingMode") && !json["EmfPlusDualRenderingMode"].is_null()) {
            this->m_EmfPlusDualRenderingMode = std::make_shared< aspose::words::cloud::models::MetafileRenderingOptionsData::EmfPlusDualRenderingMode >(
                metafileRenderingOptionsDataEmfPlusDualRenderingModeFromString(json["EmfPlusDualRenderingMode"].get< std::string >())
            );
        }
        if (json.contains("EmulateRasterOperations") && !json["EmulateRasterOperations"].is_null()) {
            this->m_EmulateRasterOperations = std::make_shared< bool >(
                json["EmulateRasterOperations"].get< bool >()
            );
        }
        if (json.contains("EmulateRenderingToSizeOnPage") && !json["EmulateRenderingToSizeOnPage"].is_null()) {
            this->m_EmulateRenderingToSizeOnPage = std::make_shared< bool >(
                json["EmulateRenderingToSizeOnPage"].get< bool >()
            );
        }
        if (json.contains("EmulateRenderingToSizeOnPageResolution") && !json["EmulateRenderingToSizeOnPageResolution"].is_null()) {
            this->m_EmulateRenderingToSizeOnPageResolution = std::make_shared< int32_t >(
                json["EmulateRenderingToSizeOnPageResolution"].get< int32_t >()
            );
        }
        if (json.contains("RenderingMode") && !json["RenderingMode"].is_null()) {
            this->m_RenderingMode = std::make_shared< aspose::words::cloud::models::MetafileRenderingOptionsData::RenderingMode >(
                metafileRenderingOptionsDataRenderingModeFromString(json["RenderingMode"].get< std::string >())
            );
        }
        if (json.contains("UseEmfEmbeddedToWmf") && !json["UseEmfEmbeddedToWmf"].is_null()) {
            this->m_UseEmfEmbeddedToWmf = std::make_shared< bool >(
                json["UseEmfEmbeddedToWmf"].get< bool >()
            );
        }
    }

    void MetafileRenderingOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void MetafileRenderingOptionsData::validate()
    {
    }

    std::shared_ptr< aspose::words::cloud::models::MetafileRenderingOptionsData::EmfPlusDualRenderingMode > MetafileRenderingOptionsData::getEmfPlusDualRenderingMode() const
    {
        return this->m_EmfPlusDualRenderingMode;
    }

    void MetafileRenderingOptionsData::setEmfPlusDualRenderingMode(std::shared_ptr< aspose::words::cloud::models::MetafileRenderingOptionsData::EmfPlusDualRenderingMode > value)
    {
        this->m_EmfPlusDualRenderingMode = value;
    }


    std::shared_ptr< bool > MetafileRenderingOptionsData::getEmulateRasterOperations() const
    {
        return this->m_EmulateRasterOperations;
    }

    void MetafileRenderingOptionsData::setEmulateRasterOperations(std::shared_ptr< bool > value)
    {
        this->m_EmulateRasterOperations = value;
    }


    std::shared_ptr< bool > MetafileRenderingOptionsData::getEmulateRenderingToSizeOnPage() const
    {
        return this->m_EmulateRenderingToSizeOnPage;
    }

    void MetafileRenderingOptionsData::setEmulateRenderingToSizeOnPage(std::shared_ptr< bool > value)
    {
        this->m_EmulateRenderingToSizeOnPage = value;
    }


    std::shared_ptr< int32_t > MetafileRenderingOptionsData::getEmulateRenderingToSizeOnPageResolution() const
    {
        return this->m_EmulateRenderingToSizeOnPageResolution;
    }

    void MetafileRenderingOptionsData::setEmulateRenderingToSizeOnPageResolution(std::shared_ptr< int32_t > value)
    {
        this->m_EmulateRenderingToSizeOnPageResolution = value;
    }


    std::shared_ptr< aspose::words::cloud::models::MetafileRenderingOptionsData::RenderingMode > MetafileRenderingOptionsData::getRenderingMode() const
    {
        return this->m_RenderingMode;
    }

    void MetafileRenderingOptionsData::setRenderingMode(std::shared_ptr< aspose::words::cloud::models::MetafileRenderingOptionsData::RenderingMode > value)
    {
        this->m_RenderingMode = value;
    }


    std::shared_ptr< bool > MetafileRenderingOptionsData::getUseEmfEmbeddedToWmf() const
    {
        return this->m_UseEmfEmbeddedToWmf;
    }

    void MetafileRenderingOptionsData::setUseEmfEmbeddedToWmf(std::shared_ptr< bool > value)
    {
        this->m_UseEmfEmbeddedToWmf = value;
    }



    /*
     * MhtmlSaveOptionsData implementation
     */
    void MhtmlSaveOptionsData::toJson(void* jsonIfc) const
    {
        HtmlSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ExportCidUrlsForMhtmlResources) {
            json["ExportCidUrlsForMhtmlResources"] = *(this->m_ExportCidUrlsForMhtmlResources);
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void MhtmlSaveOptionsData::fromJson(const void* jsonIfc)
    {
        HtmlSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ExportCidUrlsForMhtmlResources") && !json["ExportCidUrlsForMhtmlResources"].is_null()) {
            this->m_ExportCidUrlsForMhtmlResources = std::make_shared< bool >(
                json["ExportCidUrlsForMhtmlResources"].get< bool >()
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void MhtmlSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void MhtmlSaveOptionsData::validate()
    {
        HtmlSaveOptionsData::validate();
    }

    std::shared_ptr< bool > MhtmlSaveOptionsData::getExportCidUrlsForMhtmlResources() const
    {
        return this->m_ExportCidUrlsForMhtmlResources;
    }

    void MhtmlSaveOptionsData::setExportCidUrlsForMhtmlResources(std::shared_ptr< bool > value)
    {
        this->m_ExportCidUrlsForMhtmlResources = value;
    }


    std::shared_ptr< std::wstring > MhtmlSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * ModificationOperationResult implementation
     */
    void ModificationOperationResult::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Dest) {
            this->m_Dest->toJson(&json["Dest"]);
        }
        if (this->m_Source) {
            this->m_Source->toJson(&json["Source"]);
        }
    }

    void ModificationOperationResult::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Dest") && !json["Dest"].is_null()) {
            this->m_Dest = createModelInstance< aspose::words::cloud::models::FileLink >(L"FileLink, _", json["Dest"]);
        }
        if (json.contains("Source") && !json["Source"].is_null()) {
            this->m_Source = createModelInstance< aspose::words::cloud::models::FileLink >(L"FileLink, _", json["Source"]);
        }
    }

    void ModificationOperationResult::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ModificationOperationResult::validate()
    {

        if (this->m_Dest != nullptr)
        {
            this->m_Dest->validate();
        }



        if (this->m_Source != nullptr)
        {
            this->m_Source->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::FileLink > ModificationOperationResult::getDest() const
    {
        return this->m_Dest;
    }

    void ModificationOperationResult::setDest(std::shared_ptr< aspose::words::cloud::models::FileLink > value)
    {
        this->m_Dest = value;
    }


    std::shared_ptr< aspose::words::cloud::models::FileLink > ModificationOperationResult::getSource() const
    {
        return this->m_Source;
    }

    void ModificationOperationResult::setSource(std::shared_ptr< aspose::words::cloud::models::FileLink > value)
    {
        this->m_Source = value;
    }



    /*
     * NodeLink implementation
     */
    void NodeLink::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_NodeId) {
            json["NodeId"] = convertUtf16(*(this->m_NodeId));
        }
    }

    void NodeLink::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("NodeId") && !json["NodeId"].is_null()) {
            this->m_NodeId = std::make_shared< std::wstring >(
                convertUtf8( json["NodeId"].get< std::string >() )
            );
        }
    }

    void NodeLink::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void NodeLink::validate()
    {
        LinkElement::validate();
    }

    std::shared_ptr< std::wstring > NodeLink::getNodeId() const
    {
        return this->m_NodeId;
    }

    void NodeLink::setNodeId(std::shared_ptr< std::wstring > value)
    {
        this->m_NodeId = value;
    }



    /*
     * OdtSaveOptionsData implementation
     */
    inline std::string odtSaveOptionsDataMeasureUnitToString(aspose::words::cloud::models::OdtSaveOptionsData::MeasureUnit value)
    {
        if (value == aspose::words::cloud::models::OdtSaveOptionsData::MeasureUnit::CENTIMETERS) return "Centimeters";
        if (value == aspose::words::cloud::models::OdtSaveOptionsData::MeasureUnit::INCHES) return "Inches";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::OdtSaveOptionsData::MeasureUnit odtSaveOptionsDataMeasureUnitFromString(const std::string& value)
    {
        if (value == "Centimeters") return aspose::words::cloud::models::OdtSaveOptionsData::MeasureUnit::CENTIMETERS;
        if (value == "Inches") return aspose::words::cloud::models::OdtSaveOptionsData::MeasureUnit::INCHES;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void OdtSaveOptionsData::toJson(void* jsonIfc) const
    {
        SaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_IsStrictSchema11) {
            json["IsStrictSchema11"] = *(this->m_IsStrictSchema11);
        }
        if (this->m_MeasureUnit) {
            json["MeasureUnit"] = odtSaveOptionsDataMeasureUnitToString(*(this->m_MeasureUnit));
        }
        if (this->m_Password) {
            json["Password"] = convertUtf16(*(this->m_Password));
        }
        if (this->m_PrettyFormat) {
            json["PrettyFormat"] = *(this->m_PrettyFormat);
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void OdtSaveOptionsData::fromJson(const void* jsonIfc)
    {
        SaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("IsStrictSchema11") && !json["IsStrictSchema11"].is_null()) {
            this->m_IsStrictSchema11 = std::make_shared< bool >(
                json["IsStrictSchema11"].get< bool >()
            );
        }
        if (json.contains("MeasureUnit") && !json["MeasureUnit"].is_null()) {
            this->m_MeasureUnit = std::make_shared< aspose::words::cloud::models::OdtSaveOptionsData::MeasureUnit >(
                odtSaveOptionsDataMeasureUnitFromString(json["MeasureUnit"].get< std::string >())
            );
        }
        if (json.contains("Password") && !json["Password"].is_null()) {
            this->m_Password = std::make_shared< std::wstring >(
                convertUtf8( json["Password"].get< std::string >() )
            );
        }
        if (json.contains("PrettyFormat") && !json["PrettyFormat"].is_null()) {
            this->m_PrettyFormat = std::make_shared< bool >(
                json["PrettyFormat"].get< bool >()
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void OdtSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void OdtSaveOptionsData::validate()
    {
        SaveOptionsData::validate();
    }

    std::shared_ptr< bool > OdtSaveOptionsData::getIsStrictSchema11() const
    {
        return this->m_IsStrictSchema11;
    }

    void OdtSaveOptionsData::setIsStrictSchema11(std::shared_ptr< bool > value)
    {
        this->m_IsStrictSchema11 = value;
    }


    std::shared_ptr< aspose::words::cloud::models::OdtSaveOptionsData::MeasureUnit > OdtSaveOptionsData::getMeasureUnit() const
    {
        return this->m_MeasureUnit;
    }

    void OdtSaveOptionsData::setMeasureUnit(std::shared_ptr< aspose::words::cloud::models::OdtSaveOptionsData::MeasureUnit > value)
    {
        this->m_MeasureUnit = value;
    }


    std::shared_ptr< std::wstring > OdtSaveOptionsData::getPassword() const
    {
        return this->m_Password;
    }

    void OdtSaveOptionsData::setPassword(std::shared_ptr< std::wstring > value)
    {
        this->m_Password = value;
    }


    std::shared_ptr< bool > OdtSaveOptionsData::getPrettyFormat() const
    {
        return this->m_PrettyFormat;
    }

    void OdtSaveOptionsData::setPrettyFormat(std::shared_ptr< bool > value)
    {
        this->m_PrettyFormat = value;
    }


    std::shared_ptr< std::wstring > OdtSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * OfficeMathLink implementation
     */
    void OfficeMathLink::toJson(void* jsonIfc) const
    {
        NodeLink::toJson(jsonIfc);
    }

    void OfficeMathLink::fromJson(const void* jsonIfc)
    {
        NodeLink::fromJson(jsonIfc);
    }

    void OfficeMathLink::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void OfficeMathLink::validate()
    {
        NodeLink::validate();
    }




    /*
     * OfficeMathObject implementation
     */
    inline std::string officeMathObjectDisplayTypeToString(aspose::words::cloud::models::OfficeMathObject::DisplayType value)
    {
        if (value == aspose::words::cloud::models::OfficeMathObject::DisplayType::DISPLAY) return "Display";
        if (value == aspose::words::cloud::models::OfficeMathObject::DisplayType::INLINE) return "Inline";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::OfficeMathObject::DisplayType officeMathObjectDisplayTypeFromString(const std::string& value)
    {
        if (value == "Display") return aspose::words::cloud::models::OfficeMathObject::DisplayType::DISPLAY;
        if (value == "Inline") return aspose::words::cloud::models::OfficeMathObject::DisplayType::INLINE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string officeMathObjectJustificationToString(aspose::words::cloud::models::OfficeMathObject::Justification value)
    {
        if (value == aspose::words::cloud::models::OfficeMathObject::Justification::CENTER_GROUP) return "CenterGroup";
        if (value == aspose::words::cloud::models::OfficeMathObject::Justification::DEFAULT) return "Default";
        if (value == aspose::words::cloud::models::OfficeMathObject::Justification::CENTER) return "Center";
        if (value == aspose::words::cloud::models::OfficeMathObject::Justification::LEFT) return "Left";
        if (value == aspose::words::cloud::models::OfficeMathObject::Justification::RIGHT) return "Right";
        if (value == aspose::words::cloud::models::OfficeMathObject::Justification::INLINE) return "Inline";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::OfficeMathObject::Justification officeMathObjectJustificationFromString(const std::string& value)
    {
        if (value == "CenterGroup") return aspose::words::cloud::models::OfficeMathObject::Justification::CENTER_GROUP;
        if (value == "Default") return aspose::words::cloud::models::OfficeMathObject::Justification::DEFAULT;
        if (value == "Center") return aspose::words::cloud::models::OfficeMathObject::Justification::CENTER;
        if (value == "Left") return aspose::words::cloud::models::OfficeMathObject::Justification::LEFT;
        if (value == "Right") return aspose::words::cloud::models::OfficeMathObject::Justification::RIGHT;
        if (value == "Inline") return aspose::words::cloud::models::OfficeMathObject::Justification::INLINE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string officeMathObjectMathObjectTypeToString(aspose::words::cloud::models::OfficeMathObject::MathObjectType value)
    {
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::O_MATH) return "OMath";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::O_MATH_PARA) return "OMathPara";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::ACCENT) return "Accent";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::BAR) return "Bar";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::BORDER_BOX) return "BorderBox";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::BOX) return "Box";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::DELIMITER) return "Delimiter";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::DEGREE) return "Degree";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::ARGUMENT) return "Argument";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::ARRAY) return "Array";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::FRACTION) return "Fraction";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::DENOMINATOR) return "Denominator";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::NUMERATOR) return "Numerator";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::FUNCTION) return "Function";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::FUNCTION_NAME) return "FunctionName";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::GROUP_CHARACTER) return "GroupCharacter";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::LIMIT) return "Limit";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::LOWER_LIMIT) return "LowerLimit";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::UPPER_LIMIT) return "UpperLimit";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::MATRIX) return "Matrix";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::MATRIX_ROW) return "MatrixRow";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::N_ARY) return "NAry";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::PHANTOM) return "Phantom";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::RADICAL) return "Radical";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::SUBSCRIPT_PART) return "SubscriptPart";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::SUPERSCRIPT_PART) return "SuperscriptPart";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::PRE_SUB_SUPERSCRIPT) return "PreSubSuperscript";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::SUBSCRIPT) return "Subscript";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::SUB_SUPERSCRIPT) return "SubSuperscript";
        if (value == aspose::words::cloud::models::OfficeMathObject::MathObjectType::SUPERCRIPT) return "Supercript";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::OfficeMathObject::MathObjectType officeMathObjectMathObjectTypeFromString(const std::string& value)
    {
        if (value == "OMath") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::O_MATH;
        if (value == "OMathPara") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::O_MATH_PARA;
        if (value == "Accent") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::ACCENT;
        if (value == "Bar") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::BAR;
        if (value == "BorderBox") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::BORDER_BOX;
        if (value == "Box") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::BOX;
        if (value == "Delimiter") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::DELIMITER;
        if (value == "Degree") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::DEGREE;
        if (value == "Argument") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::ARGUMENT;
        if (value == "Array") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::ARRAY;
        if (value == "Fraction") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::FRACTION;
        if (value == "Denominator") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::DENOMINATOR;
        if (value == "Numerator") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::NUMERATOR;
        if (value == "Function") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::FUNCTION;
        if (value == "FunctionName") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::FUNCTION_NAME;
        if (value == "GroupCharacter") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::GROUP_CHARACTER;
        if (value == "Limit") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::LIMIT;
        if (value == "LowerLimit") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::LOWER_LIMIT;
        if (value == "UpperLimit") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::UPPER_LIMIT;
        if (value == "Matrix") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::MATRIX;
        if (value == "MatrixRow") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::MATRIX_ROW;
        if (value == "NAry") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::N_ARY;
        if (value == "Phantom") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::PHANTOM;
        if (value == "Radical") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::RADICAL;
        if (value == "SubscriptPart") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::SUBSCRIPT_PART;
        if (value == "SuperscriptPart") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::SUPERSCRIPT_PART;
        if (value == "PreSubSuperscript") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::PRE_SUB_SUPERSCRIPT;
        if (value == "Subscript") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::SUBSCRIPT;
        if (value == "SubSuperscript") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::SUB_SUPERSCRIPT;
        if (value == "Supercript") return aspose::words::cloud::models::OfficeMathObject::MathObjectType::SUPERCRIPT;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void OfficeMathObject::toJson(void* jsonIfc) const
    {
        OfficeMathLink::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Content) {
            this->m_Content->toJson(&json["Content"]);
        }
        if (this->m_DisplayType) {
            json["DisplayType"] = officeMathObjectDisplayTypeToString(*(this->m_DisplayType));
        }
        if (this->m_Justification) {
            json["Justification"] = officeMathObjectJustificationToString(*(this->m_Justification));
        }
        if (this->m_MathObjectType) {
            json["MathObjectType"] = officeMathObjectMathObjectTypeToString(*(this->m_MathObjectType));
        }
    }

    void OfficeMathObject::fromJson(const void* jsonIfc)
    {
        OfficeMathLink::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Content") && !json["Content"].is_null()) {
            this->m_Content = createModelInstance< aspose::words::cloud::models::StoryChildNodes >(L"StoryChildNodes, _", json["Content"]);
        }
        if (json.contains("DisplayType") && !json["DisplayType"].is_null()) {
            this->m_DisplayType = std::make_shared< aspose::words::cloud::models::OfficeMathObject::DisplayType >(
                officeMathObjectDisplayTypeFromString(json["DisplayType"].get< std::string >())
            );
        }
        if (json.contains("Justification") && !json["Justification"].is_null()) {
            this->m_Justification = std::make_shared< aspose::words::cloud::models::OfficeMathObject::Justification >(
                officeMathObjectJustificationFromString(json["Justification"].get< std::string >())
            );
        }
        if (json.contains("MathObjectType") && !json["MathObjectType"].is_null()) {
            this->m_MathObjectType = std::make_shared< aspose::words::cloud::models::OfficeMathObject::MathObjectType >(
                officeMathObjectMathObjectTypeFromString(json["MathObjectType"].get< std::string >())
            );
        }
    }

    void OfficeMathObject::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void OfficeMathObject::validate()
    {
        OfficeMathLink::validate();

        if (this->m_Content != nullptr)
        {
            this->m_Content->validate();
        }




    }

    std::shared_ptr< aspose::words::cloud::models::StoryChildNodes > OfficeMathObject::getContent() const
    {
        return this->m_Content;
    }

    void OfficeMathObject::setContent(std::shared_ptr< aspose::words::cloud::models::StoryChildNodes > value)
    {
        this->m_Content = value;
    }


    std::shared_ptr< aspose::words::cloud::models::OfficeMathObject::DisplayType > OfficeMathObject::getDisplayType() const
    {
        return this->m_DisplayType;
    }

    void OfficeMathObject::setDisplayType(std::shared_ptr< aspose::words::cloud::models::OfficeMathObject::DisplayType > value)
    {
        this->m_DisplayType = value;
    }


    std::shared_ptr< aspose::words::cloud::models::OfficeMathObject::Justification > OfficeMathObject::getJustification() const
    {
        return this->m_Justification;
    }

    void OfficeMathObject::setJustification(std::shared_ptr< aspose::words::cloud::models::OfficeMathObject::Justification > value)
    {
        this->m_Justification = value;
    }


    std::shared_ptr< aspose::words::cloud::models::OfficeMathObject::MathObjectType > OfficeMathObject::getMathObjectType() const
    {
        return this->m_MathObjectType;
    }

    void OfficeMathObject::setMathObjectType(std::shared_ptr< aspose::words::cloud::models::OfficeMathObject::MathObjectType > value)
    {
        this->m_MathObjectType = value;
    }



    /*
     * OfficeMathObjectResponse implementation
     */
    void OfficeMathObjectResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_OfficeMathObject) {
            this->m_OfficeMathObject->toJson(&json["OfficeMathObject"]);
        }
    }

    void OfficeMathObjectResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("OfficeMathObject") && !json["OfficeMathObject"].is_null()) {
            this->m_OfficeMathObject = createModelInstance< aspose::words::cloud::models::OfficeMathObject >(L"OfficeMathObject, _", json["OfficeMathObject"]);
        }
    }

    void OfficeMathObjectResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void OfficeMathObjectResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_OfficeMathObject != nullptr)
        {
            this->m_OfficeMathObject->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::OfficeMathObject > OfficeMathObjectResponse::getOfficeMathObject() const
    {
        return this->m_OfficeMathObject;
    }

    void OfficeMathObjectResponse::setOfficeMathObject(std::shared_ptr< aspose::words::cloud::models::OfficeMathObject > value)
    {
        this->m_OfficeMathObject = value;
    }



    /*
     * OfficeMathObjectsCollection implementation
     */
    void OfficeMathObjectsCollection::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_List) {
            json["List"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_List)) {
                element->toJson(&json["List"].emplace_back());
            }
        }
    }

    void OfficeMathObjectsCollection::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("List") && !json["List"].is_null()) {
            this->m_List = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::OfficeMathObject>> >();
            for (auto& element : json["List"]) {
                this->m_List->emplace_back(createModelInstance< aspose::words::cloud::models::OfficeMathObject >(L"OfficeMathObject, _", element));
            }
        }
    }

    void OfficeMathObjectsCollection::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void OfficeMathObjectsCollection::validate()
    {
        LinkElement::validate();

        if (this->m_List != nullptr)
        {
            for (auto& elementList : *(this->m_List))
            {
                if (elementList != nullptr)
                {
                    elementList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::OfficeMathObject>> > OfficeMathObjectsCollection::getList() const
    {
        return this->m_List;
    }

    void OfficeMathObjectsCollection::setList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::OfficeMathObject>> > value)
    {
        this->m_List = value;
    }



    /*
     * OfficeMathObjectsResponse implementation
     */
    void OfficeMathObjectsResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_OfficeMathObjects) {
            this->m_OfficeMathObjects->toJson(&json["OfficeMathObjects"]);
        }
    }

    void OfficeMathObjectsResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("OfficeMathObjects") && !json["OfficeMathObjects"].is_null()) {
            this->m_OfficeMathObjects = createModelInstance< aspose::words::cloud::models::OfficeMathObjectsCollection >(L"OfficeMathObjectsCollection, _", json["OfficeMathObjects"]);
        }
    }

    void OfficeMathObjectsResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void OfficeMathObjectsResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_OfficeMathObjects != nullptr)
        {
            this->m_OfficeMathObjects->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::OfficeMathObjectsCollection > OfficeMathObjectsResponse::getOfficeMathObjects() const
    {
        return this->m_OfficeMathObjects;
    }

    void OfficeMathObjectsResponse::setOfficeMathObjects(std::shared_ptr< aspose::words::cloud::models::OfficeMathObjectsCollection > value)
    {
        this->m_OfficeMathObjects = value;
    }



    /*
     * OoxmlSaveOptionsData implementation
     */
    inline std::string ooxmlSaveOptionsDataComplianceToString(aspose::words::cloud::models::OoxmlSaveOptionsData::Compliance value)
    {
        if (value == aspose::words::cloud::models::OoxmlSaveOptionsData::Compliance::ECMA376_2006) return "Ecma376_2006";
        if (value == aspose::words::cloud::models::OoxmlSaveOptionsData::Compliance::ISO29500_2008__TRANSITIONAL) return "Iso29500_2008_Transitional";
        if (value == aspose::words::cloud::models::OoxmlSaveOptionsData::Compliance::ISO29500_2008__STRICT) return "Iso29500_2008_Strict";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::OoxmlSaveOptionsData::Compliance ooxmlSaveOptionsDataComplianceFromString(const std::string& value)
    {
        if (value == "Ecma376_2006") return aspose::words::cloud::models::OoxmlSaveOptionsData::Compliance::ECMA376_2006;
        if (value == "Iso29500_2008_Transitional") return aspose::words::cloud::models::OoxmlSaveOptionsData::Compliance::ISO29500_2008__TRANSITIONAL;
        if (value == "Iso29500_2008_Strict") return aspose::words::cloud::models::OoxmlSaveOptionsData::Compliance::ISO29500_2008__STRICT;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string ooxmlSaveOptionsDataCompressionLevelToString(aspose::words::cloud::models::OoxmlSaveOptionsData::CompressionLevel value)
    {
        if (value == aspose::words::cloud::models::OoxmlSaveOptionsData::CompressionLevel::NORMAL) return "Normal";
        if (value == aspose::words::cloud::models::OoxmlSaveOptionsData::CompressionLevel::MAXIMUM) return "Maximum";
        if (value == aspose::words::cloud::models::OoxmlSaveOptionsData::CompressionLevel::FAST) return "Fast";
        if (value == aspose::words::cloud::models::OoxmlSaveOptionsData::CompressionLevel::SUPER_FAST) return "SuperFast";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::OoxmlSaveOptionsData::CompressionLevel ooxmlSaveOptionsDataCompressionLevelFromString(const std::string& value)
    {
        if (value == "Normal") return aspose::words::cloud::models::OoxmlSaveOptionsData::CompressionLevel::NORMAL;
        if (value == "Maximum") return aspose::words::cloud::models::OoxmlSaveOptionsData::CompressionLevel::MAXIMUM;
        if (value == "Fast") return aspose::words::cloud::models::OoxmlSaveOptionsData::CompressionLevel::FAST;
        if (value == "SuperFast") return aspose::words::cloud::models::OoxmlSaveOptionsData::CompressionLevel::SUPER_FAST;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void OoxmlSaveOptionsData::toJson(void* jsonIfc) const
    {
        SaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Compliance) {
            json["Compliance"] = ooxmlSaveOptionsDataComplianceToString(*(this->m_Compliance));
        }
        if (this->m_CompressionLevel) {
            json["CompressionLevel"] = ooxmlSaveOptionsDataCompressionLevelToString(*(this->m_CompressionLevel));
        }
        if (this->m_Password) {
            json["Password"] = convertUtf16(*(this->m_Password));
        }
        if (this->m_PrettyFormat) {
            json["PrettyFormat"] = *(this->m_PrettyFormat);
        }
    }

    void OoxmlSaveOptionsData::fromJson(const void* jsonIfc)
    {
        SaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Compliance") && !json["Compliance"].is_null()) {
            this->m_Compliance = std::make_shared< aspose::words::cloud::models::OoxmlSaveOptionsData::Compliance >(
                ooxmlSaveOptionsDataComplianceFromString(json["Compliance"].get< std::string >())
            );
        }
        if (json.contains("CompressionLevel") && !json["CompressionLevel"].is_null()) {
            this->m_CompressionLevel = std::make_shared< aspose::words::cloud::models::OoxmlSaveOptionsData::CompressionLevel >(
                ooxmlSaveOptionsDataCompressionLevelFromString(json["CompressionLevel"].get< std::string >())
            );
        }
        if (json.contains("Password") && !json["Password"].is_null()) {
            this->m_Password = std::make_shared< std::wstring >(
                convertUtf8( json["Password"].get< std::string >() )
            );
        }
        if (json.contains("PrettyFormat") && !json["PrettyFormat"].is_null()) {
            this->m_PrettyFormat = std::make_shared< bool >(
                json["PrettyFormat"].get< bool >()
            );
        }
    }

    void OoxmlSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void OoxmlSaveOptionsData::validate()
    {
        SaveOptionsData::validate();
    }

    std::shared_ptr< aspose::words::cloud::models::OoxmlSaveOptionsData::Compliance > OoxmlSaveOptionsData::getCompliance() const
    {
        return this->m_Compliance;
    }

    void OoxmlSaveOptionsData::setCompliance(std::shared_ptr< aspose::words::cloud::models::OoxmlSaveOptionsData::Compliance > value)
    {
        this->m_Compliance = value;
    }


    std::shared_ptr< aspose::words::cloud::models::OoxmlSaveOptionsData::CompressionLevel > OoxmlSaveOptionsData::getCompressionLevel() const
    {
        return this->m_CompressionLevel;
    }

    void OoxmlSaveOptionsData::setCompressionLevel(std::shared_ptr< aspose::words::cloud::models::OoxmlSaveOptionsData::CompressionLevel > value)
    {
        this->m_CompressionLevel = value;
    }


    std::shared_ptr< std::wstring > OoxmlSaveOptionsData::getPassword() const
    {
        return this->m_Password;
    }

    void OoxmlSaveOptionsData::setPassword(std::shared_ptr< std::wstring > value)
    {
        this->m_Password = value;
    }


    std::shared_ptr< bool > OoxmlSaveOptionsData::getPrettyFormat() const
    {
        return this->m_PrettyFormat;
    }

    void OoxmlSaveOptionsData::setPrettyFormat(std::shared_ptr< bool > value)
    {
        this->m_PrettyFormat = value;
    }



    /*
     * OpenXpsSaveOptionsData implementation
     */
    void OpenXpsSaveOptionsData::toJson(void* jsonIfc) const
    {
        XpsSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void OpenXpsSaveOptionsData::fromJson(const void* jsonIfc)
    {
        XpsSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void OpenXpsSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void OpenXpsSaveOptionsData::validate()
    {
        XpsSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > OpenXpsSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * OptimizationOptions implementation
     */
    inline std::string optimizationOptionsMsWordVersionToString(aspose::words::cloud::models::OptimizationOptions::MsWordVersion value)
    {
        if (value == aspose::words::cloud::models::OptimizationOptions::MsWordVersion::WORD2000) return "Word2000";
        if (value == aspose::words::cloud::models::OptimizationOptions::MsWordVersion::WORD2002) return "Word2002";
        if (value == aspose::words::cloud::models::OptimizationOptions::MsWordVersion::WORD2003) return "Word2003";
        if (value == aspose::words::cloud::models::OptimizationOptions::MsWordVersion::WORD2007) return "Word2007";
        if (value == aspose::words::cloud::models::OptimizationOptions::MsWordVersion::WORD2010) return "Word2010";
        if (value == aspose::words::cloud::models::OptimizationOptions::MsWordVersion::WORD2013) return "Word2013";
        if (value == aspose::words::cloud::models::OptimizationOptions::MsWordVersion::WORD2016) return "Word2016";
        if (value == aspose::words::cloud::models::OptimizationOptions::MsWordVersion::WORD2019) return "Word2019";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::OptimizationOptions::MsWordVersion optimizationOptionsMsWordVersionFromString(const std::string& value)
    {
        if (value == "Word2000") return aspose::words::cloud::models::OptimizationOptions::MsWordVersion::WORD2000;
        if (value == "Word2002") return aspose::words::cloud::models::OptimizationOptions::MsWordVersion::WORD2002;
        if (value == "Word2003") return aspose::words::cloud::models::OptimizationOptions::MsWordVersion::WORD2003;
        if (value == "Word2007") return aspose::words::cloud::models::OptimizationOptions::MsWordVersion::WORD2007;
        if (value == "Word2010") return aspose::words::cloud::models::OptimizationOptions::MsWordVersion::WORD2010;
        if (value == "Word2013") return aspose::words::cloud::models::OptimizationOptions::MsWordVersion::WORD2013;
        if (value == "Word2016") return aspose::words::cloud::models::OptimizationOptions::MsWordVersion::WORD2016;
        if (value == "Word2019") return aspose::words::cloud::models::OptimizationOptions::MsWordVersion::WORD2019;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void OptimizationOptions::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_MsWordVersion) {
            json["MsWordVersion"] = optimizationOptionsMsWordVersionToString(*(this->m_MsWordVersion));
        }
    }

    void OptimizationOptions::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("MsWordVersion") && !json["MsWordVersion"].is_null()) {
            this->m_MsWordVersion = std::make_shared< aspose::words::cloud::models::OptimizationOptions::MsWordVersion >(
                optimizationOptionsMsWordVersionFromString(json["MsWordVersion"].get< std::string >())
            );
        }
    }

    void OptimizationOptions::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void OptimizationOptions::validate()
    {
        if (this->m_MsWordVersion == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property MsWordVersion in OptimizationOptions is required.");
        }

    }

    std::shared_ptr< aspose::words::cloud::models::OptimizationOptions::MsWordVersion > OptimizationOptions::getMsWordVersion() const
    {
        return this->m_MsWordVersion;
    }

    void OptimizationOptions::setMsWordVersion(std::shared_ptr< aspose::words::cloud::models::OptimizationOptions::MsWordVersion > value)
    {
        this->m_MsWordVersion = value;
    }



    /*
     * OttSaveOptionsData implementation
     */
    void OttSaveOptionsData::toJson(void* jsonIfc) const
    {
        OdtSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void OttSaveOptionsData::fromJson(const void* jsonIfc)
    {
        OdtSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void OttSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void OttSaveOptionsData::validate()
    {
        OdtSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > OttSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * OutlineOptionsData implementation
     */
    void OutlineOptionsData::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_CreateMissingOutlineLevels) {
            json["CreateMissingOutlineLevels"] = *(this->m_CreateMissingOutlineLevels);
        }
        if (this->m_CreateOutlinesForHeadingsInTables) {
            json["CreateOutlinesForHeadingsInTables"] = *(this->m_CreateOutlinesForHeadingsInTables);
        }
        if (this->m_DefaultBookmarksOutlineLevel) {
            json["DefaultBookmarksOutlineLevel"] = *(this->m_DefaultBookmarksOutlineLevel);
        }
        if (this->m_ExpandedOutlineLevels) {
            json["ExpandedOutlineLevels"] = *(this->m_ExpandedOutlineLevels);
        }
        if (this->m_HeadingsOutlineLevels) {
            json["HeadingsOutlineLevels"] = *(this->m_HeadingsOutlineLevels);
        }
        if (this->m_BookmarksOutlineLevels) {
            json["BookmarksOutlineLevels"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_BookmarksOutlineLevels)) {
                element->toJson(&json["BookmarksOutlineLevels"].emplace_back());
            }
        }
    }

    void OutlineOptionsData::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("CreateMissingOutlineLevels") && !json["CreateMissingOutlineLevels"].is_null()) {
            this->m_CreateMissingOutlineLevels = std::make_shared< bool >(
                json["CreateMissingOutlineLevels"].get< bool >()
            );
        }
        if (json.contains("CreateOutlinesForHeadingsInTables") && !json["CreateOutlinesForHeadingsInTables"].is_null()) {
            this->m_CreateOutlinesForHeadingsInTables = std::make_shared< bool >(
                json["CreateOutlinesForHeadingsInTables"].get< bool >()
            );
        }
        if (json.contains("DefaultBookmarksOutlineLevel") && !json["DefaultBookmarksOutlineLevel"].is_null()) {
            this->m_DefaultBookmarksOutlineLevel = std::make_shared< int32_t >(
                json["DefaultBookmarksOutlineLevel"].get< int32_t >()
            );
        }
        if (json.contains("ExpandedOutlineLevels") && !json["ExpandedOutlineLevels"].is_null()) {
            this->m_ExpandedOutlineLevels = std::make_shared< int32_t >(
                json["ExpandedOutlineLevels"].get< int32_t >()
            );
        }
        if (json.contains("HeadingsOutlineLevels") && !json["HeadingsOutlineLevels"].is_null()) {
            this->m_HeadingsOutlineLevels = std::make_shared< int32_t >(
                json["HeadingsOutlineLevels"].get< int32_t >()
            );
        }
        if (json.contains("BookmarksOutlineLevels") && !json["BookmarksOutlineLevels"].is_null()) {
            this->m_BookmarksOutlineLevels = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::BookmarksOutlineLevelData>> >();
            for (auto& element : json["BookmarksOutlineLevels"]) {
                this->m_BookmarksOutlineLevels->emplace_back(createModelInstance< aspose::words::cloud::models::BookmarksOutlineLevelData >(L"BookmarksOutlineLevelData, _", element));
            }
        }
    }

    void OutlineOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void OutlineOptionsData::validate()
    {

        if (this->m_BookmarksOutlineLevels != nullptr)
        {
            for (auto& elementBookmarksOutlineLevels : *(this->m_BookmarksOutlineLevels))
            {
                if (elementBookmarksOutlineLevels != nullptr)
                {
                    elementBookmarksOutlineLevels->validate();
                }
            }
        }

    }

    std::shared_ptr< bool > OutlineOptionsData::getCreateMissingOutlineLevels() const
    {
        return this->m_CreateMissingOutlineLevels;
    }

    void OutlineOptionsData::setCreateMissingOutlineLevels(std::shared_ptr< bool > value)
    {
        this->m_CreateMissingOutlineLevels = value;
    }


    std::shared_ptr< bool > OutlineOptionsData::getCreateOutlinesForHeadingsInTables() const
    {
        return this->m_CreateOutlinesForHeadingsInTables;
    }

    void OutlineOptionsData::setCreateOutlinesForHeadingsInTables(std::shared_ptr< bool > value)
    {
        this->m_CreateOutlinesForHeadingsInTables = value;
    }


    std::shared_ptr< int32_t > OutlineOptionsData::getDefaultBookmarksOutlineLevel() const
    {
        return this->m_DefaultBookmarksOutlineLevel;
    }

    void OutlineOptionsData::setDefaultBookmarksOutlineLevel(std::shared_ptr< int32_t > value)
    {
        this->m_DefaultBookmarksOutlineLevel = value;
    }


    std::shared_ptr< int32_t > OutlineOptionsData::getExpandedOutlineLevels() const
    {
        return this->m_ExpandedOutlineLevels;
    }

    void OutlineOptionsData::setExpandedOutlineLevels(std::shared_ptr< int32_t > value)
    {
        this->m_ExpandedOutlineLevels = value;
    }


    std::shared_ptr< int32_t > OutlineOptionsData::getHeadingsOutlineLevels() const
    {
        return this->m_HeadingsOutlineLevels;
    }

    void OutlineOptionsData::setHeadingsOutlineLevels(std::shared_ptr< int32_t > value)
    {
        this->m_HeadingsOutlineLevels = value;
    }


    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::BookmarksOutlineLevelData>> > OutlineOptionsData::getBookmarksOutlineLevels() const
    {
        return this->m_BookmarksOutlineLevels;
    }

    void OutlineOptionsData::setBookmarksOutlineLevels(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::BookmarksOutlineLevelData>> > value)
    {
        this->m_BookmarksOutlineLevels = value;
    }



    /*
     * PageNumber implementation
     */
    void PageNumber::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Alignment) {
            json["Alignment"] = convertUtf16(*(this->m_Alignment));
        }
        if (this->m_Format) {
            json["Format"] = convertUtf16(*(this->m_Format));
        }
        if (this->m_IsTop) {
            json["IsTop"] = *(this->m_IsTop);
        }
        if (this->m_PageStartingNumber) {
            json["PageStartingNumber"] = *(this->m_PageStartingNumber);
        }
        if (this->m_SetPageNumberOnFirstPage) {
            json["SetPageNumberOnFirstPage"] = *(this->m_SetPageNumberOnFirstPage);
        }
    }

    void PageNumber::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Alignment") && !json["Alignment"].is_null()) {
            this->m_Alignment = std::make_shared< std::wstring >(
                convertUtf8( json["Alignment"].get< std::string >() )
            );
        }
        if (json.contains("Format") && !json["Format"].is_null()) {
            this->m_Format = std::make_shared< std::wstring >(
                convertUtf8( json["Format"].get< std::string >() )
            );
        }
        if (json.contains("IsTop") && !json["IsTop"].is_null()) {
            this->m_IsTop = std::make_shared< bool >(
                json["IsTop"].get< bool >()
            );
        }
        if (json.contains("PageStartingNumber") && !json["PageStartingNumber"].is_null()) {
            this->m_PageStartingNumber = std::make_shared< int32_t >(
                json["PageStartingNumber"].get< int32_t >()
            );
        }
        if (json.contains("SetPageNumberOnFirstPage") && !json["SetPageNumberOnFirstPage"].is_null()) {
            this->m_SetPageNumberOnFirstPage = std::make_shared< bool >(
                json["SetPageNumberOnFirstPage"].get< bool >()
            );
        }
    }

    void PageNumber::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void PageNumber::validate()
    {
        if (this->m_IsTop == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property IsTop in PageNumber is required.");
        }

        if (this->m_SetPageNumberOnFirstPage == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property SetPageNumberOnFirstPage in PageNumber is required.");
        }

    }

    std::shared_ptr< std::wstring > PageNumber::getAlignment() const
    {
        return this->m_Alignment;
    }

    void PageNumber::setAlignment(std::shared_ptr< std::wstring > value)
    {
        this->m_Alignment = value;
    }


    std::shared_ptr< std::wstring > PageNumber::getFormat() const
    {
        return this->m_Format;
    }

    void PageNumber::setFormat(std::shared_ptr< std::wstring > value)
    {
        this->m_Format = value;
    }


    std::shared_ptr< bool > PageNumber::getIsTop() const
    {
        return this->m_IsTop;
    }

    void PageNumber::setIsTop(std::shared_ptr< bool > value)
    {
        this->m_IsTop = value;
    }


    std::shared_ptr< int32_t > PageNumber::getPageStartingNumber() const
    {
        return this->m_PageStartingNumber;
    }

    void PageNumber::setPageStartingNumber(std::shared_ptr< int32_t > value)
    {
        this->m_PageStartingNumber = value;
    }


    std::shared_ptr< bool > PageNumber::getSetPageNumberOnFirstPage() const
    {
        return this->m_SetPageNumberOnFirstPage;
    }

    void PageNumber::setSetPageNumberOnFirstPage(std::shared_ptr< bool > value)
    {
        this->m_SetPageNumberOnFirstPage = value;
    }



    /*
     * PageSetup implementation
     */
    inline std::string pageSetupBorderAppliesToToString(aspose::words::cloud::models::PageSetup::BorderAppliesTo value)
    {
        if (value == aspose::words::cloud::models::PageSetup::BorderAppliesTo::ALL_PAGES) return "AllPages";
        if (value == aspose::words::cloud::models::PageSetup::BorderAppliesTo::FIRST_PAGE) return "FirstPage";
        if (value == aspose::words::cloud::models::PageSetup::BorderAppliesTo::OTHER_PAGES) return "OtherPages";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PageSetup::BorderAppliesTo pageSetupBorderAppliesToFromString(const std::string& value)
    {
        if (value == "AllPages") return aspose::words::cloud::models::PageSetup::BorderAppliesTo::ALL_PAGES;
        if (value == "FirstPage") return aspose::words::cloud::models::PageSetup::BorderAppliesTo::FIRST_PAGE;
        if (value == "OtherPages") return aspose::words::cloud::models::PageSetup::BorderAppliesTo::OTHER_PAGES;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string pageSetupBorderDistanceFromToString(aspose::words::cloud::models::PageSetup::BorderDistanceFrom value)
    {
        if (value == aspose::words::cloud::models::PageSetup::BorderDistanceFrom::TEXT) return "Text";
        if (value == aspose::words::cloud::models::PageSetup::BorderDistanceFrom::PAGE_EDGE) return "PageEdge";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PageSetup::BorderDistanceFrom pageSetupBorderDistanceFromFromString(const std::string& value)
    {
        if (value == "Text") return aspose::words::cloud::models::PageSetup::BorderDistanceFrom::TEXT;
        if (value == "PageEdge") return aspose::words::cloud::models::PageSetup::BorderDistanceFrom::PAGE_EDGE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string pageSetupLineNumberRestartModeToString(aspose::words::cloud::models::PageSetup::LineNumberRestartMode value)
    {
        if (value == aspose::words::cloud::models::PageSetup::LineNumberRestartMode::RESTART_PAGE) return "RestartPage";
        if (value == aspose::words::cloud::models::PageSetup::LineNumberRestartMode::RESTART_SECTION) return "RestartSection";
        if (value == aspose::words::cloud::models::PageSetup::LineNumberRestartMode::CONTINUOUS) return "Continuous";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PageSetup::LineNumberRestartMode pageSetupLineNumberRestartModeFromString(const std::string& value)
    {
        if (value == "RestartPage") return aspose::words::cloud::models::PageSetup::LineNumberRestartMode::RESTART_PAGE;
        if (value == "RestartSection") return aspose::words::cloud::models::PageSetup::LineNumberRestartMode::RESTART_SECTION;
        if (value == "Continuous") return aspose::words::cloud::models::PageSetup::LineNumberRestartMode::CONTINUOUS;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string pageSetupOrientationToString(aspose::words::cloud::models::PageSetup::Orientation value)
    {
        if (value == aspose::words::cloud::models::PageSetup::Orientation::PORTRAIT) return "Portrait";
        if (value == aspose::words::cloud::models::PageSetup::Orientation::LANDSCAPE) return "Landscape";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PageSetup::Orientation pageSetupOrientationFromString(const std::string& value)
    {
        if (value == "Portrait") return aspose::words::cloud::models::PageSetup::Orientation::PORTRAIT;
        if (value == "Landscape") return aspose::words::cloud::models::PageSetup::Orientation::LANDSCAPE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string pageSetupPageNumberStyleToString(aspose::words::cloud::models::PageSetup::PageNumberStyle value)
    {
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::ARABIC) return "Arabic";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::UPPERCASE_ROMAN) return "UppercaseRoman";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::LOWERCASE_ROMAN) return "LowercaseRoman";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::UPPERCASE_LETTER) return "UppercaseLetter";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::LOWERCASE_LETTER) return "LowercaseLetter";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::ORDINAL) return "Ordinal";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::NUMBER) return "Number";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::ORDINAL_TEXT) return "OrdinalText";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::HEX) return "Hex";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::CHICAGO_MANUAL) return "ChicagoManual";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::KANJI) return "Kanji";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::KANJI_DIGIT) return "KanjiDigit";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::AIUEO_HALF_WIDTH) return "AiueoHalfWidth";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::IROHA_HALF_WIDTH) return "IrohaHalfWidth";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::ARABIC_FULL_WIDTH) return "ArabicFullWidth";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::ARABIC_HALF_WIDTH) return "ArabicHalfWidth";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::KANJI_TRADITIONAL) return "KanjiTraditional";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::KANJI_TRADITIONAL2) return "KanjiTraditional2";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::NUMBER_IN_CIRCLE) return "NumberInCircle";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::DECIMAL_FULL_WIDTH) return "DecimalFullWidth";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::AIUEO) return "Aiueo";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::IROHA) return "Iroha";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::LEADING_ZERO) return "LeadingZero";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::BULLET) return "Bullet";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::GANADA) return "Ganada";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::CHOSUNG) return "Chosung";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::G_B1) return "GB1";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::G_B2) return "GB2";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::G_B3) return "GB3";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::G_B4) return "GB4";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::ZODIAC1) return "Zodiac1";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::ZODIAC2) return "Zodiac2";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::ZODIAC3) return "Zodiac3";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::TRAD_CHIN_NUM1) return "TradChinNum1";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::TRAD_CHIN_NUM2) return "TradChinNum2";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::TRAD_CHIN_NUM3) return "TradChinNum3";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::TRAD_CHIN_NUM4) return "TradChinNum4";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::SIMP_CHIN_NUM1) return "SimpChinNum1";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::SIMP_CHIN_NUM2) return "SimpChinNum2";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::SIMP_CHIN_NUM3) return "SimpChinNum3";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::SIMP_CHIN_NUM4) return "SimpChinNum4";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::HANJA_READ) return "HanjaRead";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::HANJA_READ_DIGIT) return "HanjaReadDigit";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::HANGUL) return "Hangul";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::HANJA) return "Hanja";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::HEBREW1) return "Hebrew1";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::ARABIC1) return "Arabic1";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::HEBREW2) return "Hebrew2";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::ARABIC2) return "Arabic2";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::HINDI_LETTER1) return "HindiLetter1";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::HINDI_LETTER2) return "HindiLetter2";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::HINDI_ARABIC) return "HindiArabic";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::HINDI_CARDINAL_TEXT) return "HindiCardinalText";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::THAI_LETTER) return "ThaiLetter";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::THAI_ARABIC) return "ThaiArabic";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::THAI_CARDINAL_TEXT) return "ThaiCardinalText";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::VIET_CARDINAL_TEXT) return "VietCardinalText";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::NUMBER_IN_DASH) return "NumberInDash";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::LOWERCASE_RUSSIAN) return "LowercaseRussian";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::UPPERCASE_RUSSIAN) return "UppercaseRussian";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::NONE) return "None";
        if (value == aspose::words::cloud::models::PageSetup::PageNumberStyle::CUSTOM) return "Custom";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PageSetup::PageNumberStyle pageSetupPageNumberStyleFromString(const std::string& value)
    {
        if (value == "Arabic") return aspose::words::cloud::models::PageSetup::PageNumberStyle::ARABIC;
        if (value == "UppercaseRoman") return aspose::words::cloud::models::PageSetup::PageNumberStyle::UPPERCASE_ROMAN;
        if (value == "LowercaseRoman") return aspose::words::cloud::models::PageSetup::PageNumberStyle::LOWERCASE_ROMAN;
        if (value == "UppercaseLetter") return aspose::words::cloud::models::PageSetup::PageNumberStyle::UPPERCASE_LETTER;
        if (value == "LowercaseLetter") return aspose::words::cloud::models::PageSetup::PageNumberStyle::LOWERCASE_LETTER;
        if (value == "Ordinal") return aspose::words::cloud::models::PageSetup::PageNumberStyle::ORDINAL;
        if (value == "Number") return aspose::words::cloud::models::PageSetup::PageNumberStyle::NUMBER;
        if (value == "OrdinalText") return aspose::words::cloud::models::PageSetup::PageNumberStyle::ORDINAL_TEXT;
        if (value == "Hex") return aspose::words::cloud::models::PageSetup::PageNumberStyle::HEX;
        if (value == "ChicagoManual") return aspose::words::cloud::models::PageSetup::PageNumberStyle::CHICAGO_MANUAL;
        if (value == "Kanji") return aspose::words::cloud::models::PageSetup::PageNumberStyle::KANJI;
        if (value == "KanjiDigit") return aspose::words::cloud::models::PageSetup::PageNumberStyle::KANJI_DIGIT;
        if (value == "AiueoHalfWidth") return aspose::words::cloud::models::PageSetup::PageNumberStyle::AIUEO_HALF_WIDTH;
        if (value == "IrohaHalfWidth") return aspose::words::cloud::models::PageSetup::PageNumberStyle::IROHA_HALF_WIDTH;
        if (value == "ArabicFullWidth") return aspose::words::cloud::models::PageSetup::PageNumberStyle::ARABIC_FULL_WIDTH;
        if (value == "ArabicHalfWidth") return aspose::words::cloud::models::PageSetup::PageNumberStyle::ARABIC_HALF_WIDTH;
        if (value == "KanjiTraditional") return aspose::words::cloud::models::PageSetup::PageNumberStyle::KANJI_TRADITIONAL;
        if (value == "KanjiTraditional2") return aspose::words::cloud::models::PageSetup::PageNumberStyle::KANJI_TRADITIONAL2;
        if (value == "NumberInCircle") return aspose::words::cloud::models::PageSetup::PageNumberStyle::NUMBER_IN_CIRCLE;
        if (value == "DecimalFullWidth") return aspose::words::cloud::models::PageSetup::PageNumberStyle::DECIMAL_FULL_WIDTH;
        if (value == "Aiueo") return aspose::words::cloud::models::PageSetup::PageNumberStyle::AIUEO;
        if (value == "Iroha") return aspose::words::cloud::models::PageSetup::PageNumberStyle::IROHA;
        if (value == "LeadingZero") return aspose::words::cloud::models::PageSetup::PageNumberStyle::LEADING_ZERO;
        if (value == "Bullet") return aspose::words::cloud::models::PageSetup::PageNumberStyle::BULLET;
        if (value == "Ganada") return aspose::words::cloud::models::PageSetup::PageNumberStyle::GANADA;
        if (value == "Chosung") return aspose::words::cloud::models::PageSetup::PageNumberStyle::CHOSUNG;
        if (value == "GB1") return aspose::words::cloud::models::PageSetup::PageNumberStyle::G_B1;
        if (value == "GB2") return aspose::words::cloud::models::PageSetup::PageNumberStyle::G_B2;
        if (value == "GB3") return aspose::words::cloud::models::PageSetup::PageNumberStyle::G_B3;
        if (value == "GB4") return aspose::words::cloud::models::PageSetup::PageNumberStyle::G_B4;
        if (value == "Zodiac1") return aspose::words::cloud::models::PageSetup::PageNumberStyle::ZODIAC1;
        if (value == "Zodiac2") return aspose::words::cloud::models::PageSetup::PageNumberStyle::ZODIAC2;
        if (value == "Zodiac3") return aspose::words::cloud::models::PageSetup::PageNumberStyle::ZODIAC3;
        if (value == "TradChinNum1") return aspose::words::cloud::models::PageSetup::PageNumberStyle::TRAD_CHIN_NUM1;
        if (value == "TradChinNum2") return aspose::words::cloud::models::PageSetup::PageNumberStyle::TRAD_CHIN_NUM2;
        if (value == "TradChinNum3") return aspose::words::cloud::models::PageSetup::PageNumberStyle::TRAD_CHIN_NUM3;
        if (value == "TradChinNum4") return aspose::words::cloud::models::PageSetup::PageNumberStyle::TRAD_CHIN_NUM4;
        if (value == "SimpChinNum1") return aspose::words::cloud::models::PageSetup::PageNumberStyle::SIMP_CHIN_NUM1;
        if (value == "SimpChinNum2") return aspose::words::cloud::models::PageSetup::PageNumberStyle::SIMP_CHIN_NUM2;
        if (value == "SimpChinNum3") return aspose::words::cloud::models::PageSetup::PageNumberStyle::SIMP_CHIN_NUM3;
        if (value == "SimpChinNum4") return aspose::words::cloud::models::PageSetup::PageNumberStyle::SIMP_CHIN_NUM4;
        if (value == "HanjaRead") return aspose::words::cloud::models::PageSetup::PageNumberStyle::HANJA_READ;
        if (value == "HanjaReadDigit") return aspose::words::cloud::models::PageSetup::PageNumberStyle::HANJA_READ_DIGIT;
        if (value == "Hangul") return aspose::words::cloud::models::PageSetup::PageNumberStyle::HANGUL;
        if (value == "Hanja") return aspose::words::cloud::models::PageSetup::PageNumberStyle::HANJA;
        if (value == "Hebrew1") return aspose::words::cloud::models::PageSetup::PageNumberStyle::HEBREW1;
        if (value == "Arabic1") return aspose::words::cloud::models::PageSetup::PageNumberStyle::ARABIC1;
        if (value == "Hebrew2") return aspose::words::cloud::models::PageSetup::PageNumberStyle::HEBREW2;
        if (value == "Arabic2") return aspose::words::cloud::models::PageSetup::PageNumberStyle::ARABIC2;
        if (value == "HindiLetter1") return aspose::words::cloud::models::PageSetup::PageNumberStyle::HINDI_LETTER1;
        if (value == "HindiLetter2") return aspose::words::cloud::models::PageSetup::PageNumberStyle::HINDI_LETTER2;
        if (value == "HindiArabic") return aspose::words::cloud::models::PageSetup::PageNumberStyle::HINDI_ARABIC;
        if (value == "HindiCardinalText") return aspose::words::cloud::models::PageSetup::PageNumberStyle::HINDI_CARDINAL_TEXT;
        if (value == "ThaiLetter") return aspose::words::cloud::models::PageSetup::PageNumberStyle::THAI_LETTER;
        if (value == "ThaiArabic") return aspose::words::cloud::models::PageSetup::PageNumberStyle::THAI_ARABIC;
        if (value == "ThaiCardinalText") return aspose::words::cloud::models::PageSetup::PageNumberStyle::THAI_CARDINAL_TEXT;
        if (value == "VietCardinalText") return aspose::words::cloud::models::PageSetup::PageNumberStyle::VIET_CARDINAL_TEXT;
        if (value == "NumberInDash") return aspose::words::cloud::models::PageSetup::PageNumberStyle::NUMBER_IN_DASH;
        if (value == "LowercaseRussian") return aspose::words::cloud::models::PageSetup::PageNumberStyle::LOWERCASE_RUSSIAN;
        if (value == "UppercaseRussian") return aspose::words::cloud::models::PageSetup::PageNumberStyle::UPPERCASE_RUSSIAN;
        if (value == "None") return aspose::words::cloud::models::PageSetup::PageNumberStyle::NONE;
        if (value == "Custom") return aspose::words::cloud::models::PageSetup::PageNumberStyle::CUSTOM;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string pageSetupPaperSizeToString(aspose::words::cloud::models::PageSetup::PaperSize value)
    {
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::A3) return "A3";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::A4) return "A4";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::A5) return "A5";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::B4) return "B4";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::B5) return "B5";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::EXECUTIVE) return "Executive";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::FOLIO) return "Folio";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::LEDGER) return "Ledger";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::LEGAL) return "Legal";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::LETTER) return "Letter";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::ENVELOPE_DL) return "EnvelopeDL";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::QUARTO) return "Quarto";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::STATEMENT) return "Statement";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::TABLOID) return "Tabloid";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::PAPER10X14) return "Paper10x14";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::PAPER11X17) return "Paper11x17";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::NUMBER10_ENVELOPE) return "Number10Envelope";
        if (value == aspose::words::cloud::models::PageSetup::PaperSize::CUSTOM) return "Custom";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PageSetup::PaperSize pageSetupPaperSizeFromString(const std::string& value)
    {
        if (value == "A3") return aspose::words::cloud::models::PageSetup::PaperSize::A3;
        if (value == "A4") return aspose::words::cloud::models::PageSetup::PaperSize::A4;
        if (value == "A5") return aspose::words::cloud::models::PageSetup::PaperSize::A5;
        if (value == "B4") return aspose::words::cloud::models::PageSetup::PaperSize::B4;
        if (value == "B5") return aspose::words::cloud::models::PageSetup::PaperSize::B5;
        if (value == "Executive") return aspose::words::cloud::models::PageSetup::PaperSize::EXECUTIVE;
        if (value == "Folio") return aspose::words::cloud::models::PageSetup::PaperSize::FOLIO;
        if (value == "Ledger") return aspose::words::cloud::models::PageSetup::PaperSize::LEDGER;
        if (value == "Legal") return aspose::words::cloud::models::PageSetup::PaperSize::LEGAL;
        if (value == "Letter") return aspose::words::cloud::models::PageSetup::PaperSize::LETTER;
        if (value == "EnvelopeDL") return aspose::words::cloud::models::PageSetup::PaperSize::ENVELOPE_DL;
        if (value == "Quarto") return aspose::words::cloud::models::PageSetup::PaperSize::QUARTO;
        if (value == "Statement") return aspose::words::cloud::models::PageSetup::PaperSize::STATEMENT;
        if (value == "Tabloid") return aspose::words::cloud::models::PageSetup::PaperSize::TABLOID;
        if (value == "Paper10x14") return aspose::words::cloud::models::PageSetup::PaperSize::PAPER10X14;
        if (value == "Paper11x17") return aspose::words::cloud::models::PageSetup::PaperSize::PAPER11X17;
        if (value == "Number10Envelope") return aspose::words::cloud::models::PageSetup::PaperSize::NUMBER10_ENVELOPE;
        if (value == "Custom") return aspose::words::cloud::models::PageSetup::PaperSize::CUSTOM;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string pageSetupSectionStartToString(aspose::words::cloud::models::PageSetup::SectionStart value)
    {
        if (value == aspose::words::cloud::models::PageSetup::SectionStart::CONTINUOUS) return "Continuous";
        if (value == aspose::words::cloud::models::PageSetup::SectionStart::NEW_COLUMN) return "NewColumn";
        if (value == aspose::words::cloud::models::PageSetup::SectionStart::NEW_PAGE) return "NewPage";
        if (value == aspose::words::cloud::models::PageSetup::SectionStart::EVEN_PAGE) return "EvenPage";
        if (value == aspose::words::cloud::models::PageSetup::SectionStart::ODD_PAGE) return "OddPage";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PageSetup::SectionStart pageSetupSectionStartFromString(const std::string& value)
    {
        if (value == "Continuous") return aspose::words::cloud::models::PageSetup::SectionStart::CONTINUOUS;
        if (value == "NewColumn") return aspose::words::cloud::models::PageSetup::SectionStart::NEW_COLUMN;
        if (value == "NewPage") return aspose::words::cloud::models::PageSetup::SectionStart::NEW_PAGE;
        if (value == "EvenPage") return aspose::words::cloud::models::PageSetup::SectionStart::EVEN_PAGE;
        if (value == "OddPage") return aspose::words::cloud::models::PageSetup::SectionStart::ODD_PAGE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string pageSetupVerticalAlignmentToString(aspose::words::cloud::models::PageSetup::VerticalAlignment value)
    {
        if (value == aspose::words::cloud::models::PageSetup::VerticalAlignment::TOP) return "Top";
        if (value == aspose::words::cloud::models::PageSetup::VerticalAlignment::CENTER) return "Center";
        if (value == aspose::words::cloud::models::PageSetup::VerticalAlignment::JUSTIFY) return "Justify";
        if (value == aspose::words::cloud::models::PageSetup::VerticalAlignment::BOTTOM) return "Bottom";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PageSetup::VerticalAlignment pageSetupVerticalAlignmentFromString(const std::string& value)
    {
        if (value == "Top") return aspose::words::cloud::models::PageSetup::VerticalAlignment::TOP;
        if (value == "Center") return aspose::words::cloud::models::PageSetup::VerticalAlignment::CENTER;
        if (value == "Justify") return aspose::words::cloud::models::PageSetup::VerticalAlignment::JUSTIFY;
        if (value == "Bottom") return aspose::words::cloud::models::PageSetup::VerticalAlignment::BOTTOM;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void PageSetup::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Bidi) {
            json["Bidi"] = *(this->m_Bidi);
        }
        if (this->m_BorderAlwaysInFront) {
            json["BorderAlwaysInFront"] = *(this->m_BorderAlwaysInFront);
        }
        if (this->m_BorderAppliesTo) {
            json["BorderAppliesTo"] = pageSetupBorderAppliesToToString(*(this->m_BorderAppliesTo));
        }
        if (this->m_BorderDistanceFrom) {
            json["BorderDistanceFrom"] = pageSetupBorderDistanceFromToString(*(this->m_BorderDistanceFrom));
        }
        if (this->m_BottomMargin) {
            json["BottomMargin"] = *(this->m_BottomMargin);
        }
        if (this->m_DifferentFirstPageHeaderFooter) {
            json["DifferentFirstPageHeaderFooter"] = *(this->m_DifferentFirstPageHeaderFooter);
        }
        if (this->m_FirstPageTray) {
            json["FirstPageTray"] = *(this->m_FirstPageTray);
        }
        if (this->m_FooterDistance) {
            json["FooterDistance"] = *(this->m_FooterDistance);
        }
        if (this->m_Gutter) {
            json["Gutter"] = *(this->m_Gutter);
        }
        if (this->m_HeaderDistance) {
            json["HeaderDistance"] = *(this->m_HeaderDistance);
        }
        if (this->m_LeftMargin) {
            json["LeftMargin"] = *(this->m_LeftMargin);
        }
        if (this->m_LineNumberCountBy) {
            json["LineNumberCountBy"] = *(this->m_LineNumberCountBy);
        }
        if (this->m_LineNumberDistanceFromText) {
            json["LineNumberDistanceFromText"] = *(this->m_LineNumberDistanceFromText);
        }
        if (this->m_LineNumberRestartMode) {
            json["LineNumberRestartMode"] = pageSetupLineNumberRestartModeToString(*(this->m_LineNumberRestartMode));
        }
        if (this->m_LineStartingNumber) {
            json["LineStartingNumber"] = *(this->m_LineStartingNumber);
        }
        if (this->m_Orientation) {
            json["Orientation"] = pageSetupOrientationToString(*(this->m_Orientation));
        }
        if (this->m_OtherPagesTray) {
            json["OtherPagesTray"] = *(this->m_OtherPagesTray);
        }
        if (this->m_PageHeight) {
            json["PageHeight"] = *(this->m_PageHeight);
        }
        if (this->m_PageNumberStyle) {
            json["PageNumberStyle"] = pageSetupPageNumberStyleToString(*(this->m_PageNumberStyle));
        }
        if (this->m_PageStartingNumber) {
            json["PageStartingNumber"] = *(this->m_PageStartingNumber);
        }
        if (this->m_PageWidth) {
            json["PageWidth"] = *(this->m_PageWidth);
        }
        if (this->m_PaperSize) {
            json["PaperSize"] = pageSetupPaperSizeToString(*(this->m_PaperSize));
        }
        if (this->m_RestartPageNumbering) {
            json["RestartPageNumbering"] = *(this->m_RestartPageNumbering);
        }
        if (this->m_RightMargin) {
            json["RightMargin"] = *(this->m_RightMargin);
        }
        if (this->m_RtlGutter) {
            json["RtlGutter"] = *(this->m_RtlGutter);
        }
        if (this->m_SectionStart) {
            json["SectionStart"] = pageSetupSectionStartToString(*(this->m_SectionStart));
        }
        if (this->m_SuppressEndnotes) {
            json["SuppressEndnotes"] = *(this->m_SuppressEndnotes);
        }
        if (this->m_TopMargin) {
            json["TopMargin"] = *(this->m_TopMargin);
        }
        if (this->m_VerticalAlignment) {
            json["VerticalAlignment"] = pageSetupVerticalAlignmentToString(*(this->m_VerticalAlignment));
        }
    }

    void PageSetup::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Bidi") && !json["Bidi"].is_null()) {
            this->m_Bidi = std::make_shared< bool >(
                json["Bidi"].get< bool >()
            );
        }
        if (json.contains("BorderAlwaysInFront") && !json["BorderAlwaysInFront"].is_null()) {
            this->m_BorderAlwaysInFront = std::make_shared< bool >(
                json["BorderAlwaysInFront"].get< bool >()
            );
        }
        if (json.contains("BorderAppliesTo") && !json["BorderAppliesTo"].is_null()) {
            this->m_BorderAppliesTo = std::make_shared< aspose::words::cloud::models::PageSetup::BorderAppliesTo >(
                pageSetupBorderAppliesToFromString(json["BorderAppliesTo"].get< std::string >())
            );
        }
        if (json.contains("BorderDistanceFrom") && !json["BorderDistanceFrom"].is_null()) {
            this->m_BorderDistanceFrom = std::make_shared< aspose::words::cloud::models::PageSetup::BorderDistanceFrom >(
                pageSetupBorderDistanceFromFromString(json["BorderDistanceFrom"].get< std::string >())
            );
        }
        if (json.contains("BottomMargin") && !json["BottomMargin"].is_null()) {
            this->m_BottomMargin = std::make_shared< double >(
                json["BottomMargin"].get< double >()
            );
        }
        if (json.contains("DifferentFirstPageHeaderFooter") && !json["DifferentFirstPageHeaderFooter"].is_null()) {
            this->m_DifferentFirstPageHeaderFooter = std::make_shared< bool >(
                json["DifferentFirstPageHeaderFooter"].get< bool >()
            );
        }
        if (json.contains("FirstPageTray") && !json["FirstPageTray"].is_null()) {
            this->m_FirstPageTray = std::make_shared< int32_t >(
                json["FirstPageTray"].get< int32_t >()
            );
        }
        if (json.contains("FooterDistance") && !json["FooterDistance"].is_null()) {
            this->m_FooterDistance = std::make_shared< double >(
                json["FooterDistance"].get< double >()
            );
        }
        if (json.contains("Gutter") && !json["Gutter"].is_null()) {
            this->m_Gutter = std::make_shared< double >(
                json["Gutter"].get< double >()
            );
        }
        if (json.contains("HeaderDistance") && !json["HeaderDistance"].is_null()) {
            this->m_HeaderDistance = std::make_shared< double >(
                json["HeaderDistance"].get< double >()
            );
        }
        if (json.contains("LeftMargin") && !json["LeftMargin"].is_null()) {
            this->m_LeftMargin = std::make_shared< double >(
                json["LeftMargin"].get< double >()
            );
        }
        if (json.contains("LineNumberCountBy") && !json["LineNumberCountBy"].is_null()) {
            this->m_LineNumberCountBy = std::make_shared< int32_t >(
                json["LineNumberCountBy"].get< int32_t >()
            );
        }
        if (json.contains("LineNumberDistanceFromText") && !json["LineNumberDistanceFromText"].is_null()) {
            this->m_LineNumberDistanceFromText = std::make_shared< double >(
                json["LineNumberDistanceFromText"].get< double >()
            );
        }
        if (json.contains("LineNumberRestartMode") && !json["LineNumberRestartMode"].is_null()) {
            this->m_LineNumberRestartMode = std::make_shared< aspose::words::cloud::models::PageSetup::LineNumberRestartMode >(
                pageSetupLineNumberRestartModeFromString(json["LineNumberRestartMode"].get< std::string >())
            );
        }
        if (json.contains("LineStartingNumber") && !json["LineStartingNumber"].is_null()) {
            this->m_LineStartingNumber = std::make_shared< int32_t >(
                json["LineStartingNumber"].get< int32_t >()
            );
        }
        if (json.contains("Orientation") && !json["Orientation"].is_null()) {
            this->m_Orientation = std::make_shared< aspose::words::cloud::models::PageSetup::Orientation >(
                pageSetupOrientationFromString(json["Orientation"].get< std::string >())
            );
        }
        if (json.contains("OtherPagesTray") && !json["OtherPagesTray"].is_null()) {
            this->m_OtherPagesTray = std::make_shared< int32_t >(
                json["OtherPagesTray"].get< int32_t >()
            );
        }
        if (json.contains("PageHeight") && !json["PageHeight"].is_null()) {
            this->m_PageHeight = std::make_shared< double >(
                json["PageHeight"].get< double >()
            );
        }
        if (json.contains("PageNumberStyle") && !json["PageNumberStyle"].is_null()) {
            this->m_PageNumberStyle = std::make_shared< aspose::words::cloud::models::PageSetup::PageNumberStyle >(
                pageSetupPageNumberStyleFromString(json["PageNumberStyle"].get< std::string >())
            );
        }
        if (json.contains("PageStartingNumber") && !json["PageStartingNumber"].is_null()) {
            this->m_PageStartingNumber = std::make_shared< int32_t >(
                json["PageStartingNumber"].get< int32_t >()
            );
        }
        if (json.contains("PageWidth") && !json["PageWidth"].is_null()) {
            this->m_PageWidth = std::make_shared< double >(
                json["PageWidth"].get< double >()
            );
        }
        if (json.contains("PaperSize") && !json["PaperSize"].is_null()) {
            this->m_PaperSize = std::make_shared< aspose::words::cloud::models::PageSetup::PaperSize >(
                pageSetupPaperSizeFromString(json["PaperSize"].get< std::string >())
            );
        }
        if (json.contains("RestartPageNumbering") && !json["RestartPageNumbering"].is_null()) {
            this->m_RestartPageNumbering = std::make_shared< bool >(
                json["RestartPageNumbering"].get< bool >()
            );
        }
        if (json.contains("RightMargin") && !json["RightMargin"].is_null()) {
            this->m_RightMargin = std::make_shared< double >(
                json["RightMargin"].get< double >()
            );
        }
        if (json.contains("RtlGutter") && !json["RtlGutter"].is_null()) {
            this->m_RtlGutter = std::make_shared< bool >(
                json["RtlGutter"].get< bool >()
            );
        }
        if (json.contains("SectionStart") && !json["SectionStart"].is_null()) {
            this->m_SectionStart = std::make_shared< aspose::words::cloud::models::PageSetup::SectionStart >(
                pageSetupSectionStartFromString(json["SectionStart"].get< std::string >())
            );
        }
        if (json.contains("SuppressEndnotes") && !json["SuppressEndnotes"].is_null()) {
            this->m_SuppressEndnotes = std::make_shared< bool >(
                json["SuppressEndnotes"].get< bool >()
            );
        }
        if (json.contains("TopMargin") && !json["TopMargin"].is_null()) {
            this->m_TopMargin = std::make_shared< double >(
                json["TopMargin"].get< double >()
            );
        }
        if (json.contains("VerticalAlignment") && !json["VerticalAlignment"].is_null()) {
            this->m_VerticalAlignment = std::make_shared< aspose::words::cloud::models::PageSetup::VerticalAlignment >(
                pageSetupVerticalAlignmentFromString(json["VerticalAlignment"].get< std::string >())
            );
        }
    }

    void PageSetup::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void PageSetup::validate()
    {
        LinkElement::validate();
    }

    std::shared_ptr< bool > PageSetup::getBidi() const
    {
        return this->m_Bidi;
    }

    void PageSetup::setBidi(std::shared_ptr< bool > value)
    {
        this->m_Bidi = value;
    }


    std::shared_ptr< bool > PageSetup::getBorderAlwaysInFront() const
    {
        return this->m_BorderAlwaysInFront;
    }

    void PageSetup::setBorderAlwaysInFront(std::shared_ptr< bool > value)
    {
        this->m_BorderAlwaysInFront = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PageSetup::BorderAppliesTo > PageSetup::getBorderAppliesTo() const
    {
        return this->m_BorderAppliesTo;
    }

    void PageSetup::setBorderAppliesTo(std::shared_ptr< aspose::words::cloud::models::PageSetup::BorderAppliesTo > value)
    {
        this->m_BorderAppliesTo = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PageSetup::BorderDistanceFrom > PageSetup::getBorderDistanceFrom() const
    {
        return this->m_BorderDistanceFrom;
    }

    void PageSetup::setBorderDistanceFrom(std::shared_ptr< aspose::words::cloud::models::PageSetup::BorderDistanceFrom > value)
    {
        this->m_BorderDistanceFrom = value;
    }


    std::shared_ptr< double > PageSetup::getBottomMargin() const
    {
        return this->m_BottomMargin;
    }

    void PageSetup::setBottomMargin(std::shared_ptr< double > value)
    {
        this->m_BottomMargin = value;
    }


    std::shared_ptr< bool > PageSetup::getDifferentFirstPageHeaderFooter() const
    {
        return this->m_DifferentFirstPageHeaderFooter;
    }

    void PageSetup::setDifferentFirstPageHeaderFooter(std::shared_ptr< bool > value)
    {
        this->m_DifferentFirstPageHeaderFooter = value;
    }


    std::shared_ptr< int32_t > PageSetup::getFirstPageTray() const
    {
        return this->m_FirstPageTray;
    }

    void PageSetup::setFirstPageTray(std::shared_ptr< int32_t > value)
    {
        this->m_FirstPageTray = value;
    }


    std::shared_ptr< double > PageSetup::getFooterDistance() const
    {
        return this->m_FooterDistance;
    }

    void PageSetup::setFooterDistance(std::shared_ptr< double > value)
    {
        this->m_FooterDistance = value;
    }


    std::shared_ptr< double > PageSetup::getGutter() const
    {
        return this->m_Gutter;
    }

    void PageSetup::setGutter(std::shared_ptr< double > value)
    {
        this->m_Gutter = value;
    }


    std::shared_ptr< double > PageSetup::getHeaderDistance() const
    {
        return this->m_HeaderDistance;
    }

    void PageSetup::setHeaderDistance(std::shared_ptr< double > value)
    {
        this->m_HeaderDistance = value;
    }


    std::shared_ptr< double > PageSetup::getLeftMargin() const
    {
        return this->m_LeftMargin;
    }

    void PageSetup::setLeftMargin(std::shared_ptr< double > value)
    {
        this->m_LeftMargin = value;
    }


    std::shared_ptr< int32_t > PageSetup::getLineNumberCountBy() const
    {
        return this->m_LineNumberCountBy;
    }

    void PageSetup::setLineNumberCountBy(std::shared_ptr< int32_t > value)
    {
        this->m_LineNumberCountBy = value;
    }


    std::shared_ptr< double > PageSetup::getLineNumberDistanceFromText() const
    {
        return this->m_LineNumberDistanceFromText;
    }

    void PageSetup::setLineNumberDistanceFromText(std::shared_ptr< double > value)
    {
        this->m_LineNumberDistanceFromText = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PageSetup::LineNumberRestartMode > PageSetup::getLineNumberRestartMode() const
    {
        return this->m_LineNumberRestartMode;
    }

    void PageSetup::setLineNumberRestartMode(std::shared_ptr< aspose::words::cloud::models::PageSetup::LineNumberRestartMode > value)
    {
        this->m_LineNumberRestartMode = value;
    }


    std::shared_ptr< int32_t > PageSetup::getLineStartingNumber() const
    {
        return this->m_LineStartingNumber;
    }

    void PageSetup::setLineStartingNumber(std::shared_ptr< int32_t > value)
    {
        this->m_LineStartingNumber = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PageSetup::Orientation > PageSetup::getOrientation() const
    {
        return this->m_Orientation;
    }

    void PageSetup::setOrientation(std::shared_ptr< aspose::words::cloud::models::PageSetup::Orientation > value)
    {
        this->m_Orientation = value;
    }


    std::shared_ptr< int32_t > PageSetup::getOtherPagesTray() const
    {
        return this->m_OtherPagesTray;
    }

    void PageSetup::setOtherPagesTray(std::shared_ptr< int32_t > value)
    {
        this->m_OtherPagesTray = value;
    }


    std::shared_ptr< double > PageSetup::getPageHeight() const
    {
        return this->m_PageHeight;
    }

    void PageSetup::setPageHeight(std::shared_ptr< double > value)
    {
        this->m_PageHeight = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PageSetup::PageNumberStyle > PageSetup::getPageNumberStyle() const
    {
        return this->m_PageNumberStyle;
    }

    void PageSetup::setPageNumberStyle(std::shared_ptr< aspose::words::cloud::models::PageSetup::PageNumberStyle > value)
    {
        this->m_PageNumberStyle = value;
    }


    std::shared_ptr< int32_t > PageSetup::getPageStartingNumber() const
    {
        return this->m_PageStartingNumber;
    }

    void PageSetup::setPageStartingNumber(std::shared_ptr< int32_t > value)
    {
        this->m_PageStartingNumber = value;
    }


    std::shared_ptr< double > PageSetup::getPageWidth() const
    {
        return this->m_PageWidth;
    }

    void PageSetup::setPageWidth(std::shared_ptr< double > value)
    {
        this->m_PageWidth = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PageSetup::PaperSize > PageSetup::getPaperSize() const
    {
        return this->m_PaperSize;
    }

    void PageSetup::setPaperSize(std::shared_ptr< aspose::words::cloud::models::PageSetup::PaperSize > value)
    {
        this->m_PaperSize = value;
    }


    std::shared_ptr< bool > PageSetup::getRestartPageNumbering() const
    {
        return this->m_RestartPageNumbering;
    }

    void PageSetup::setRestartPageNumbering(std::shared_ptr< bool > value)
    {
        this->m_RestartPageNumbering = value;
    }


    std::shared_ptr< double > PageSetup::getRightMargin() const
    {
        return this->m_RightMargin;
    }

    void PageSetup::setRightMargin(std::shared_ptr< double > value)
    {
        this->m_RightMargin = value;
    }


    std::shared_ptr< bool > PageSetup::getRtlGutter() const
    {
        return this->m_RtlGutter;
    }

    void PageSetup::setRtlGutter(std::shared_ptr< bool > value)
    {
        this->m_RtlGutter = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PageSetup::SectionStart > PageSetup::getSectionStart() const
    {
        return this->m_SectionStart;
    }

    void PageSetup::setSectionStart(std::shared_ptr< aspose::words::cloud::models::PageSetup::SectionStart > value)
    {
        this->m_SectionStart = value;
    }


    std::shared_ptr< bool > PageSetup::getSuppressEndnotes() const
    {
        return this->m_SuppressEndnotes;
    }

    void PageSetup::setSuppressEndnotes(std::shared_ptr< bool > value)
    {
        this->m_SuppressEndnotes = value;
    }


    std::shared_ptr< double > PageSetup::getTopMargin() const
    {
        return this->m_TopMargin;
    }

    void PageSetup::setTopMargin(std::shared_ptr< double > value)
    {
        this->m_TopMargin = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PageSetup::VerticalAlignment > PageSetup::getVerticalAlignment() const
    {
        return this->m_VerticalAlignment;
    }

    void PageSetup::setVerticalAlignment(std::shared_ptr< aspose::words::cloud::models::PageSetup::VerticalAlignment > value)
    {
        this->m_VerticalAlignment = value;
    }



    /*
     * PageStatData implementation
     */
    void PageStatData::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_FootnotesStatData) {
            this->m_FootnotesStatData->toJson(&json["FootnotesStatData"]);
        }
        if (this->m_ParagraphCount) {
            json["ParagraphCount"] = *(this->m_ParagraphCount);
        }
        if (this->m_WordCount) {
            json["WordCount"] = *(this->m_WordCount);
        }
        if (this->m_PageNumber) {
            json["PageNumber"] = *(this->m_PageNumber);
        }
    }

    void PageStatData::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("FootnotesStatData") && !json["FootnotesStatData"].is_null()) {
            this->m_FootnotesStatData = createModelInstance< aspose::words::cloud::models::FootnotesStatData >(L"FootnotesStatData, _", json["FootnotesStatData"]);
        }
        if (json.contains("ParagraphCount") && !json["ParagraphCount"].is_null()) {
            this->m_ParagraphCount = std::make_shared< int32_t >(
                json["ParagraphCount"].get< int32_t >()
            );
        }
        if (json.contains("WordCount") && !json["WordCount"].is_null()) {
            this->m_WordCount = std::make_shared< int32_t >(
                json["WordCount"].get< int32_t >()
            );
        }
        if (json.contains("PageNumber") && !json["PageNumber"].is_null()) {
            this->m_PageNumber = std::make_shared< int32_t >(
                json["PageNumber"].get< int32_t >()
            );
        }
    }

    void PageStatData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void PageStatData::validate()
    {
        if (this->m_ParagraphCount == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property ParagraphCount in PageStatData is required.");
        }

        if (this->m_WordCount == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property WordCount in PageStatData is required.");
        }

        if (this->m_PageNumber == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property PageNumber in PageStatData is required.");
        }


        if (this->m_FootnotesStatData != nullptr)
        {
            this->m_FootnotesStatData->validate();
        }




    }

    std::shared_ptr< aspose::words::cloud::models::FootnotesStatData > PageStatData::getFootnotesStatData() const
    {
        return this->m_FootnotesStatData;
    }

    void PageStatData::setFootnotesStatData(std::shared_ptr< aspose::words::cloud::models::FootnotesStatData > value)
    {
        this->m_FootnotesStatData = value;
    }


    std::shared_ptr< int32_t > PageStatData::getParagraphCount() const
    {
        return this->m_ParagraphCount;
    }

    void PageStatData::setParagraphCount(std::shared_ptr< int32_t > value)
    {
        this->m_ParagraphCount = value;
    }


    std::shared_ptr< int32_t > PageStatData::getWordCount() const
    {
        return this->m_WordCount;
    }

    void PageStatData::setWordCount(std::shared_ptr< int32_t > value)
    {
        this->m_WordCount = value;
    }


    std::shared_ptr< int32_t > PageStatData::getPageNumber() const
    {
        return this->m_PageNumber;
    }

    void PageStatData::setPageNumber(std::shared_ptr< int32_t > value)
    {
        this->m_PageNumber = value;
    }



    /*
     * Paragraph implementation
     */
    void Paragraph::toJson(void* jsonIfc) const
    {
        NodeLink::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ChildNodes) {
            json["ChildNodes"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_ChildNodes)) {
                element->toJson(&json["ChildNodes"].emplace_back());
            }
        }
    }

    void Paragraph::fromJson(const void* jsonIfc)
    {
        NodeLink::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ChildNodes") && !json["ChildNodes"].is_null()) {
            this->m_ChildNodes = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::NodeLink>> >();
            for (auto& element : json["ChildNodes"]) {
                this->m_ChildNodes->emplace_back(createModelInstance< aspose::words::cloud::models::NodeLink >(L"NodeLink, _", element));
            }
        }
    }

    void Paragraph::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Paragraph::validate()
    {
        NodeLink::validate();

        if (this->m_ChildNodes != nullptr)
        {
            for (auto& elementChildNodes : *(this->m_ChildNodes))
            {
                if (elementChildNodes != nullptr)
                {
                    elementChildNodes->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::NodeLink>> > Paragraph::getChildNodes() const
    {
        return this->m_ChildNodes;
    }

    void Paragraph::setChildNodes(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::NodeLink>> > value)
    {
        this->m_ChildNodes = value;
    }



    /*
     * ParagraphFormat implementation
     */
    void ParagraphFormat::toJson(void* jsonIfc) const
    {
        ParagraphFormatBase::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_IsListItem) {
            json["IsListItem"] = *(this->m_IsListItem);
        }
        if (this->m_IsHeading) {
            json["IsHeading"] = *(this->m_IsHeading);
        }
    }

    void ParagraphFormat::fromJson(const void* jsonIfc)
    {
        ParagraphFormatBase::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("IsListItem") && !json["IsListItem"].is_null()) {
            this->m_IsListItem = std::make_shared< bool >(
                json["IsListItem"].get< bool >()
            );
        }
        if (json.contains("IsHeading") && !json["IsHeading"].is_null()) {
            this->m_IsHeading = std::make_shared< bool >(
                json["IsHeading"].get< bool >()
            );
        }
    }

    void ParagraphFormat::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ParagraphFormat::validate()
    {
        ParagraphFormatBase::validate();
    }

    std::shared_ptr< bool > ParagraphFormat::getIsListItem() const
    {
        return this->m_IsListItem;
    }

    void ParagraphFormat::setIsListItem(std::shared_ptr< bool > value)
    {
        this->m_IsListItem = value;
    }


    std::shared_ptr< bool > ParagraphFormat::getIsHeading() const
    {
        return this->m_IsHeading;
    }

    void ParagraphFormat::setIsHeading(std::shared_ptr< bool > value)
    {
        this->m_IsHeading = value;
    }



    /*
     * ParagraphFormatBase implementation
     */
    inline std::string paragraphFormatBaseAlignmentToString(aspose::words::cloud::models::ParagraphFormatBase::Alignment value)
    {
        if (value == aspose::words::cloud::models::ParagraphFormatBase::Alignment::LEFT) return "Left";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::Alignment::CENTER) return "Center";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::Alignment::RIGHT) return "Right";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::Alignment::JUSTIFY) return "Justify";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::Alignment::DISTRIBUTED) return "Distributed";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::Alignment::ARABIC_MEDIUM_KASHIDA) return "ArabicMediumKashida";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::Alignment::ARABIC_HIGH_KASHIDA) return "ArabicHighKashida";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::Alignment::ARABIC_LOW_KASHIDA) return "ArabicLowKashida";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::Alignment::THAI_DISTRIBUTED) return "ThaiDistributed";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::Alignment::MATH_ELEMENT_CENTER_AS_GROUP) return "MathElementCenterAsGroup";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ParagraphFormatBase::Alignment paragraphFormatBaseAlignmentFromString(const std::string& value)
    {
        if (value == "Left") return aspose::words::cloud::models::ParagraphFormatBase::Alignment::LEFT;
        if (value == "Center") return aspose::words::cloud::models::ParagraphFormatBase::Alignment::CENTER;
        if (value == "Right") return aspose::words::cloud::models::ParagraphFormatBase::Alignment::RIGHT;
        if (value == "Justify") return aspose::words::cloud::models::ParagraphFormatBase::Alignment::JUSTIFY;
        if (value == "Distributed") return aspose::words::cloud::models::ParagraphFormatBase::Alignment::DISTRIBUTED;
        if (value == "ArabicMediumKashida") return aspose::words::cloud::models::ParagraphFormatBase::Alignment::ARABIC_MEDIUM_KASHIDA;
        if (value == "ArabicHighKashida") return aspose::words::cloud::models::ParagraphFormatBase::Alignment::ARABIC_HIGH_KASHIDA;
        if (value == "ArabicLowKashida") return aspose::words::cloud::models::ParagraphFormatBase::Alignment::ARABIC_LOW_KASHIDA;
        if (value == "ThaiDistributed") return aspose::words::cloud::models::ParagraphFormatBase::Alignment::THAI_DISTRIBUTED;
        if (value == "MathElementCenterAsGroup") return aspose::words::cloud::models::ParagraphFormatBase::Alignment::MATH_ELEMENT_CENTER_AS_GROUP;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string paragraphFormatBaseDropCapPositionToString(aspose::words::cloud::models::ParagraphFormatBase::DropCapPosition value)
    {
        if (value == aspose::words::cloud::models::ParagraphFormatBase::DropCapPosition::NONE) return "None";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::DropCapPosition::NORMAL) return "Normal";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::DropCapPosition::MARGIN) return "Margin";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ParagraphFormatBase::DropCapPosition paragraphFormatBaseDropCapPositionFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::ParagraphFormatBase::DropCapPosition::NONE;
        if (value == "Normal") return aspose::words::cloud::models::ParagraphFormatBase::DropCapPosition::NORMAL;
        if (value == "Margin") return aspose::words::cloud::models::ParagraphFormatBase::DropCapPosition::MARGIN;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string paragraphFormatBaseLineSpacingRuleToString(aspose::words::cloud::models::ParagraphFormatBase::LineSpacingRule value)
    {
        if (value == aspose::words::cloud::models::ParagraphFormatBase::LineSpacingRule::AT_LEAST) return "AtLeast";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::LineSpacingRule::EXACTLY) return "Exactly";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::LineSpacingRule::MULTIPLE) return "Multiple";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ParagraphFormatBase::LineSpacingRule paragraphFormatBaseLineSpacingRuleFromString(const std::string& value)
    {
        if (value == "AtLeast") return aspose::words::cloud::models::ParagraphFormatBase::LineSpacingRule::AT_LEAST;
        if (value == "Exactly") return aspose::words::cloud::models::ParagraphFormatBase::LineSpacingRule::EXACTLY;
        if (value == "Multiple") return aspose::words::cloud::models::ParagraphFormatBase::LineSpacingRule::MULTIPLE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string paragraphFormatBaseOutlineLevelToString(aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel value)
    {
        if (value == aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL1) return "Level1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL2) return "Level2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL3) return "Level3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL4) return "Level4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL5) return "Level5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL6) return "Level6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL7) return "Level7";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL8) return "Level8";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL9) return "Level9";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::BODY_TEXT) return "BodyText";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel paragraphFormatBaseOutlineLevelFromString(const std::string& value)
    {
        if (value == "Level1") return aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL1;
        if (value == "Level2") return aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL2;
        if (value == "Level3") return aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL3;
        if (value == "Level4") return aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL4;
        if (value == "Level5") return aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL5;
        if (value == "Level6") return aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL6;
        if (value == "Level7") return aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL7;
        if (value == "Level8") return aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL8;
        if (value == "Level9") return aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::LEVEL9;
        if (value == "BodyText") return aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel::BODY_TEXT;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string paragraphFormatBaseStyleIdentifierToString(aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier value)
    {
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::NORMAL) return "Normal";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING1) return "Heading1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING2) return "Heading2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING3) return "Heading3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING4) return "Heading4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING5) return "Heading5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING6) return "Heading6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING7) return "Heading7";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING8) return "Heading8";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING9) return "Heading9";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX1) return "Index1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX2) return "Index2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX3) return "Index3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX4) return "Index4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX5) return "Index5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX6) return "Index6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX7) return "Index7";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX8) return "Index8";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX9) return "Index9";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC1) return "Toc1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC2) return "Toc2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC3) return "Toc3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC4) return "Toc4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC5) return "Toc5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC6) return "Toc6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC7) return "Toc7";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC8) return "Toc8";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC9) return "Toc9";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::NORMAL_INDENT) return "NormalIndent";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::FOOTNOTE_TEXT) return "FootnoteText";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COMMENT_TEXT) return "CommentText";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADER) return "Header";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::FOOTER) return "Footer";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX_HEADING) return "IndexHeading";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::CAPTION) return "Caption";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_OF_FIGURES) return "TableOfFigures";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::ENVELOPE_ADDRESS) return "EnvelopeAddress";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::ENVELOPE_RETURN) return "EnvelopeReturn";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::FOOTNOTE_REFERENCE) return "FootnoteReference";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COMMENT_REFERENCE) return "CommentReference";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LINE_NUMBER) return "LineNumber";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::PAGE_NUMBER) return "PageNumber";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::ENDNOTE_REFERENCE) return "EndnoteReference";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::ENDNOTE_TEXT) return "EndnoteText";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_OF_AUTHORITIES) return "TableOfAuthorities";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MACRO) return "Macro";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOA_HEADING) return "ToaHeading";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST) return "List";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_BULLET) return "ListBullet";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_NUMBER) return "ListNumber";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST2) return "List2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST3) return "List3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST4) return "List4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST5) return "List5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_BULLET2) return "ListBullet2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_BULLET3) return "ListBullet3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_BULLET4) return "ListBullet4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_BULLET5) return "ListBullet5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_NUMBER2) return "ListNumber2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_NUMBER3) return "ListNumber3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_NUMBER4) return "ListNumber4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_NUMBER5) return "ListNumber5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TITLE) return "Title";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::CLOSING) return "Closing";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::SIGNATURE) return "Signature";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DEFAULT_PARAGRAPH_FONT) return "DefaultParagraphFont";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BODY_TEXT) return "BodyText";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BODY_TEXT_IND) return "BodyTextInd";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_CONTINUE) return "ListContinue";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_CONTINUE2) return "ListContinue2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_CONTINUE3) return "ListContinue3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_CONTINUE4) return "ListContinue4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_CONTINUE5) return "ListContinue5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MESSAGE_HEADER) return "MessageHeader";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::SUBTITLE) return "Subtitle";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::SALUTATION) return "Salutation";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DATE) return "Date";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BODY_TEXT1_I) return "BodyText1I";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BODY_TEXT1_I2) return "BodyText1I2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::NOTE_HEADING) return "NoteHeading";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BODY_TEXT2) return "BodyText2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BODY_TEXT3) return "BodyText3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BODY_TEXT_IND2) return "BodyTextInd2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BODY_TEXT_IND3) return "BodyTextInd3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BLOCK_TEXT) return "BlockText";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HYPERLINK) return "Hyperlink";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::FOLLOWED_HYPERLINK) return "FollowedHyperlink";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::STRONG) return "Strong";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::EMPHASIS) return "Emphasis";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DOCUMENT_MAP) return "DocumentMap";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::PLAIN_TEXT) return "PlainText";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::EMAIL_SIGNATURE) return "EmailSignature";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_TOP_OF_FORM) return "HtmlTopOfForm";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_BOTTOM_OF_FORM) return "HtmlBottomOfForm";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::NORMAL_WEB) return "NormalWeb";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_ACRONYM) return "HtmlAcronym";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_ADDRESS) return "HtmlAddress";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_CITE) return "HtmlCite";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_CODE) return "HtmlCode";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_DEFINITION) return "HtmlDefinition";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_KEYBOARD) return "HtmlKeyboard";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_PREFORMATTED) return "HtmlPreformatted";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_SAMPLE) return "HtmlSample";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_TYPEWRITER) return "HtmlTypewriter";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_VARIABLE) return "HtmlVariable";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_NORMAL) return "TableNormal";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COMMENT_SUBJECT) return "CommentSubject";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::NO_LIST) return "NoList";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::OUTLINE_LIST1) return "OutlineList1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::OUTLINE_LIST2) return "OutlineList2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::OUTLINE_LIST3) return "OutlineList3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_SIMPLE1) return "TableSimple1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_SIMPLE2) return "TableSimple2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_SIMPLE3) return "TableSimple3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_CLASSIC1) return "TableClassic1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_CLASSIC2) return "TableClassic2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_CLASSIC3) return "TableClassic3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_CLASSIC4) return "TableClassic4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_COLORFUL1) return "TableColorful1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_COLORFUL2) return "TableColorful2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_COLORFUL3) return "TableColorful3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_COLUMNS1) return "TableColumns1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_COLUMNS2) return "TableColumns2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_COLUMNS3) return "TableColumns3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_COLUMNS4) return "TableColumns4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_COLUMNS5) return "TableColumns5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID1) return "TableGrid1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID2) return "TableGrid2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID3) return "TableGrid3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID4) return "TableGrid4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID5) return "TableGrid5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID6) return "TableGrid6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID7) return "TableGrid7";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID8) return "TableGrid8";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_LIST1) return "TableList1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_LIST2) return "TableList2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_LIST3) return "TableList3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_LIST4) return "TableList4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_LIST5) return "TableList5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_LIST6) return "TableList6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_LIST7) return "TableList7";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_LIST8) return "TableList8";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE3_D_EFFECTS1) return "Table3DEffects1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE3_D_EFFECTS2) return "Table3DEffects2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE3_D_EFFECTS3) return "Table3DEffects3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_CONTEMPORARY) return "TableContemporary";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_ELEGANT) return "TableElegant";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_PROFESSIONAL) return "TableProfessional";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_SUBTLE1) return "TableSubtle1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_SUBTLE2) return "TableSubtle2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_WEB1) return "TableWeb1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_WEB2) return "TableWeb2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_WEB3) return "TableWeb3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BALLOON_TEXT) return "BalloonText";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID) return "TableGrid";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_THEME) return "TableTheme";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::PLACEHOLDER_TEXT) return "PlaceholderText";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::NO_SPACING) return "NoSpacing";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_SHADING) return "LightShading";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_LIST) return "LightList";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_GRID) return "LightGrid";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING1) return "MediumShading1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING2) return "MediumShading2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST1) return "MediumList1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST2) return "MediumList2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID1) return "MediumGrid1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID2) return "MediumGrid2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID3) return "MediumGrid3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DARK_LIST) return "DarkList";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_SHADING) return "ColorfulShading";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_LIST) return "ColorfulList";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_GRID) return "ColorfulGrid";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_SHADING_ACCENT1) return "LightShadingAccent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_LIST_ACCENT1) return "LightListAccent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_GRID_ACCENT1) return "LightGridAccent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING1_ACCENT1) return "MediumShading1Accent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING2_ACCENT1) return "MediumShading2Accent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST1_ACCENT1) return "MediumList1Accent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::REVISION) return "Revision";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_PARAGRAPH) return "ListParagraph";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::QUOTE) return "Quote";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INTENSE_QUOTE) return "IntenseQuote";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST2_ACCENT1) return "MediumList2Accent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID1_ACCENT1) return "MediumGrid1Accent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID2_ACCENT1) return "MediumGrid2Accent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID3_ACCENT1) return "MediumGrid3Accent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DARK_LIST_ACCENT1) return "DarkListAccent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_SHADING_ACCENT1) return "ColorfulShadingAccent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_LIST_ACCENT1) return "ColorfulListAccent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_GRID_ACCENT1) return "ColorfulGridAccent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_SHADING_ACCENT2) return "LightShadingAccent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_LIST_ACCENT2) return "LightListAccent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_GRID_ACCENT2) return "LightGridAccent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING1_ACCENT2) return "MediumShading1Accent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING2_ACCENT2) return "MediumShading2Accent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST1_ACCENT2) return "MediumList1Accent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST2_ACCENT2) return "MediumList2Accent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID1_ACCENT2) return "MediumGrid1Accent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID2_ACCENT2) return "MediumGrid2Accent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID3_ACCENT2) return "MediumGrid3Accent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DARK_LIST_ACCENT2) return "DarkListAccent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_SHADING_ACCENT2) return "ColorfulShadingAccent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_LIST_ACCENT2) return "ColorfulListAccent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_GRID_ACCENT2) return "ColorfulGridAccent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_SHADING_ACCENT3) return "LightShadingAccent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_LIST_ACCENT3) return "LightListAccent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_GRID_ACCENT3) return "LightGridAccent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING1_ACCENT3) return "MediumShading1Accent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING2_ACCENT3) return "MediumShading2Accent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST1_ACCENT3) return "MediumList1Accent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST2_ACCENT3) return "MediumList2Accent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID1_ACCENT3) return "MediumGrid1Accent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID2_ACCENT3) return "MediumGrid2Accent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID3_ACCENT3) return "MediumGrid3Accent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DARK_LIST_ACCENT3) return "DarkListAccent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_SHADING_ACCENT3) return "ColorfulShadingAccent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_LIST_ACCENT3) return "ColorfulListAccent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_GRID_ACCENT3) return "ColorfulGridAccent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_SHADING_ACCENT4) return "LightShadingAccent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_LIST_ACCENT4) return "LightListAccent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_GRID_ACCENT4) return "LightGridAccent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING1_ACCENT4) return "MediumShading1Accent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING2_ACCENT4) return "MediumShading2Accent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST1_ACCENT4) return "MediumList1Accent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST2_ACCENT4) return "MediumList2Accent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID1_ACCENT4) return "MediumGrid1Accent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID2_ACCENT4) return "MediumGrid2Accent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID3_ACCENT4) return "MediumGrid3Accent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DARK_LIST_ACCENT4) return "DarkListAccent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_SHADING_ACCENT4) return "ColorfulShadingAccent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_LIST_ACCENT4) return "ColorfulListAccent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_GRID_ACCENT4) return "ColorfulGridAccent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_SHADING_ACCENT5) return "LightShadingAccent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_LIST_ACCENT5) return "LightListAccent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_GRID_ACCENT5) return "LightGridAccent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING1_ACCENT5) return "MediumShading1Accent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING2_ACCENT5) return "MediumShading2Accent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST1_ACCENT5) return "MediumList1Accent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST2_ACCENT5) return "MediumList2Accent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID1_ACCENT5) return "MediumGrid1Accent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID2_ACCENT5) return "MediumGrid2Accent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID3_ACCENT5) return "MediumGrid3Accent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DARK_LIST_ACCENT5) return "DarkListAccent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_SHADING_ACCENT5) return "ColorfulShadingAccent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_LIST_ACCENT5) return "ColorfulListAccent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_GRID_ACCENT5) return "ColorfulGridAccent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_SHADING_ACCENT6) return "LightShadingAccent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_LIST_ACCENT6) return "LightListAccent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_GRID_ACCENT6) return "LightGridAccent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING1_ACCENT6) return "MediumShading1Accent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING2_ACCENT6) return "MediumShading2Accent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST1_ACCENT6) return "MediumList1Accent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST2_ACCENT6) return "MediumList2Accent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID1_ACCENT6) return "MediumGrid1Accent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID2_ACCENT6) return "MediumGrid2Accent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID3_ACCENT6) return "MediumGrid3Accent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DARK_LIST_ACCENT6) return "DarkListAccent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_SHADING_ACCENT6) return "ColorfulShadingAccent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_LIST_ACCENT6) return "ColorfulListAccent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_GRID_ACCENT6) return "ColorfulGridAccent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::SUBTLE_EMPHASIS) return "SubtleEmphasis";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INTENSE_EMPHASIS) return "IntenseEmphasis";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::SUBTLE_REFERENCE) return "SubtleReference";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INTENSE_REFERENCE) return "IntenseReference";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BOOK_TITLE) return "BookTitle";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BIBLIOGRAPHY) return "Bibliography";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC_HEADING) return "TocHeading";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::PLAIN_TABLE1) return "PlainTable1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::PLAIN_TABLE2) return "PlainTable2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::PLAIN_TABLE3) return "PlainTable3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::PLAIN_TABLE4) return "PlainTable4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::PLAIN_TABLE5) return "PlainTable5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID_LIGHT) return "TableGridLight";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE1_LIGHT) return "GridTable1Light";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE2) return "GridTable2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE3) return "GridTable3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE4) return "GridTable4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE5_DARK) return "GridTable5Dark";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE6_COLORFUL) return "GridTable6Colorful";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE7_COLORFUL) return "GridTable7Colorful";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT1) return "GridTable1LightAccent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE2_ACCENT1) return "GridTable2Accent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE3_ACCENT1) return "GridTable3Accent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE4_ACCENT1) return "GridTable4Accent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE5_DARK_ACCENT1) return "GridTable5DarkAccent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT1) return "GridTable6ColorfulAccent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT1) return "GridTable7ColorfulAccent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT2) return "GridTable1LightAccent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE2_ACCENT2) return "GridTable2Accent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE3_ACCENT2) return "GridTable3Accent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE4_ACCENT2) return "GridTable4Accent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE5_DARK_ACCENT2) return "GridTable5DarkAccent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT2) return "GridTable6ColorfulAccent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT2) return "GridTable7ColorfulAccent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT3) return "GridTable1LightAccent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE2_ACCENT3) return "GridTable2Accent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE3_ACCENT3) return "GridTable3Accent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE4_ACCENT3) return "GridTable4Accent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE5_DARK_ACCENT3) return "GridTable5DarkAccent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT3) return "GridTable6ColorfulAccent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT3) return "GridTable7ColorfulAccent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT4) return "GridTable1LightAccent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE2_ACCENT4) return "GridTable2Accent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE3_ACCENT4) return "GridTable3Accent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE4_ACCENT4) return "GridTable4Accent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE5_DARK_ACCENT4) return "GridTable5DarkAccent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT4) return "GridTable6ColorfulAccent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT4) return "GridTable7ColorfulAccent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT5) return "GridTable1LightAccent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE2_ACCENT5) return "GridTable2Accent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE3_ACCENT5) return "GridTable3Accent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE4_ACCENT5) return "GridTable4Accent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE5_DARK_ACCENT5) return "GridTable5DarkAccent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT5) return "GridTable6ColorfulAccent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT5) return "GridTable7ColorfulAccent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT6) return "GridTable1LightAccent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE2_ACCENT6) return "GridTable2Accent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE3_ACCENT6) return "GridTable3Accent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE4_ACCENT6) return "GridTable4Accent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE5_DARK_ACCENT6) return "GridTable5DarkAccent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT6) return "GridTable6ColorfulAccent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT6) return "GridTable7ColorfulAccent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE1_LIGHT) return "ListTable1Light";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE2) return "ListTable2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE3) return "ListTable3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE4) return "ListTable4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE5_DARK) return "ListTable5Dark";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE6_COLORFUL) return "ListTable6Colorful";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE7_COLORFUL) return "ListTable7Colorful";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT1) return "ListTable1LightAccent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE2_ACCENT1) return "ListTable2Accent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE3_ACCENT1) return "ListTable3Accent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE4_ACCENT1) return "ListTable4Accent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE5_DARK_ACCENT1) return "ListTable5DarkAccent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT1) return "ListTable6ColorfulAccent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT1) return "ListTable7ColorfulAccent1";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT2) return "ListTable1LightAccent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE2_ACCENT2) return "ListTable2Accent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE3_ACCENT2) return "ListTable3Accent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE4_ACCENT2) return "ListTable4Accent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE5_DARK_ACCENT2) return "ListTable5DarkAccent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT2) return "ListTable6ColorfulAccent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT2) return "ListTable7ColorfulAccent2";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT3) return "ListTable1LightAccent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE2_ACCENT3) return "ListTable2Accent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE3_ACCENT3) return "ListTable3Accent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE4_ACCENT3) return "ListTable4Accent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE5_DARK_ACCENT3) return "ListTable5DarkAccent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT3) return "ListTable6ColorfulAccent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT3) return "ListTable7ColorfulAccent3";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT4) return "ListTable1LightAccent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE2_ACCENT4) return "ListTable2Accent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE3_ACCENT4) return "ListTable3Accent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE4_ACCENT4) return "ListTable4Accent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE5_DARK_ACCENT4) return "ListTable5DarkAccent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT4) return "ListTable6ColorfulAccent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT4) return "ListTable7ColorfulAccent4";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT5) return "ListTable1LightAccent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE2_ACCENT5) return "ListTable2Accent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE3_ACCENT5) return "ListTable3Accent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE4_ACCENT5) return "ListTable4Accent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE5_DARK_ACCENT5) return "ListTable5DarkAccent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT5) return "ListTable6ColorfulAccent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT5) return "ListTable7ColorfulAccent5";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT6) return "ListTable1LightAccent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE2_ACCENT6) return "ListTable2Accent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE3_ACCENT6) return "ListTable3Accent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE4_ACCENT6) return "ListTable4Accent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE5_DARK_ACCENT6) return "ListTable5DarkAccent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT6) return "ListTable6ColorfulAccent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT6) return "ListTable7ColorfulAccent6";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::SMART_LINK) return "SmartLink";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MENTION) return "Mention";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::SMART_HYPERLINK) return "SmartHyperlink";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HASHTAG) return "Hashtag";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::UNRESOLVED_MENTION) return "UnresolvedMention";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::USER) return "User";
        if (value == aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::NIL) return "Nil";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier paragraphFormatBaseStyleIdentifierFromString(const std::string& value)
    {
        if (value == "Normal") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::NORMAL;
        if (value == "Heading1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING1;
        if (value == "Heading2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING2;
        if (value == "Heading3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING3;
        if (value == "Heading4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING4;
        if (value == "Heading5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING5;
        if (value == "Heading6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING6;
        if (value == "Heading7") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING7;
        if (value == "Heading8") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING8;
        if (value == "Heading9") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADING9;
        if (value == "Index1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX1;
        if (value == "Index2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX2;
        if (value == "Index3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX3;
        if (value == "Index4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX4;
        if (value == "Index5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX5;
        if (value == "Index6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX6;
        if (value == "Index7") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX7;
        if (value == "Index8") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX8;
        if (value == "Index9") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX9;
        if (value == "Toc1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC1;
        if (value == "Toc2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC2;
        if (value == "Toc3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC3;
        if (value == "Toc4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC4;
        if (value == "Toc5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC5;
        if (value == "Toc6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC6;
        if (value == "Toc7") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC7;
        if (value == "Toc8") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC8;
        if (value == "Toc9") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC9;
        if (value == "NormalIndent") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::NORMAL_INDENT;
        if (value == "FootnoteText") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::FOOTNOTE_TEXT;
        if (value == "CommentText") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COMMENT_TEXT;
        if (value == "Header") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HEADER;
        if (value == "Footer") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::FOOTER;
        if (value == "IndexHeading") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INDEX_HEADING;
        if (value == "Caption") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::CAPTION;
        if (value == "TableOfFigures") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_OF_FIGURES;
        if (value == "EnvelopeAddress") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::ENVELOPE_ADDRESS;
        if (value == "EnvelopeReturn") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::ENVELOPE_RETURN;
        if (value == "FootnoteReference") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::FOOTNOTE_REFERENCE;
        if (value == "CommentReference") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COMMENT_REFERENCE;
        if (value == "LineNumber") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LINE_NUMBER;
        if (value == "PageNumber") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::PAGE_NUMBER;
        if (value == "EndnoteReference") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::ENDNOTE_REFERENCE;
        if (value == "EndnoteText") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::ENDNOTE_TEXT;
        if (value == "TableOfAuthorities") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_OF_AUTHORITIES;
        if (value == "Macro") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MACRO;
        if (value == "ToaHeading") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOA_HEADING;
        if (value == "List") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST;
        if (value == "ListBullet") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_BULLET;
        if (value == "ListNumber") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_NUMBER;
        if (value == "List2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST2;
        if (value == "List3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST3;
        if (value == "List4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST4;
        if (value == "List5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST5;
        if (value == "ListBullet2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_BULLET2;
        if (value == "ListBullet3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_BULLET3;
        if (value == "ListBullet4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_BULLET4;
        if (value == "ListBullet5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_BULLET5;
        if (value == "ListNumber2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_NUMBER2;
        if (value == "ListNumber3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_NUMBER3;
        if (value == "ListNumber4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_NUMBER4;
        if (value == "ListNumber5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_NUMBER5;
        if (value == "Title") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TITLE;
        if (value == "Closing") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::CLOSING;
        if (value == "Signature") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::SIGNATURE;
        if (value == "DefaultParagraphFont") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DEFAULT_PARAGRAPH_FONT;
        if (value == "BodyText") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BODY_TEXT;
        if (value == "BodyTextInd") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BODY_TEXT_IND;
        if (value == "ListContinue") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_CONTINUE;
        if (value == "ListContinue2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_CONTINUE2;
        if (value == "ListContinue3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_CONTINUE3;
        if (value == "ListContinue4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_CONTINUE4;
        if (value == "ListContinue5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_CONTINUE5;
        if (value == "MessageHeader") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MESSAGE_HEADER;
        if (value == "Subtitle") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::SUBTITLE;
        if (value == "Salutation") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::SALUTATION;
        if (value == "Date") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DATE;
        if (value == "BodyText1I") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BODY_TEXT1_I;
        if (value == "BodyText1I2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BODY_TEXT1_I2;
        if (value == "NoteHeading") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::NOTE_HEADING;
        if (value == "BodyText2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BODY_TEXT2;
        if (value == "BodyText3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BODY_TEXT3;
        if (value == "BodyTextInd2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BODY_TEXT_IND2;
        if (value == "BodyTextInd3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BODY_TEXT_IND3;
        if (value == "BlockText") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BLOCK_TEXT;
        if (value == "Hyperlink") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HYPERLINK;
        if (value == "FollowedHyperlink") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::FOLLOWED_HYPERLINK;
        if (value == "Strong") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::STRONG;
        if (value == "Emphasis") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::EMPHASIS;
        if (value == "DocumentMap") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DOCUMENT_MAP;
        if (value == "PlainText") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::PLAIN_TEXT;
        if (value == "EmailSignature") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::EMAIL_SIGNATURE;
        if (value == "HtmlTopOfForm") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_TOP_OF_FORM;
        if (value == "HtmlBottomOfForm") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_BOTTOM_OF_FORM;
        if (value == "NormalWeb") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::NORMAL_WEB;
        if (value == "HtmlAcronym") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_ACRONYM;
        if (value == "HtmlAddress") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_ADDRESS;
        if (value == "HtmlCite") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_CITE;
        if (value == "HtmlCode") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_CODE;
        if (value == "HtmlDefinition") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_DEFINITION;
        if (value == "HtmlKeyboard") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_KEYBOARD;
        if (value == "HtmlPreformatted") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_PREFORMATTED;
        if (value == "HtmlSample") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_SAMPLE;
        if (value == "HtmlTypewriter") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_TYPEWRITER;
        if (value == "HtmlVariable") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HTML_VARIABLE;
        if (value == "TableNormal") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_NORMAL;
        if (value == "CommentSubject") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COMMENT_SUBJECT;
        if (value == "NoList") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::NO_LIST;
        if (value == "OutlineList1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::OUTLINE_LIST1;
        if (value == "OutlineList2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::OUTLINE_LIST2;
        if (value == "OutlineList3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::OUTLINE_LIST3;
        if (value == "TableSimple1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_SIMPLE1;
        if (value == "TableSimple2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_SIMPLE2;
        if (value == "TableSimple3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_SIMPLE3;
        if (value == "TableClassic1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_CLASSIC1;
        if (value == "TableClassic2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_CLASSIC2;
        if (value == "TableClassic3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_CLASSIC3;
        if (value == "TableClassic4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_CLASSIC4;
        if (value == "TableColorful1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_COLORFUL1;
        if (value == "TableColorful2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_COLORFUL2;
        if (value == "TableColorful3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_COLORFUL3;
        if (value == "TableColumns1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_COLUMNS1;
        if (value == "TableColumns2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_COLUMNS2;
        if (value == "TableColumns3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_COLUMNS3;
        if (value == "TableColumns4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_COLUMNS4;
        if (value == "TableColumns5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_COLUMNS5;
        if (value == "TableGrid1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID1;
        if (value == "TableGrid2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID2;
        if (value == "TableGrid3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID3;
        if (value == "TableGrid4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID4;
        if (value == "TableGrid5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID5;
        if (value == "TableGrid6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID6;
        if (value == "TableGrid7") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID7;
        if (value == "TableGrid8") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID8;
        if (value == "TableList1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_LIST1;
        if (value == "TableList2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_LIST2;
        if (value == "TableList3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_LIST3;
        if (value == "TableList4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_LIST4;
        if (value == "TableList5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_LIST5;
        if (value == "TableList6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_LIST6;
        if (value == "TableList7") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_LIST7;
        if (value == "TableList8") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_LIST8;
        if (value == "Table3DEffects1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE3_D_EFFECTS1;
        if (value == "Table3DEffects2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE3_D_EFFECTS2;
        if (value == "Table3DEffects3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE3_D_EFFECTS3;
        if (value == "TableContemporary") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_CONTEMPORARY;
        if (value == "TableElegant") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_ELEGANT;
        if (value == "TableProfessional") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_PROFESSIONAL;
        if (value == "TableSubtle1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_SUBTLE1;
        if (value == "TableSubtle2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_SUBTLE2;
        if (value == "TableWeb1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_WEB1;
        if (value == "TableWeb2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_WEB2;
        if (value == "TableWeb3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_WEB3;
        if (value == "BalloonText") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BALLOON_TEXT;
        if (value == "TableGrid") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID;
        if (value == "TableTheme") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_THEME;
        if (value == "PlaceholderText") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::PLACEHOLDER_TEXT;
        if (value == "NoSpacing") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::NO_SPACING;
        if (value == "LightShading") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_SHADING;
        if (value == "LightList") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_LIST;
        if (value == "LightGrid") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_GRID;
        if (value == "MediumShading1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING1;
        if (value == "MediumShading2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING2;
        if (value == "MediumList1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST1;
        if (value == "MediumList2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST2;
        if (value == "MediumGrid1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID1;
        if (value == "MediumGrid2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID2;
        if (value == "MediumGrid3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID3;
        if (value == "DarkList") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DARK_LIST;
        if (value == "ColorfulShading") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_SHADING;
        if (value == "ColorfulList") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_LIST;
        if (value == "ColorfulGrid") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_GRID;
        if (value == "LightShadingAccent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_SHADING_ACCENT1;
        if (value == "LightListAccent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_LIST_ACCENT1;
        if (value == "LightGridAccent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_GRID_ACCENT1;
        if (value == "MediumShading1Accent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING1_ACCENT1;
        if (value == "MediumShading2Accent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING2_ACCENT1;
        if (value == "MediumList1Accent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST1_ACCENT1;
        if (value == "Revision") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::REVISION;
        if (value == "ListParagraph") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_PARAGRAPH;
        if (value == "Quote") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::QUOTE;
        if (value == "IntenseQuote") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INTENSE_QUOTE;
        if (value == "MediumList2Accent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST2_ACCENT1;
        if (value == "MediumGrid1Accent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID1_ACCENT1;
        if (value == "MediumGrid2Accent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID2_ACCENT1;
        if (value == "MediumGrid3Accent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID3_ACCENT1;
        if (value == "DarkListAccent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DARK_LIST_ACCENT1;
        if (value == "ColorfulShadingAccent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_SHADING_ACCENT1;
        if (value == "ColorfulListAccent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_LIST_ACCENT1;
        if (value == "ColorfulGridAccent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_GRID_ACCENT1;
        if (value == "LightShadingAccent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_SHADING_ACCENT2;
        if (value == "LightListAccent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_LIST_ACCENT2;
        if (value == "LightGridAccent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_GRID_ACCENT2;
        if (value == "MediumShading1Accent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING1_ACCENT2;
        if (value == "MediumShading2Accent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING2_ACCENT2;
        if (value == "MediumList1Accent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST1_ACCENT2;
        if (value == "MediumList2Accent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST2_ACCENT2;
        if (value == "MediumGrid1Accent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID1_ACCENT2;
        if (value == "MediumGrid2Accent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID2_ACCENT2;
        if (value == "MediumGrid3Accent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID3_ACCENT2;
        if (value == "DarkListAccent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DARK_LIST_ACCENT2;
        if (value == "ColorfulShadingAccent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_SHADING_ACCENT2;
        if (value == "ColorfulListAccent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_LIST_ACCENT2;
        if (value == "ColorfulGridAccent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_GRID_ACCENT2;
        if (value == "LightShadingAccent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_SHADING_ACCENT3;
        if (value == "LightListAccent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_LIST_ACCENT3;
        if (value == "LightGridAccent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_GRID_ACCENT3;
        if (value == "MediumShading1Accent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING1_ACCENT3;
        if (value == "MediumShading2Accent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING2_ACCENT3;
        if (value == "MediumList1Accent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST1_ACCENT3;
        if (value == "MediumList2Accent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST2_ACCENT3;
        if (value == "MediumGrid1Accent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID1_ACCENT3;
        if (value == "MediumGrid2Accent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID2_ACCENT3;
        if (value == "MediumGrid3Accent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID3_ACCENT3;
        if (value == "DarkListAccent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DARK_LIST_ACCENT3;
        if (value == "ColorfulShadingAccent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_SHADING_ACCENT3;
        if (value == "ColorfulListAccent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_LIST_ACCENT3;
        if (value == "ColorfulGridAccent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_GRID_ACCENT3;
        if (value == "LightShadingAccent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_SHADING_ACCENT4;
        if (value == "LightListAccent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_LIST_ACCENT4;
        if (value == "LightGridAccent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_GRID_ACCENT4;
        if (value == "MediumShading1Accent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING1_ACCENT4;
        if (value == "MediumShading2Accent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING2_ACCENT4;
        if (value == "MediumList1Accent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST1_ACCENT4;
        if (value == "MediumList2Accent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST2_ACCENT4;
        if (value == "MediumGrid1Accent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID1_ACCENT4;
        if (value == "MediumGrid2Accent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID2_ACCENT4;
        if (value == "MediumGrid3Accent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID3_ACCENT4;
        if (value == "DarkListAccent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DARK_LIST_ACCENT4;
        if (value == "ColorfulShadingAccent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_SHADING_ACCENT4;
        if (value == "ColorfulListAccent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_LIST_ACCENT4;
        if (value == "ColorfulGridAccent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_GRID_ACCENT4;
        if (value == "LightShadingAccent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_SHADING_ACCENT5;
        if (value == "LightListAccent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_LIST_ACCENT5;
        if (value == "LightGridAccent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_GRID_ACCENT5;
        if (value == "MediumShading1Accent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING1_ACCENT5;
        if (value == "MediumShading2Accent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING2_ACCENT5;
        if (value == "MediumList1Accent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST1_ACCENT5;
        if (value == "MediumList2Accent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST2_ACCENT5;
        if (value == "MediumGrid1Accent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID1_ACCENT5;
        if (value == "MediumGrid2Accent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID2_ACCENT5;
        if (value == "MediumGrid3Accent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID3_ACCENT5;
        if (value == "DarkListAccent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DARK_LIST_ACCENT5;
        if (value == "ColorfulShadingAccent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_SHADING_ACCENT5;
        if (value == "ColorfulListAccent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_LIST_ACCENT5;
        if (value == "ColorfulGridAccent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_GRID_ACCENT5;
        if (value == "LightShadingAccent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_SHADING_ACCENT6;
        if (value == "LightListAccent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_LIST_ACCENT6;
        if (value == "LightGridAccent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIGHT_GRID_ACCENT6;
        if (value == "MediumShading1Accent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING1_ACCENT6;
        if (value == "MediumShading2Accent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_SHADING2_ACCENT6;
        if (value == "MediumList1Accent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST1_ACCENT6;
        if (value == "MediumList2Accent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_LIST2_ACCENT6;
        if (value == "MediumGrid1Accent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID1_ACCENT6;
        if (value == "MediumGrid2Accent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID2_ACCENT6;
        if (value == "MediumGrid3Accent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MEDIUM_GRID3_ACCENT6;
        if (value == "DarkListAccent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::DARK_LIST_ACCENT6;
        if (value == "ColorfulShadingAccent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_SHADING_ACCENT6;
        if (value == "ColorfulListAccent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_LIST_ACCENT6;
        if (value == "ColorfulGridAccent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::COLORFUL_GRID_ACCENT6;
        if (value == "SubtleEmphasis") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::SUBTLE_EMPHASIS;
        if (value == "IntenseEmphasis") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INTENSE_EMPHASIS;
        if (value == "SubtleReference") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::SUBTLE_REFERENCE;
        if (value == "IntenseReference") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::INTENSE_REFERENCE;
        if (value == "BookTitle") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BOOK_TITLE;
        if (value == "Bibliography") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::BIBLIOGRAPHY;
        if (value == "TocHeading") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TOC_HEADING;
        if (value == "PlainTable1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::PLAIN_TABLE1;
        if (value == "PlainTable2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::PLAIN_TABLE2;
        if (value == "PlainTable3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::PLAIN_TABLE3;
        if (value == "PlainTable4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::PLAIN_TABLE4;
        if (value == "PlainTable5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::PLAIN_TABLE5;
        if (value == "TableGridLight") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::TABLE_GRID_LIGHT;
        if (value == "GridTable1Light") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE1_LIGHT;
        if (value == "GridTable2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE2;
        if (value == "GridTable3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE3;
        if (value == "GridTable4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE4;
        if (value == "GridTable5Dark") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE5_DARK;
        if (value == "GridTable6Colorful") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE6_COLORFUL;
        if (value == "GridTable7Colorful") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE7_COLORFUL;
        if (value == "GridTable1LightAccent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT1;
        if (value == "GridTable2Accent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE2_ACCENT1;
        if (value == "GridTable3Accent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE3_ACCENT1;
        if (value == "GridTable4Accent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE4_ACCENT1;
        if (value == "GridTable5DarkAccent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE5_DARK_ACCENT1;
        if (value == "GridTable6ColorfulAccent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT1;
        if (value == "GridTable7ColorfulAccent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT1;
        if (value == "GridTable1LightAccent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT2;
        if (value == "GridTable2Accent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE2_ACCENT2;
        if (value == "GridTable3Accent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE3_ACCENT2;
        if (value == "GridTable4Accent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE4_ACCENT2;
        if (value == "GridTable5DarkAccent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE5_DARK_ACCENT2;
        if (value == "GridTable6ColorfulAccent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT2;
        if (value == "GridTable7ColorfulAccent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT2;
        if (value == "GridTable1LightAccent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT3;
        if (value == "GridTable2Accent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE2_ACCENT3;
        if (value == "GridTable3Accent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE3_ACCENT3;
        if (value == "GridTable4Accent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE4_ACCENT3;
        if (value == "GridTable5DarkAccent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE5_DARK_ACCENT3;
        if (value == "GridTable6ColorfulAccent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT3;
        if (value == "GridTable7ColorfulAccent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT3;
        if (value == "GridTable1LightAccent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT4;
        if (value == "GridTable2Accent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE2_ACCENT4;
        if (value == "GridTable3Accent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE3_ACCENT4;
        if (value == "GridTable4Accent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE4_ACCENT4;
        if (value == "GridTable5DarkAccent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE5_DARK_ACCENT4;
        if (value == "GridTable6ColorfulAccent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT4;
        if (value == "GridTable7ColorfulAccent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT4;
        if (value == "GridTable1LightAccent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT5;
        if (value == "GridTable2Accent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE2_ACCENT5;
        if (value == "GridTable3Accent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE3_ACCENT5;
        if (value == "GridTable4Accent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE4_ACCENT5;
        if (value == "GridTable5DarkAccent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE5_DARK_ACCENT5;
        if (value == "GridTable6ColorfulAccent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT5;
        if (value == "GridTable7ColorfulAccent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT5;
        if (value == "GridTable1LightAccent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT6;
        if (value == "GridTable2Accent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE2_ACCENT6;
        if (value == "GridTable3Accent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE3_ACCENT6;
        if (value == "GridTable4Accent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE4_ACCENT6;
        if (value == "GridTable5DarkAccent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE5_DARK_ACCENT6;
        if (value == "GridTable6ColorfulAccent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT6;
        if (value == "GridTable7ColorfulAccent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT6;
        if (value == "ListTable1Light") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE1_LIGHT;
        if (value == "ListTable2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE2;
        if (value == "ListTable3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE3;
        if (value == "ListTable4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE4;
        if (value == "ListTable5Dark") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE5_DARK;
        if (value == "ListTable6Colorful") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE6_COLORFUL;
        if (value == "ListTable7Colorful") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE7_COLORFUL;
        if (value == "ListTable1LightAccent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT1;
        if (value == "ListTable2Accent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE2_ACCENT1;
        if (value == "ListTable3Accent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE3_ACCENT1;
        if (value == "ListTable4Accent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE4_ACCENT1;
        if (value == "ListTable5DarkAccent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE5_DARK_ACCENT1;
        if (value == "ListTable6ColorfulAccent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT1;
        if (value == "ListTable7ColorfulAccent1") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT1;
        if (value == "ListTable1LightAccent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT2;
        if (value == "ListTable2Accent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE2_ACCENT2;
        if (value == "ListTable3Accent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE3_ACCENT2;
        if (value == "ListTable4Accent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE4_ACCENT2;
        if (value == "ListTable5DarkAccent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE5_DARK_ACCENT2;
        if (value == "ListTable6ColorfulAccent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT2;
        if (value == "ListTable7ColorfulAccent2") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT2;
        if (value == "ListTable1LightAccent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT3;
        if (value == "ListTable2Accent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE2_ACCENT3;
        if (value == "ListTable3Accent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE3_ACCENT3;
        if (value == "ListTable4Accent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE4_ACCENT3;
        if (value == "ListTable5DarkAccent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE5_DARK_ACCENT3;
        if (value == "ListTable6ColorfulAccent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT3;
        if (value == "ListTable7ColorfulAccent3") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT3;
        if (value == "ListTable1LightAccent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT4;
        if (value == "ListTable2Accent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE2_ACCENT4;
        if (value == "ListTable3Accent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE3_ACCENT4;
        if (value == "ListTable4Accent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE4_ACCENT4;
        if (value == "ListTable5DarkAccent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE5_DARK_ACCENT4;
        if (value == "ListTable6ColorfulAccent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT4;
        if (value == "ListTable7ColorfulAccent4") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT4;
        if (value == "ListTable1LightAccent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT5;
        if (value == "ListTable2Accent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE2_ACCENT5;
        if (value == "ListTable3Accent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE3_ACCENT5;
        if (value == "ListTable4Accent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE4_ACCENT5;
        if (value == "ListTable5DarkAccent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE5_DARK_ACCENT5;
        if (value == "ListTable6ColorfulAccent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT5;
        if (value == "ListTable7ColorfulAccent5") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT5;
        if (value == "ListTable1LightAccent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT6;
        if (value == "ListTable2Accent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE2_ACCENT6;
        if (value == "ListTable3Accent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE3_ACCENT6;
        if (value == "ListTable4Accent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE4_ACCENT6;
        if (value == "ListTable5DarkAccent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE5_DARK_ACCENT6;
        if (value == "ListTable6ColorfulAccent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT6;
        if (value == "ListTable7ColorfulAccent6") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT6;
        if (value == "SmartLink") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::SMART_LINK;
        if (value == "Mention") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::MENTION;
        if (value == "SmartHyperlink") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::SMART_HYPERLINK;
        if (value == "Hashtag") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::HASHTAG;
        if (value == "UnresolvedMention") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::UNRESOLVED_MENTION;
        if (value == "User") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::USER;
        if (value == "Nil") return aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier::NIL;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void ParagraphFormatBase::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_AddSpaceBetweenFarEastAndAlpha) {
            json["AddSpaceBetweenFarEastAndAlpha"] = *(this->m_AddSpaceBetweenFarEastAndAlpha);
        }
        if (this->m_AddSpaceBetweenFarEastAndDigit) {
            json["AddSpaceBetweenFarEastAndDigit"] = *(this->m_AddSpaceBetweenFarEastAndDigit);
        }
        if (this->m_Alignment) {
            json["Alignment"] = paragraphFormatBaseAlignmentToString(*(this->m_Alignment));
        }
        if (this->m_Bidi) {
            json["Bidi"] = *(this->m_Bidi);
        }
        if (this->m_DropCapPosition) {
            json["DropCapPosition"] = paragraphFormatBaseDropCapPositionToString(*(this->m_DropCapPosition));
        }
        if (this->m_FirstLineIndent) {
            json["FirstLineIndent"] = *(this->m_FirstLineIndent);
        }
        if (this->m_KeepTogether) {
            json["KeepTogether"] = *(this->m_KeepTogether);
        }
        if (this->m_KeepWithNext) {
            json["KeepWithNext"] = *(this->m_KeepWithNext);
        }
        if (this->m_LeftIndent) {
            json["LeftIndent"] = *(this->m_LeftIndent);
        }
        if (this->m_LineSpacing) {
            json["LineSpacing"] = *(this->m_LineSpacing);
        }
        if (this->m_LineSpacingRule) {
            json["LineSpacingRule"] = paragraphFormatBaseLineSpacingRuleToString(*(this->m_LineSpacingRule));
        }
        if (this->m_LinesToDrop) {
            json["LinesToDrop"] = *(this->m_LinesToDrop);
        }
        if (this->m_NoSpaceBetweenParagraphsOfSameStyle) {
            json["NoSpaceBetweenParagraphsOfSameStyle"] = *(this->m_NoSpaceBetweenParagraphsOfSameStyle);
        }
        if (this->m_OutlineLevel) {
            json["OutlineLevel"] = paragraphFormatBaseOutlineLevelToString(*(this->m_OutlineLevel));
        }
        if (this->m_PageBreakBefore) {
            json["PageBreakBefore"] = *(this->m_PageBreakBefore);
        }
        if (this->m_RightIndent) {
            json["RightIndent"] = *(this->m_RightIndent);
        }
        if (this->m_SpaceAfter) {
            json["SpaceAfter"] = *(this->m_SpaceAfter);
        }
        if (this->m_SpaceAfterAuto) {
            json["SpaceAfterAuto"] = *(this->m_SpaceAfterAuto);
        }
        if (this->m_SpaceBefore) {
            json["SpaceBefore"] = *(this->m_SpaceBefore);
        }
        if (this->m_SpaceBeforeAuto) {
            json["SpaceBeforeAuto"] = *(this->m_SpaceBeforeAuto);
        }
        if (this->m_StyleIdentifier) {
            json["StyleIdentifier"] = paragraphFormatBaseStyleIdentifierToString(*(this->m_StyleIdentifier));
        }
        if (this->m_StyleName) {
            json["StyleName"] = convertUtf16(*(this->m_StyleName));
        }
        if (this->m_SuppressAutoHyphens) {
            json["SuppressAutoHyphens"] = *(this->m_SuppressAutoHyphens);
        }
        if (this->m_SuppressLineNumbers) {
            json["SuppressLineNumbers"] = *(this->m_SuppressLineNumbers);
        }
        if (this->m_WidowControl) {
            json["WidowControl"] = *(this->m_WidowControl);
        }
        if (this->m_Shading) {
            this->m_Shading->toJson(&json["Shading"]);
        }
    }

    void ParagraphFormatBase::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("AddSpaceBetweenFarEastAndAlpha") && !json["AddSpaceBetweenFarEastAndAlpha"].is_null()) {
            this->m_AddSpaceBetweenFarEastAndAlpha = std::make_shared< bool >(
                json["AddSpaceBetweenFarEastAndAlpha"].get< bool >()
            );
        }
        if (json.contains("AddSpaceBetweenFarEastAndDigit") && !json["AddSpaceBetweenFarEastAndDigit"].is_null()) {
            this->m_AddSpaceBetweenFarEastAndDigit = std::make_shared< bool >(
                json["AddSpaceBetweenFarEastAndDigit"].get< bool >()
            );
        }
        if (json.contains("Alignment") && !json["Alignment"].is_null()) {
            this->m_Alignment = std::make_shared< aspose::words::cloud::models::ParagraphFormatBase::Alignment >(
                paragraphFormatBaseAlignmentFromString(json["Alignment"].get< std::string >())
            );
        }
        if (json.contains("Bidi") && !json["Bidi"].is_null()) {
            this->m_Bidi = std::make_shared< bool >(
                json["Bidi"].get< bool >()
            );
        }
        if (json.contains("DropCapPosition") && !json["DropCapPosition"].is_null()) {
            this->m_DropCapPosition = std::make_shared< aspose::words::cloud::models::ParagraphFormatBase::DropCapPosition >(
                paragraphFormatBaseDropCapPositionFromString(json["DropCapPosition"].get< std::string >())
            );
        }
        if (json.contains("FirstLineIndent") && !json["FirstLineIndent"].is_null()) {
            this->m_FirstLineIndent = std::make_shared< double >(
                json["FirstLineIndent"].get< double >()
            );
        }
        if (json.contains("KeepTogether") && !json["KeepTogether"].is_null()) {
            this->m_KeepTogether = std::make_shared< bool >(
                json["KeepTogether"].get< bool >()
            );
        }
        if (json.contains("KeepWithNext") && !json["KeepWithNext"].is_null()) {
            this->m_KeepWithNext = std::make_shared< bool >(
                json["KeepWithNext"].get< bool >()
            );
        }
        if (json.contains("LeftIndent") && !json["LeftIndent"].is_null()) {
            this->m_LeftIndent = std::make_shared< double >(
                json["LeftIndent"].get< double >()
            );
        }
        if (json.contains("LineSpacing") && !json["LineSpacing"].is_null()) {
            this->m_LineSpacing = std::make_shared< double >(
                json["LineSpacing"].get< double >()
            );
        }
        if (json.contains("LineSpacingRule") && !json["LineSpacingRule"].is_null()) {
            this->m_LineSpacingRule = std::make_shared< aspose::words::cloud::models::ParagraphFormatBase::LineSpacingRule >(
                paragraphFormatBaseLineSpacingRuleFromString(json["LineSpacingRule"].get< std::string >())
            );
        }
        if (json.contains("LinesToDrop") && !json["LinesToDrop"].is_null()) {
            this->m_LinesToDrop = std::make_shared< int32_t >(
                json["LinesToDrop"].get< int32_t >()
            );
        }
        if (json.contains("NoSpaceBetweenParagraphsOfSameStyle") && !json["NoSpaceBetweenParagraphsOfSameStyle"].is_null()) {
            this->m_NoSpaceBetweenParagraphsOfSameStyle = std::make_shared< bool >(
                json["NoSpaceBetweenParagraphsOfSameStyle"].get< bool >()
            );
        }
        if (json.contains("OutlineLevel") && !json["OutlineLevel"].is_null()) {
            this->m_OutlineLevel = std::make_shared< aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel >(
                paragraphFormatBaseOutlineLevelFromString(json["OutlineLevel"].get< std::string >())
            );
        }
        if (json.contains("PageBreakBefore") && !json["PageBreakBefore"].is_null()) {
            this->m_PageBreakBefore = std::make_shared< bool >(
                json["PageBreakBefore"].get< bool >()
            );
        }
        if (json.contains("RightIndent") && !json["RightIndent"].is_null()) {
            this->m_RightIndent = std::make_shared< double >(
                json["RightIndent"].get< double >()
            );
        }
        if (json.contains("SpaceAfter") && !json["SpaceAfter"].is_null()) {
            this->m_SpaceAfter = std::make_shared< double >(
                json["SpaceAfter"].get< double >()
            );
        }
        if (json.contains("SpaceAfterAuto") && !json["SpaceAfterAuto"].is_null()) {
            this->m_SpaceAfterAuto = std::make_shared< bool >(
                json["SpaceAfterAuto"].get< bool >()
            );
        }
        if (json.contains("SpaceBefore") && !json["SpaceBefore"].is_null()) {
            this->m_SpaceBefore = std::make_shared< double >(
                json["SpaceBefore"].get< double >()
            );
        }
        if (json.contains("SpaceBeforeAuto") && !json["SpaceBeforeAuto"].is_null()) {
            this->m_SpaceBeforeAuto = std::make_shared< bool >(
                json["SpaceBeforeAuto"].get< bool >()
            );
        }
        if (json.contains("StyleIdentifier") && !json["StyleIdentifier"].is_null()) {
            this->m_StyleIdentifier = std::make_shared< aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier >(
                paragraphFormatBaseStyleIdentifierFromString(json["StyleIdentifier"].get< std::string >())
            );
        }
        if (json.contains("StyleName") && !json["StyleName"].is_null()) {
            this->m_StyleName = std::make_shared< std::wstring >(
                convertUtf8( json["StyleName"].get< std::string >() )
            );
        }
        if (json.contains("SuppressAutoHyphens") && !json["SuppressAutoHyphens"].is_null()) {
            this->m_SuppressAutoHyphens = std::make_shared< bool >(
                json["SuppressAutoHyphens"].get< bool >()
            );
        }
        if (json.contains("SuppressLineNumbers") && !json["SuppressLineNumbers"].is_null()) {
            this->m_SuppressLineNumbers = std::make_shared< bool >(
                json["SuppressLineNumbers"].get< bool >()
            );
        }
        if (json.contains("WidowControl") && !json["WidowControl"].is_null()) {
            this->m_WidowControl = std::make_shared< bool >(
                json["WidowControl"].get< bool >()
            );
        }
        if (json.contains("Shading") && !json["Shading"].is_null()) {
            this->m_Shading = createModelInstance< aspose::words::cloud::models::Shading >(L"Shading, _", json["Shading"]);
        }
    }

    void ParagraphFormatBase::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ParagraphFormatBase::validate()
    {
        LinkElement::validate();

        if (this->m_Shading != nullptr)
        {
            this->m_Shading->validate();
        }

    }

    std::shared_ptr< bool > ParagraphFormatBase::getAddSpaceBetweenFarEastAndAlpha() const
    {
        return this->m_AddSpaceBetweenFarEastAndAlpha;
    }

    void ParagraphFormatBase::setAddSpaceBetweenFarEastAndAlpha(std::shared_ptr< bool > value)
    {
        this->m_AddSpaceBetweenFarEastAndAlpha = value;
    }


    std::shared_ptr< bool > ParagraphFormatBase::getAddSpaceBetweenFarEastAndDigit() const
    {
        return this->m_AddSpaceBetweenFarEastAndDigit;
    }

    void ParagraphFormatBase::setAddSpaceBetweenFarEastAndDigit(std::shared_ptr< bool > value)
    {
        this->m_AddSpaceBetweenFarEastAndDigit = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ParagraphFormatBase::Alignment > ParagraphFormatBase::getAlignment() const
    {
        return this->m_Alignment;
    }

    void ParagraphFormatBase::setAlignment(std::shared_ptr< aspose::words::cloud::models::ParagraphFormatBase::Alignment > value)
    {
        this->m_Alignment = value;
    }


    std::shared_ptr< bool > ParagraphFormatBase::getBidi() const
    {
        return this->m_Bidi;
    }

    void ParagraphFormatBase::setBidi(std::shared_ptr< bool > value)
    {
        this->m_Bidi = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ParagraphFormatBase::DropCapPosition > ParagraphFormatBase::getDropCapPosition() const
    {
        return this->m_DropCapPosition;
    }

    void ParagraphFormatBase::setDropCapPosition(std::shared_ptr< aspose::words::cloud::models::ParagraphFormatBase::DropCapPosition > value)
    {
        this->m_DropCapPosition = value;
    }


    std::shared_ptr< double > ParagraphFormatBase::getFirstLineIndent() const
    {
        return this->m_FirstLineIndent;
    }

    void ParagraphFormatBase::setFirstLineIndent(std::shared_ptr< double > value)
    {
        this->m_FirstLineIndent = value;
    }


    std::shared_ptr< bool > ParagraphFormatBase::getKeepTogether() const
    {
        return this->m_KeepTogether;
    }

    void ParagraphFormatBase::setKeepTogether(std::shared_ptr< bool > value)
    {
        this->m_KeepTogether = value;
    }


    std::shared_ptr< bool > ParagraphFormatBase::getKeepWithNext() const
    {
        return this->m_KeepWithNext;
    }

    void ParagraphFormatBase::setKeepWithNext(std::shared_ptr< bool > value)
    {
        this->m_KeepWithNext = value;
    }


    std::shared_ptr< double > ParagraphFormatBase::getLeftIndent() const
    {
        return this->m_LeftIndent;
    }

    void ParagraphFormatBase::setLeftIndent(std::shared_ptr< double > value)
    {
        this->m_LeftIndent = value;
    }


    std::shared_ptr< double > ParagraphFormatBase::getLineSpacing() const
    {
        return this->m_LineSpacing;
    }

    void ParagraphFormatBase::setLineSpacing(std::shared_ptr< double > value)
    {
        this->m_LineSpacing = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ParagraphFormatBase::LineSpacingRule > ParagraphFormatBase::getLineSpacingRule() const
    {
        return this->m_LineSpacingRule;
    }

    void ParagraphFormatBase::setLineSpacingRule(std::shared_ptr< aspose::words::cloud::models::ParagraphFormatBase::LineSpacingRule > value)
    {
        this->m_LineSpacingRule = value;
    }


    std::shared_ptr< int32_t > ParagraphFormatBase::getLinesToDrop() const
    {
        return this->m_LinesToDrop;
    }

    void ParagraphFormatBase::setLinesToDrop(std::shared_ptr< int32_t > value)
    {
        this->m_LinesToDrop = value;
    }


    std::shared_ptr< bool > ParagraphFormatBase::getNoSpaceBetweenParagraphsOfSameStyle() const
    {
        return this->m_NoSpaceBetweenParagraphsOfSameStyle;
    }

    void ParagraphFormatBase::setNoSpaceBetweenParagraphsOfSameStyle(std::shared_ptr< bool > value)
    {
        this->m_NoSpaceBetweenParagraphsOfSameStyle = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel > ParagraphFormatBase::getOutlineLevel() const
    {
        return this->m_OutlineLevel;
    }

    void ParagraphFormatBase::setOutlineLevel(std::shared_ptr< aspose::words::cloud::models::ParagraphFormatBase::OutlineLevel > value)
    {
        this->m_OutlineLevel = value;
    }


    std::shared_ptr< bool > ParagraphFormatBase::getPageBreakBefore() const
    {
        return this->m_PageBreakBefore;
    }

    void ParagraphFormatBase::setPageBreakBefore(std::shared_ptr< bool > value)
    {
        this->m_PageBreakBefore = value;
    }


    std::shared_ptr< double > ParagraphFormatBase::getRightIndent() const
    {
        return this->m_RightIndent;
    }

    void ParagraphFormatBase::setRightIndent(std::shared_ptr< double > value)
    {
        this->m_RightIndent = value;
    }


    std::shared_ptr< double > ParagraphFormatBase::getSpaceAfter() const
    {
        return this->m_SpaceAfter;
    }

    void ParagraphFormatBase::setSpaceAfter(std::shared_ptr< double > value)
    {
        this->m_SpaceAfter = value;
    }


    std::shared_ptr< bool > ParagraphFormatBase::getSpaceAfterAuto() const
    {
        return this->m_SpaceAfterAuto;
    }

    void ParagraphFormatBase::setSpaceAfterAuto(std::shared_ptr< bool > value)
    {
        this->m_SpaceAfterAuto = value;
    }


    std::shared_ptr< double > ParagraphFormatBase::getSpaceBefore() const
    {
        return this->m_SpaceBefore;
    }

    void ParagraphFormatBase::setSpaceBefore(std::shared_ptr< double > value)
    {
        this->m_SpaceBefore = value;
    }


    std::shared_ptr< bool > ParagraphFormatBase::getSpaceBeforeAuto() const
    {
        return this->m_SpaceBeforeAuto;
    }

    void ParagraphFormatBase::setSpaceBeforeAuto(std::shared_ptr< bool > value)
    {
        this->m_SpaceBeforeAuto = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier > ParagraphFormatBase::getStyleIdentifier() const
    {
        return this->m_StyleIdentifier;
    }

    void ParagraphFormatBase::setStyleIdentifier(std::shared_ptr< aspose::words::cloud::models::ParagraphFormatBase::StyleIdentifier > value)
    {
        this->m_StyleIdentifier = value;
    }


    std::shared_ptr< std::wstring > ParagraphFormatBase::getStyleName() const
    {
        return this->m_StyleName;
    }

    void ParagraphFormatBase::setStyleName(std::shared_ptr< std::wstring > value)
    {
        this->m_StyleName = value;
    }


    std::shared_ptr< bool > ParagraphFormatBase::getSuppressAutoHyphens() const
    {
        return this->m_SuppressAutoHyphens;
    }

    void ParagraphFormatBase::setSuppressAutoHyphens(std::shared_ptr< bool > value)
    {
        this->m_SuppressAutoHyphens = value;
    }


    std::shared_ptr< bool > ParagraphFormatBase::getSuppressLineNumbers() const
    {
        return this->m_SuppressLineNumbers;
    }

    void ParagraphFormatBase::setSuppressLineNumbers(std::shared_ptr< bool > value)
    {
        this->m_SuppressLineNumbers = value;
    }


    std::shared_ptr< bool > ParagraphFormatBase::getWidowControl() const
    {
        return this->m_WidowControl;
    }

    void ParagraphFormatBase::setWidowControl(std::shared_ptr< bool > value)
    {
        this->m_WidowControl = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Shading > ParagraphFormatBase::getShading() const
    {
        return this->m_Shading;
    }

    void ParagraphFormatBase::setShading(std::shared_ptr< aspose::words::cloud::models::Shading > value)
    {
        this->m_Shading = value;
    }



    /*
     * ParagraphFormatResponse implementation
     */
    void ParagraphFormatResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ParagraphFormat) {
            this->m_ParagraphFormat->toJson(&json["ParagraphFormat"]);
        }
    }

    void ParagraphFormatResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ParagraphFormat") && !json["ParagraphFormat"].is_null()) {
            this->m_ParagraphFormat = createModelInstance< aspose::words::cloud::models::ParagraphFormat >(L"ParagraphFormat, _", json["ParagraphFormat"]);
        }
    }

    void ParagraphFormatResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ParagraphFormatResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_ParagraphFormat != nullptr)
        {
            this->m_ParagraphFormat->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::ParagraphFormat > ParagraphFormatResponse::getParagraphFormat() const
    {
        return this->m_ParagraphFormat;
    }

    void ParagraphFormatResponse::setParagraphFormat(std::shared_ptr< aspose::words::cloud::models::ParagraphFormat > value)
    {
        this->m_ParagraphFormat = value;
    }



    /*
     * ParagraphFormatUpdate implementation
     */
    void ParagraphFormatUpdate::toJson(void* jsonIfc) const
    {
        ParagraphFormatBase::toJson(jsonIfc);
    }

    void ParagraphFormatUpdate::fromJson(const void* jsonIfc)
    {
        ParagraphFormatBase::fromJson(jsonIfc);
    }

    void ParagraphFormatUpdate::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ParagraphFormatUpdate::validate()
    {
        ParagraphFormatBase::validate();
    }




    /*
     * ParagraphInsert implementation
     */
    void ParagraphInsert::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Text) {
            json["Text"] = convertUtf16(*(this->m_Text));
        }
        if (this->m_Position) {
            this->m_Position->toJson(&json["Position"]);
        }
    }

    void ParagraphInsert::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Text") && !json["Text"].is_null()) {
            this->m_Text = std::make_shared< std::wstring >(
                convertUtf8( json["Text"].get< std::string >() )
            );
        }
        if (json.contains("Position") && !json["Position"].is_null()) {
            this->m_Position = createModelInstance< aspose::words::cloud::models::Position >(L"Position, _", json["Position"]);
        }
    }

    void ParagraphInsert::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ParagraphInsert::validate()
    {
        if (this->m_Text == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Text in ParagraphInsert is required.");
        }


        if (this->m_Position != nullptr)
        {
            this->m_Position->validate();
        }

    }

    std::shared_ptr< std::wstring > ParagraphInsert::getText() const
    {
        return this->m_Text;
    }

    void ParagraphInsert::setText(std::shared_ptr< std::wstring > value)
    {
        this->m_Text = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Position > ParagraphInsert::getPosition() const
    {
        return this->m_Position;
    }

    void ParagraphInsert::setPosition(std::shared_ptr< aspose::words::cloud::models::Position > value)
    {
        this->m_Position = value;
    }



    /*
     * ParagraphLink implementation
     */
    void ParagraphLink::toJson(void* jsonIfc) const
    {
        NodeLink::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Text) {
            json["Text"] = convertUtf16(*(this->m_Text));
        }
    }

    void ParagraphLink::fromJson(const void* jsonIfc)
    {
        NodeLink::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Text") && !json["Text"].is_null()) {
            this->m_Text = std::make_shared< std::wstring >(
                convertUtf8( json["Text"].get< std::string >() )
            );
        }
    }

    void ParagraphLink::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ParagraphLink::validate()
    {
        NodeLink::validate();
    }

    std::shared_ptr< std::wstring > ParagraphLink::getText() const
    {
        return this->m_Text;
    }

    void ParagraphLink::setText(std::shared_ptr< std::wstring > value)
    {
        this->m_Text = value;
    }



    /*
     * ParagraphLinkCollection implementation
     */
    void ParagraphLinkCollection::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ParagraphLinkList) {
            json["ParagraphLinkList"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_ParagraphLinkList)) {
                element->toJson(&json["ParagraphLinkList"].emplace_back());
            }
        }
    }

    void ParagraphLinkCollection::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ParagraphLinkList") && !json["ParagraphLinkList"].is_null()) {
            this->m_ParagraphLinkList = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::ParagraphLink>> >();
            for (auto& element : json["ParagraphLinkList"]) {
                this->m_ParagraphLinkList->emplace_back(createModelInstance< aspose::words::cloud::models::ParagraphLink >(L"ParagraphLink, _", element));
            }
        }
    }

    void ParagraphLinkCollection::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ParagraphLinkCollection::validate()
    {
        LinkElement::validate();

        if (this->m_ParagraphLinkList != nullptr)
        {
            for (auto& elementParagraphLinkList : *(this->m_ParagraphLinkList))
            {
                if (elementParagraphLinkList != nullptr)
                {
                    elementParagraphLinkList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::ParagraphLink>> > ParagraphLinkCollection::getParagraphLinkList() const
    {
        return this->m_ParagraphLinkList;
    }

    void ParagraphLinkCollection::setParagraphLinkList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::ParagraphLink>> > value)
    {
        this->m_ParagraphLinkList = value;
    }



    /*
     * ParagraphLinkCollectionResponse implementation
     */
    void ParagraphLinkCollectionResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Paragraphs) {
            this->m_Paragraphs->toJson(&json["Paragraphs"]);
        }
    }

    void ParagraphLinkCollectionResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Paragraphs") && !json["Paragraphs"].is_null()) {
            this->m_Paragraphs = createModelInstance< aspose::words::cloud::models::ParagraphLinkCollection >(L"ParagraphLinkCollection, _", json["Paragraphs"]);
        }
    }

    void ParagraphLinkCollectionResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ParagraphLinkCollectionResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Paragraphs != nullptr)
        {
            this->m_Paragraphs->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::ParagraphLinkCollection > ParagraphLinkCollectionResponse::getParagraphs() const
    {
        return this->m_Paragraphs;
    }

    void ParagraphLinkCollectionResponse::setParagraphs(std::shared_ptr< aspose::words::cloud::models::ParagraphLinkCollection > value)
    {
        this->m_Paragraphs = value;
    }



    /*
     * ParagraphListFormatResponse implementation
     */
    void ParagraphListFormatResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ListFormat) {
            this->m_ListFormat->toJson(&json["ListFormat"]);
        }
    }

    void ParagraphListFormatResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ListFormat") && !json["ListFormat"].is_null()) {
            this->m_ListFormat = createModelInstance< aspose::words::cloud::models::ListFormat >(L"ListFormat, _", json["ListFormat"]);
        }
    }

    void ParagraphListFormatResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ParagraphListFormatResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_ListFormat != nullptr)
        {
            this->m_ListFormat->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::ListFormat > ParagraphListFormatResponse::getListFormat() const
    {
        return this->m_ListFormat;
    }

    void ParagraphListFormatResponse::setListFormat(std::shared_ptr< aspose::words::cloud::models::ListFormat > value)
    {
        this->m_ListFormat = value;
    }



    /*
     * ParagraphResponse implementation
     */
    void ParagraphResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Paragraph) {
            this->m_Paragraph->toJson(&json["Paragraph"]);
        }
    }

    void ParagraphResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Paragraph") && !json["Paragraph"].is_null()) {
            this->m_Paragraph = createModelInstance< aspose::words::cloud::models::Paragraph >(L"Paragraph, _", json["Paragraph"]);
        }
    }

    void ParagraphResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ParagraphResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Paragraph != nullptr)
        {
            this->m_Paragraph->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Paragraph > ParagraphResponse::getParagraph() const
    {
        return this->m_Paragraph;
    }

    void ParagraphResponse::setParagraph(std::shared_ptr< aspose::words::cloud::models::Paragraph > value)
    {
        this->m_Paragraph = value;
    }



    /*
     * PclSaveOptionsData implementation
     */
    void PclSaveOptionsData::toJson(void* jsonIfc) const
    {
        FixedPageSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_FalllbackFontName) {
            json["FalllbackFontName"] = convertUtf16(*(this->m_FalllbackFontName));
        }
        if (this->m_RasterizeTransformedElements) {
            json["RasterizeTransformedElements"] = *(this->m_RasterizeTransformedElements);
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void PclSaveOptionsData::fromJson(const void* jsonIfc)
    {
        FixedPageSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("FalllbackFontName") && !json["FalllbackFontName"].is_null()) {
            this->m_FalllbackFontName = std::make_shared< std::wstring >(
                convertUtf8( json["FalllbackFontName"].get< std::string >() )
            );
        }
        if (json.contains("RasterizeTransformedElements") && !json["RasterizeTransformedElements"].is_null()) {
            this->m_RasterizeTransformedElements = std::make_shared< bool >(
                json["RasterizeTransformedElements"].get< bool >()
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void PclSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void PclSaveOptionsData::validate()
    {
        FixedPageSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > PclSaveOptionsData::getFalllbackFontName() const
    {
        return this->m_FalllbackFontName;
    }

    void PclSaveOptionsData::setFalllbackFontName(std::shared_ptr< std::wstring > value)
    {
        this->m_FalllbackFontName = value;
    }


    std::shared_ptr< bool > PclSaveOptionsData::getRasterizeTransformedElements() const
    {
        return this->m_RasterizeTransformedElements;
    }

    void PclSaveOptionsData::setRasterizeTransformedElements(std::shared_ptr< bool > value)
    {
        this->m_RasterizeTransformedElements = value;
    }


    std::shared_ptr< std::wstring > PclSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * PdfDigitalSignatureDetailsData implementation
     */
    inline std::string pdfDigitalSignatureDetailsDataHashAlgorithmToString(aspose::words::cloud::models::PdfDigitalSignatureDetailsData::HashAlgorithm value)
    {
        if (value == aspose::words::cloud::models::PdfDigitalSignatureDetailsData::HashAlgorithm::SHA256) return "Sha256";
        if (value == aspose::words::cloud::models::PdfDigitalSignatureDetailsData::HashAlgorithm::SHA384) return "Sha384";
        if (value == aspose::words::cloud::models::PdfDigitalSignatureDetailsData::HashAlgorithm::SHA512) return "Sha512";
        if (value == aspose::words::cloud::models::PdfDigitalSignatureDetailsData::HashAlgorithm::RIPE_M_D160) return "RipeMD160";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PdfDigitalSignatureDetailsData::HashAlgorithm pdfDigitalSignatureDetailsDataHashAlgorithmFromString(const std::string& value)
    {
        if (value == "Sha256") return aspose::words::cloud::models::PdfDigitalSignatureDetailsData::HashAlgorithm::SHA256;
        if (value == "Sha384") return aspose::words::cloud::models::PdfDigitalSignatureDetailsData::HashAlgorithm::SHA384;
        if (value == "Sha512") return aspose::words::cloud::models::PdfDigitalSignatureDetailsData::HashAlgorithm::SHA512;
        if (value == "RipeMD160") return aspose::words::cloud::models::PdfDigitalSignatureDetailsData::HashAlgorithm::RIPE_M_D160;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void PdfDigitalSignatureDetailsData::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_CertificateFilename) {
            json["CertificateFilename"] = convertUtf16(*(this->m_CertificateFilename));
        }
        if (this->m_HashAlgorithm) {
            json["HashAlgorithm"] = pdfDigitalSignatureDetailsDataHashAlgorithmToString(*(this->m_HashAlgorithm));
        }
        if (this->m_Location) {
            json["Location"] = convertUtf16(*(this->m_Location));
        }
        if (this->m_Reason) {
            json["Reason"] = convertUtf16(*(this->m_Reason));
        }
        if (this->m_SignatureDate) {
            json["SignatureDate"] = convertUtf16(*(this->m_SignatureDate));
        }
    }

    void PdfDigitalSignatureDetailsData::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("CertificateFilename") && !json["CertificateFilename"].is_null()) {
            this->m_CertificateFilename = std::make_shared< std::wstring >(
                convertUtf8( json["CertificateFilename"].get< std::string >() )
            );
        }
        if (json.contains("HashAlgorithm") && !json["HashAlgorithm"].is_null()) {
            this->m_HashAlgorithm = std::make_shared< aspose::words::cloud::models::PdfDigitalSignatureDetailsData::HashAlgorithm >(
                pdfDigitalSignatureDetailsDataHashAlgorithmFromString(json["HashAlgorithm"].get< std::string >())
            );
        }
        if (json.contains("Location") && !json["Location"].is_null()) {
            this->m_Location = std::make_shared< std::wstring >(
                convertUtf8( json["Location"].get< std::string >() )
            );
        }
        if (json.contains("Reason") && !json["Reason"].is_null()) {
            this->m_Reason = std::make_shared< std::wstring >(
                convertUtf8( json["Reason"].get< std::string >() )
            );
        }
        if (json.contains("SignatureDate") && !json["SignatureDate"].is_null()) {
            this->m_SignatureDate = std::make_shared< std::wstring >(
                convertUtf8( json["SignatureDate"].get< std::string >() )
            );
        }
    }

    void PdfDigitalSignatureDetailsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void PdfDigitalSignatureDetailsData::validate()
    {
    }

    std::shared_ptr< std::wstring > PdfDigitalSignatureDetailsData::getCertificateFilename() const
    {
        return this->m_CertificateFilename;
    }

    void PdfDigitalSignatureDetailsData::setCertificateFilename(std::shared_ptr< std::wstring > value)
    {
        this->m_CertificateFilename = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PdfDigitalSignatureDetailsData::HashAlgorithm > PdfDigitalSignatureDetailsData::getHashAlgorithm() const
    {
        return this->m_HashAlgorithm;
    }

    void PdfDigitalSignatureDetailsData::setHashAlgorithm(std::shared_ptr< aspose::words::cloud::models::PdfDigitalSignatureDetailsData::HashAlgorithm > value)
    {
        this->m_HashAlgorithm = value;
    }


    std::shared_ptr< std::wstring > PdfDigitalSignatureDetailsData::getLocation() const
    {
        return this->m_Location;
    }

    void PdfDigitalSignatureDetailsData::setLocation(std::shared_ptr< std::wstring > value)
    {
        this->m_Location = value;
    }


    std::shared_ptr< std::wstring > PdfDigitalSignatureDetailsData::getReason() const
    {
        return this->m_Reason;
    }

    void PdfDigitalSignatureDetailsData::setReason(std::shared_ptr< std::wstring > value)
    {
        this->m_Reason = value;
    }


    std::shared_ptr< std::wstring > PdfDigitalSignatureDetailsData::getSignatureDate() const
    {
        return this->m_SignatureDate;
    }

    void PdfDigitalSignatureDetailsData::setSignatureDate(std::shared_ptr< std::wstring > value)
    {
        this->m_SignatureDate = value;
    }



    /*
     * PdfEncryptionDetailsData implementation
     */
    inline std::string pdfEncryptionDetailsDataPdfPermissionsToString(aspose::words::cloud::models::PdfPermissions value)
    {
        if (value == aspose::words::cloud::models::PdfPermissions::DISALLOW_ALL) return "DisallowAll";
        if (value == aspose::words::cloud::models::PdfPermissions::PRINTING) return "Printing";
        if (value == aspose::words::cloud::models::PdfPermissions::MODIFY_CONTENTS) return "ModifyContents";
        if (value == aspose::words::cloud::models::PdfPermissions::CONTENT_COPY) return "ContentCopy";
        if (value == aspose::words::cloud::models::PdfPermissions::MODIFY_ANNOTATIONS) return "ModifyAnnotations";
        if (value == aspose::words::cloud::models::PdfPermissions::FILL_IN) return "FillIn";
        if (value == aspose::words::cloud::models::PdfPermissions::CONTENT_COPY_FOR_ACCESSIBILITY) return "ContentCopyForAccessibility";
        if (value == aspose::words::cloud::models::PdfPermissions::DOCUMENT_ASSEMBLY) return "DocumentAssembly";
        if (value == aspose::words::cloud::models::PdfPermissions::HIGH_RESOLUTION_PRINTING) return "HighResolutionPrinting";
        if (value == aspose::words::cloud::models::PdfPermissions::ALLOW_ALL) return "AllowAll";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PdfPermissions pdfEncryptionDetailsDataPdfPermissionsFromString(const std::string& value)
    {
        if (value == "DisallowAll") return aspose::words::cloud::models::PdfPermissions::DISALLOW_ALL;
        if (value == "Printing") return aspose::words::cloud::models::PdfPermissions::PRINTING;
        if (value == "ModifyContents") return aspose::words::cloud::models::PdfPermissions::MODIFY_CONTENTS;
        if (value == "ContentCopy") return aspose::words::cloud::models::PdfPermissions::CONTENT_COPY;
        if (value == "ModifyAnnotations") return aspose::words::cloud::models::PdfPermissions::MODIFY_ANNOTATIONS;
        if (value == "FillIn") return aspose::words::cloud::models::PdfPermissions::FILL_IN;
        if (value == "ContentCopyForAccessibility") return aspose::words::cloud::models::PdfPermissions::CONTENT_COPY_FOR_ACCESSIBILITY;
        if (value == "DocumentAssembly") return aspose::words::cloud::models::PdfPermissions::DOCUMENT_ASSEMBLY;
        if (value == "HighResolutionPrinting") return aspose::words::cloud::models::PdfPermissions::HIGH_RESOLUTION_PRINTING;
        if (value == "AllowAll") return aspose::words::cloud::models::PdfPermissions::ALLOW_ALL;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void PdfEncryptionDetailsData::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_OwnerPassword) {
            json["OwnerPassword"] = convertUtf16(*(this->m_OwnerPassword));
        }
        if (this->m_Permissions) {
            json["Permissions"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_Permissions)) {
                json["Permissions"].push_back(pdfPermissionsToString(*element));
            }
        }
        if (this->m_UserPassword) {
            json["UserPassword"] = convertUtf16(*(this->m_UserPassword));
        }
    }

    void PdfEncryptionDetailsData::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("OwnerPassword") && !json["OwnerPassword"].is_null()) {
            this->m_OwnerPassword = std::make_shared< std::wstring >(
                convertUtf8( json["OwnerPassword"].get< std::string >() )
            );
        }
        if (json.contains("Permissions") && !json["Permissions"].is_null()) {
            this->m_Permissions = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::PdfPermissions>> >();
            for (auto& element : json["Permissions"]) {
                this->m_Permissions->push_back(std::make_shared< aspose::words::cloud::models::PdfPermissions >(pdfPermissionsFromString(element.get< std::string >())));
            }
        }
        if (json.contains("UserPassword") && !json["UserPassword"].is_null()) {
            this->m_UserPassword = std::make_shared< std::wstring >(
                convertUtf8( json["UserPassword"].get< std::string >() )
            );
        }
    }

    void PdfEncryptionDetailsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void PdfEncryptionDetailsData::validate()
    {
    }

    std::shared_ptr< std::wstring > PdfEncryptionDetailsData::getOwnerPassword() const
    {
        return this->m_OwnerPassword;
    }

    void PdfEncryptionDetailsData::setOwnerPassword(std::shared_ptr< std::wstring > value)
    {
        this->m_OwnerPassword = value;
    }


    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::PdfPermissions>> > PdfEncryptionDetailsData::getPermissions() const
    {
        return this->m_Permissions;
    }

    void PdfEncryptionDetailsData::setPermissions(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::PdfPermissions>> > value)
    {
        this->m_Permissions = value;
    }


    std::shared_ptr< std::wstring > PdfEncryptionDetailsData::getUserPassword() const
    {
        return this->m_UserPassword;
    }

    void PdfEncryptionDetailsData::setUserPassword(std::shared_ptr< std::wstring > value)
    {
        this->m_UserPassword = value;
    }



    /*
     * PdfSaveOptionsData implementation
     */
    inline std::string pdfSaveOptionsDataComplianceToString(aspose::words::cloud::models::PdfSaveOptionsData::Compliance value)
    {
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::Compliance::PDF17) return "Pdf17";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::Compliance::PDF20) return "Pdf20";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::Compliance::PDF_A1A) return "PdfA1a";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::Compliance::PDF_A1B) return "PdfA1b";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::Compliance::PDF_A2A) return "PdfA2a";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::Compliance::PDF_A2U) return "PdfA2u";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::Compliance::PDF_A4) return "PdfA4";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::Compliance::PDF_UA1) return "PdfUa1";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PdfSaveOptionsData::Compliance pdfSaveOptionsDataComplianceFromString(const std::string& value)
    {
        if (value == "Pdf17") return aspose::words::cloud::models::PdfSaveOptionsData::Compliance::PDF17;
        if (value == "Pdf20") return aspose::words::cloud::models::PdfSaveOptionsData::Compliance::PDF20;
        if (value == "PdfA1a") return aspose::words::cloud::models::PdfSaveOptionsData::Compliance::PDF_A1A;
        if (value == "PdfA1b") return aspose::words::cloud::models::PdfSaveOptionsData::Compliance::PDF_A1B;
        if (value == "PdfA2a") return aspose::words::cloud::models::PdfSaveOptionsData::Compliance::PDF_A2A;
        if (value == "PdfA2u") return aspose::words::cloud::models::PdfSaveOptionsData::Compliance::PDF_A2U;
        if (value == "PdfA4") return aspose::words::cloud::models::PdfSaveOptionsData::Compliance::PDF_A4;
        if (value == "PdfUa1") return aspose::words::cloud::models::PdfSaveOptionsData::Compliance::PDF_UA1;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string pdfSaveOptionsDataCustomPropertiesExportToString(aspose::words::cloud::models::PdfSaveOptionsData::CustomPropertiesExport value)
    {
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::CustomPropertiesExport::NONE) return "None";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::CustomPropertiesExport::STANDARD) return "Standard";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::CustomPropertiesExport::METADATA) return "Metadata";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PdfSaveOptionsData::CustomPropertiesExport pdfSaveOptionsDataCustomPropertiesExportFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::PdfSaveOptionsData::CustomPropertiesExport::NONE;
        if (value == "Standard") return aspose::words::cloud::models::PdfSaveOptionsData::CustomPropertiesExport::STANDARD;
        if (value == "Metadata") return aspose::words::cloud::models::PdfSaveOptionsData::CustomPropertiesExport::METADATA;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string pdfSaveOptionsDataFontEmbeddingModeToString(aspose::words::cloud::models::PdfSaveOptionsData::FontEmbeddingMode value)
    {
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::FontEmbeddingMode::EMBED_ALL) return "EmbedAll";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::FontEmbeddingMode::EMBED_NONSTANDARD) return "EmbedNonstandard";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::FontEmbeddingMode::EMBED_NONE) return "EmbedNone";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PdfSaveOptionsData::FontEmbeddingMode pdfSaveOptionsDataFontEmbeddingModeFromString(const std::string& value)
    {
        if (value == "EmbedAll") return aspose::words::cloud::models::PdfSaveOptionsData::FontEmbeddingMode::EMBED_ALL;
        if (value == "EmbedNonstandard") return aspose::words::cloud::models::PdfSaveOptionsData::FontEmbeddingMode::EMBED_NONSTANDARD;
        if (value == "EmbedNone") return aspose::words::cloud::models::PdfSaveOptionsData::FontEmbeddingMode::EMBED_NONE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string pdfSaveOptionsDataHeaderFooterBookmarksExportModeToString(aspose::words::cloud::models::PdfSaveOptionsData::HeaderFooterBookmarksExportMode value)
    {
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::HeaderFooterBookmarksExportMode::NONE) return "None";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::HeaderFooterBookmarksExportMode::FIRST) return "First";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::HeaderFooterBookmarksExportMode::ALL) return "All";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PdfSaveOptionsData::HeaderFooterBookmarksExportMode pdfSaveOptionsDataHeaderFooterBookmarksExportModeFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::PdfSaveOptionsData::HeaderFooterBookmarksExportMode::NONE;
        if (value == "First") return aspose::words::cloud::models::PdfSaveOptionsData::HeaderFooterBookmarksExportMode::FIRST;
        if (value == "All") return aspose::words::cloud::models::PdfSaveOptionsData::HeaderFooterBookmarksExportMode::ALL;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string pdfSaveOptionsDataImageColorSpaceExportModeToString(aspose::words::cloud::models::PdfSaveOptionsData::ImageColorSpaceExportMode value)
    {
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::ImageColorSpaceExportMode::AUTO) return "Auto";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::ImageColorSpaceExportMode::SIMPLE_CMYK) return "SimpleCmyk";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PdfSaveOptionsData::ImageColorSpaceExportMode pdfSaveOptionsDataImageColorSpaceExportModeFromString(const std::string& value)
    {
        if (value == "Auto") return aspose::words::cloud::models::PdfSaveOptionsData::ImageColorSpaceExportMode::AUTO;
        if (value == "SimpleCmyk") return aspose::words::cloud::models::PdfSaveOptionsData::ImageColorSpaceExportMode::SIMPLE_CMYK;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string pdfSaveOptionsDataPageModeToString(aspose::words::cloud::models::PdfSaveOptionsData::PageMode value)
    {
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::PageMode::USE_NONE) return "UseNone";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::PageMode::USE_OUTLINES) return "UseOutlines";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::PageMode::USE_THUMBS) return "UseThumbs";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::PageMode::FULL_SCREEN) return "FullScreen";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::PageMode::USE_OC) return "UseOC";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::PageMode::USE_ATTACHMENTS) return "UseAttachments";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PdfSaveOptionsData::PageMode pdfSaveOptionsDataPageModeFromString(const std::string& value)
    {
        if (value == "UseNone") return aspose::words::cloud::models::PdfSaveOptionsData::PageMode::USE_NONE;
        if (value == "UseOutlines") return aspose::words::cloud::models::PdfSaveOptionsData::PageMode::USE_OUTLINES;
        if (value == "UseThumbs") return aspose::words::cloud::models::PdfSaveOptionsData::PageMode::USE_THUMBS;
        if (value == "FullScreen") return aspose::words::cloud::models::PdfSaveOptionsData::PageMode::FULL_SCREEN;
        if (value == "UseOC") return aspose::words::cloud::models::PdfSaveOptionsData::PageMode::USE_OC;
        if (value == "UseAttachments") return aspose::words::cloud::models::PdfSaveOptionsData::PageMode::USE_ATTACHMENTS;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string pdfSaveOptionsDataTextCompressionToString(aspose::words::cloud::models::PdfSaveOptionsData::TextCompression value)
    {
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::TextCompression::NONE) return "None";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::TextCompression::FLATE) return "Flate";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PdfSaveOptionsData::TextCompression pdfSaveOptionsDataTextCompressionFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::PdfSaveOptionsData::TextCompression::NONE;
        if (value == "Flate") return aspose::words::cloud::models::PdfSaveOptionsData::TextCompression::FLATE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string pdfSaveOptionsDataZoomBehaviorToString(aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior value)
    {
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior::NONE) return "None";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior::ZOOM_FACTOR) return "ZoomFactor";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior::FIT_PAGE) return "FitPage";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior::FIT_WIDTH) return "FitWidth";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior::FIT_HEIGHT) return "FitHeight";
        if (value == aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior::FIT_BOX) return "FitBox";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior pdfSaveOptionsDataZoomBehaviorFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior::NONE;
        if (value == "ZoomFactor") return aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior::ZOOM_FACTOR;
        if (value == "FitPage") return aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior::FIT_PAGE;
        if (value == "FitWidth") return aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior::FIT_WIDTH;
        if (value == "FitHeight") return aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior::FIT_HEIGHT;
        if (value == "FitBox") return aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior::FIT_BOX;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void PdfSaveOptionsData::toJson(void* jsonIfc) const
    {
        FixedPageSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_CacheBackgroundGraphics) {
            json["CacheBackgroundGraphics"] = *(this->m_CacheBackgroundGraphics);
        }
        if (this->m_Compliance) {
            json["Compliance"] = pdfSaveOptionsDataComplianceToString(*(this->m_Compliance));
        }
        if (this->m_CreateNoteHyperlinks) {
            json["CreateNoteHyperlinks"] = *(this->m_CreateNoteHyperlinks);
        }
        if (this->m_CustomPropertiesExport) {
            json["CustomPropertiesExport"] = pdfSaveOptionsDataCustomPropertiesExportToString(*(this->m_CustomPropertiesExport));
        }
        if (this->m_DigitalSignatureDetails) {
            this->m_DigitalSignatureDetails->toJson(&json["DigitalSignatureDetails"]);
        }
        if (this->m_DisplayDocTitle) {
            json["DisplayDocTitle"] = *(this->m_DisplayDocTitle);
        }
        if (this->m_DownsampleOptions) {
            this->m_DownsampleOptions->toJson(&json["DownsampleOptions"]);
        }
        if (this->m_EmbedAttachments) {
            json["EmbedAttachments"] = *(this->m_EmbedAttachments);
        }
        if (this->m_EmbedFullFonts) {
            json["EmbedFullFonts"] = *(this->m_EmbedFullFonts);
        }
        if (this->m_EncryptionDetails) {
            this->m_EncryptionDetails->toJson(&json["EncryptionDetails"]);
        }
        if (this->m_ExportDocumentStructure) {
            json["ExportDocumentStructure"] = *(this->m_ExportDocumentStructure);
        }
        if (this->m_ExportLanguageToSpanTag) {
            json["ExportLanguageToSpanTag"] = *(this->m_ExportLanguageToSpanTag);
        }
        if (this->m_FontEmbeddingMode) {
            json["FontEmbeddingMode"] = pdfSaveOptionsDataFontEmbeddingModeToString(*(this->m_FontEmbeddingMode));
        }
        if (this->m_HeaderFooterBookmarksExportMode) {
            json["HeaderFooterBookmarksExportMode"] = pdfSaveOptionsDataHeaderFooterBookmarksExportModeToString(*(this->m_HeaderFooterBookmarksExportMode));
        }
        if (this->m_ImageColorSpaceExportMode) {
            json["ImageColorSpaceExportMode"] = pdfSaveOptionsDataImageColorSpaceExportModeToString(*(this->m_ImageColorSpaceExportMode));
        }
        if (this->m_ImageCompression) {
            json["ImageCompression"] = convertUtf16(*(this->m_ImageCompression));
        }
        if (this->m_InterpolateImages) {
            json["InterpolateImages"] = *(this->m_InterpolateImages);
        }
        if (this->m_OpenHyperlinksInNewWindow) {
            json["OpenHyperlinksInNewWindow"] = *(this->m_OpenHyperlinksInNewWindow);
        }
        if (this->m_OutlineOptions) {
            this->m_OutlineOptions->toJson(&json["OutlineOptions"]);
        }
        if (this->m_PageMode) {
            json["PageMode"] = pdfSaveOptionsDataPageModeToString(*(this->m_PageMode));
        }
        if (this->m_PreblendImages) {
            json["PreblendImages"] = *(this->m_PreblendImages);
        }
        if (this->m_PreserveFormFields) {
            json["PreserveFormFields"] = *(this->m_PreserveFormFields);
        }
        if (this->m_TextCompression) {
            json["TextCompression"] = pdfSaveOptionsDataTextCompressionToString(*(this->m_TextCompression));
        }
        if (this->m_UseBookFoldPrintingSettings) {
            json["UseBookFoldPrintingSettings"] = *(this->m_UseBookFoldPrintingSettings);
        }
        if (this->m_UseCoreFonts) {
            json["UseCoreFonts"] = *(this->m_UseCoreFonts);
        }
        if (this->m_ZoomBehavior) {
            json["ZoomBehavior"] = pdfSaveOptionsDataZoomBehaviorToString(*(this->m_ZoomBehavior));
        }
        if (this->m_ZoomFactor) {
            json["ZoomFactor"] = *(this->m_ZoomFactor);
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void PdfSaveOptionsData::fromJson(const void* jsonIfc)
    {
        FixedPageSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("CacheBackgroundGraphics") && !json["CacheBackgroundGraphics"].is_null()) {
            this->m_CacheBackgroundGraphics = std::make_shared< bool >(
                json["CacheBackgroundGraphics"].get< bool >()
            );
        }
        if (json.contains("Compliance") && !json["Compliance"].is_null()) {
            this->m_Compliance = std::make_shared< aspose::words::cloud::models::PdfSaveOptionsData::Compliance >(
                pdfSaveOptionsDataComplianceFromString(json["Compliance"].get< std::string >())
            );
        }
        if (json.contains("CreateNoteHyperlinks") && !json["CreateNoteHyperlinks"].is_null()) {
            this->m_CreateNoteHyperlinks = std::make_shared< bool >(
                json["CreateNoteHyperlinks"].get< bool >()
            );
        }
        if (json.contains("CustomPropertiesExport") && !json["CustomPropertiesExport"].is_null()) {
            this->m_CustomPropertiesExport = std::make_shared< aspose::words::cloud::models::PdfSaveOptionsData::CustomPropertiesExport >(
                pdfSaveOptionsDataCustomPropertiesExportFromString(json["CustomPropertiesExport"].get< std::string >())
            );
        }
        if (json.contains("DigitalSignatureDetails") && !json["DigitalSignatureDetails"].is_null()) {
            this->m_DigitalSignatureDetails = createModelInstance< aspose::words::cloud::models::PdfDigitalSignatureDetailsData >(L"PdfDigitalSignatureDetailsData, _", json["DigitalSignatureDetails"]);
        }
        if (json.contains("DisplayDocTitle") && !json["DisplayDocTitle"].is_null()) {
            this->m_DisplayDocTitle = std::make_shared< bool >(
                json["DisplayDocTitle"].get< bool >()
            );
        }
        if (json.contains("DownsampleOptions") && !json["DownsampleOptions"].is_null()) {
            this->m_DownsampleOptions = createModelInstance< aspose::words::cloud::models::DownsampleOptionsData >(L"DownsampleOptionsData, _", json["DownsampleOptions"]);
        }
        if (json.contains("EmbedAttachments") && !json["EmbedAttachments"].is_null()) {
            this->m_EmbedAttachments = std::make_shared< bool >(
                json["EmbedAttachments"].get< bool >()
            );
        }
        if (json.contains("EmbedFullFonts") && !json["EmbedFullFonts"].is_null()) {
            this->m_EmbedFullFonts = std::make_shared< bool >(
                json["EmbedFullFonts"].get< bool >()
            );
        }
        if (json.contains("EncryptionDetails") && !json["EncryptionDetails"].is_null()) {
            this->m_EncryptionDetails = createModelInstance< aspose::words::cloud::models::PdfEncryptionDetailsData >(L"PdfEncryptionDetailsData, _", json["EncryptionDetails"]);
        }
        if (json.contains("ExportDocumentStructure") && !json["ExportDocumentStructure"].is_null()) {
            this->m_ExportDocumentStructure = std::make_shared< bool >(
                json["ExportDocumentStructure"].get< bool >()
            );
        }
        if (json.contains("ExportLanguageToSpanTag") && !json["ExportLanguageToSpanTag"].is_null()) {
            this->m_ExportLanguageToSpanTag = std::make_shared< bool >(
                json["ExportLanguageToSpanTag"].get< bool >()
            );
        }
        if (json.contains("FontEmbeddingMode") && !json["FontEmbeddingMode"].is_null()) {
            this->m_FontEmbeddingMode = std::make_shared< aspose::words::cloud::models::PdfSaveOptionsData::FontEmbeddingMode >(
                pdfSaveOptionsDataFontEmbeddingModeFromString(json["FontEmbeddingMode"].get< std::string >())
            );
        }
        if (json.contains("HeaderFooterBookmarksExportMode") && !json["HeaderFooterBookmarksExportMode"].is_null()) {
            this->m_HeaderFooterBookmarksExportMode = std::make_shared< aspose::words::cloud::models::PdfSaveOptionsData::HeaderFooterBookmarksExportMode >(
                pdfSaveOptionsDataHeaderFooterBookmarksExportModeFromString(json["HeaderFooterBookmarksExportMode"].get< std::string >())
            );
        }
        if (json.contains("ImageColorSpaceExportMode") && !json["ImageColorSpaceExportMode"].is_null()) {
            this->m_ImageColorSpaceExportMode = std::make_shared< aspose::words::cloud::models::PdfSaveOptionsData::ImageColorSpaceExportMode >(
                pdfSaveOptionsDataImageColorSpaceExportModeFromString(json["ImageColorSpaceExportMode"].get< std::string >())
            );
        }
        if (json.contains("ImageCompression") && !json["ImageCompression"].is_null()) {
            this->m_ImageCompression = std::make_shared< std::wstring >(
                convertUtf8( json["ImageCompression"].get< std::string >() )
            );
        }
        if (json.contains("InterpolateImages") && !json["InterpolateImages"].is_null()) {
            this->m_InterpolateImages = std::make_shared< bool >(
                json["InterpolateImages"].get< bool >()
            );
        }
        if (json.contains("OpenHyperlinksInNewWindow") && !json["OpenHyperlinksInNewWindow"].is_null()) {
            this->m_OpenHyperlinksInNewWindow = std::make_shared< bool >(
                json["OpenHyperlinksInNewWindow"].get< bool >()
            );
        }
        if (json.contains("OutlineOptions") && !json["OutlineOptions"].is_null()) {
            this->m_OutlineOptions = createModelInstance< aspose::words::cloud::models::OutlineOptionsData >(L"OutlineOptionsData, _", json["OutlineOptions"]);
        }
        if (json.contains("PageMode") && !json["PageMode"].is_null()) {
            this->m_PageMode = std::make_shared< aspose::words::cloud::models::PdfSaveOptionsData::PageMode >(
                pdfSaveOptionsDataPageModeFromString(json["PageMode"].get< std::string >())
            );
        }
        if (json.contains("PreblendImages") && !json["PreblendImages"].is_null()) {
            this->m_PreblendImages = std::make_shared< bool >(
                json["PreblendImages"].get< bool >()
            );
        }
        if (json.contains("PreserveFormFields") && !json["PreserveFormFields"].is_null()) {
            this->m_PreserveFormFields = std::make_shared< bool >(
                json["PreserveFormFields"].get< bool >()
            );
        }
        if (json.contains("TextCompression") && !json["TextCompression"].is_null()) {
            this->m_TextCompression = std::make_shared< aspose::words::cloud::models::PdfSaveOptionsData::TextCompression >(
                pdfSaveOptionsDataTextCompressionFromString(json["TextCompression"].get< std::string >())
            );
        }
        if (json.contains("UseBookFoldPrintingSettings") && !json["UseBookFoldPrintingSettings"].is_null()) {
            this->m_UseBookFoldPrintingSettings = std::make_shared< bool >(
                json["UseBookFoldPrintingSettings"].get< bool >()
            );
        }
        if (json.contains("UseCoreFonts") && !json["UseCoreFonts"].is_null()) {
            this->m_UseCoreFonts = std::make_shared< bool >(
                json["UseCoreFonts"].get< bool >()
            );
        }
        if (json.contains("ZoomBehavior") && !json["ZoomBehavior"].is_null()) {
            this->m_ZoomBehavior = std::make_shared< aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior >(
                pdfSaveOptionsDataZoomBehaviorFromString(json["ZoomBehavior"].get< std::string >())
            );
        }
        if (json.contains("ZoomFactor") && !json["ZoomFactor"].is_null()) {
            this->m_ZoomFactor = std::make_shared< int32_t >(
                json["ZoomFactor"].get< int32_t >()
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void PdfSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void PdfSaveOptionsData::validate()
    {
        FixedPageSaveOptionsData::validate();

        if (this->m_DigitalSignatureDetails != nullptr)
        {
            this->m_DigitalSignatureDetails->validate();
        }




        if (this->m_DownsampleOptions != nullptr)
        {
            this->m_DownsampleOptions->validate();
        }





        if (this->m_EncryptionDetails != nullptr)
        {
            this->m_EncryptionDetails->validate();
        }











        if (this->m_OutlineOptions != nullptr)
        {
            this->m_OutlineOptions->validate();
        }










    }

    std::shared_ptr< bool > PdfSaveOptionsData::getCacheBackgroundGraphics() const
    {
        return this->m_CacheBackgroundGraphics;
    }

    void PdfSaveOptionsData::setCacheBackgroundGraphics(std::shared_ptr< bool > value)
    {
        this->m_CacheBackgroundGraphics = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PdfSaveOptionsData::Compliance > PdfSaveOptionsData::getCompliance() const
    {
        return this->m_Compliance;
    }

    void PdfSaveOptionsData::setCompliance(std::shared_ptr< aspose::words::cloud::models::PdfSaveOptionsData::Compliance > value)
    {
        this->m_Compliance = value;
    }


    std::shared_ptr< bool > PdfSaveOptionsData::getCreateNoteHyperlinks() const
    {
        return this->m_CreateNoteHyperlinks;
    }

    void PdfSaveOptionsData::setCreateNoteHyperlinks(std::shared_ptr< bool > value)
    {
        this->m_CreateNoteHyperlinks = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PdfSaveOptionsData::CustomPropertiesExport > PdfSaveOptionsData::getCustomPropertiesExport() const
    {
        return this->m_CustomPropertiesExport;
    }

    void PdfSaveOptionsData::setCustomPropertiesExport(std::shared_ptr< aspose::words::cloud::models::PdfSaveOptionsData::CustomPropertiesExport > value)
    {
        this->m_CustomPropertiesExport = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PdfDigitalSignatureDetailsData > PdfSaveOptionsData::getDigitalSignatureDetails() const
    {
        return this->m_DigitalSignatureDetails;
    }

    void PdfSaveOptionsData::setDigitalSignatureDetails(std::shared_ptr< aspose::words::cloud::models::PdfDigitalSignatureDetailsData > value)
    {
        this->m_DigitalSignatureDetails = value;
    }


    std::shared_ptr< bool > PdfSaveOptionsData::getDisplayDocTitle() const
    {
        return this->m_DisplayDocTitle;
    }

    void PdfSaveOptionsData::setDisplayDocTitle(std::shared_ptr< bool > value)
    {
        this->m_DisplayDocTitle = value;
    }


    std::shared_ptr< aspose::words::cloud::models::DownsampleOptionsData > PdfSaveOptionsData::getDownsampleOptions() const
    {
        return this->m_DownsampleOptions;
    }

    void PdfSaveOptionsData::setDownsampleOptions(std::shared_ptr< aspose::words::cloud::models::DownsampleOptionsData > value)
    {
        this->m_DownsampleOptions = value;
    }


    std::shared_ptr< bool > PdfSaveOptionsData::getEmbedAttachments() const
    {
        return this->m_EmbedAttachments;
    }

    void PdfSaveOptionsData::setEmbedAttachments(std::shared_ptr< bool > value)
    {
        this->m_EmbedAttachments = value;
    }


    std::shared_ptr< bool > PdfSaveOptionsData::getEmbedFullFonts() const
    {
        return this->m_EmbedFullFonts;
    }

    void PdfSaveOptionsData::setEmbedFullFonts(std::shared_ptr< bool > value)
    {
        this->m_EmbedFullFonts = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PdfEncryptionDetailsData > PdfSaveOptionsData::getEncryptionDetails() const
    {
        return this->m_EncryptionDetails;
    }

    void PdfSaveOptionsData::setEncryptionDetails(std::shared_ptr< aspose::words::cloud::models::PdfEncryptionDetailsData > value)
    {
        this->m_EncryptionDetails = value;
    }


    std::shared_ptr< bool > PdfSaveOptionsData::getExportDocumentStructure() const
    {
        return this->m_ExportDocumentStructure;
    }

    void PdfSaveOptionsData::setExportDocumentStructure(std::shared_ptr< bool > value)
    {
        this->m_ExportDocumentStructure = value;
    }


    std::shared_ptr< bool > PdfSaveOptionsData::getExportLanguageToSpanTag() const
    {
        return this->m_ExportLanguageToSpanTag;
    }

    void PdfSaveOptionsData::setExportLanguageToSpanTag(std::shared_ptr< bool > value)
    {
        this->m_ExportLanguageToSpanTag = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PdfSaveOptionsData::FontEmbeddingMode > PdfSaveOptionsData::getFontEmbeddingMode() const
    {
        return this->m_FontEmbeddingMode;
    }

    void PdfSaveOptionsData::setFontEmbeddingMode(std::shared_ptr< aspose::words::cloud::models::PdfSaveOptionsData::FontEmbeddingMode > value)
    {
        this->m_FontEmbeddingMode = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PdfSaveOptionsData::HeaderFooterBookmarksExportMode > PdfSaveOptionsData::getHeaderFooterBookmarksExportMode() const
    {
        return this->m_HeaderFooterBookmarksExportMode;
    }

    void PdfSaveOptionsData::setHeaderFooterBookmarksExportMode(std::shared_ptr< aspose::words::cloud::models::PdfSaveOptionsData::HeaderFooterBookmarksExportMode > value)
    {
        this->m_HeaderFooterBookmarksExportMode = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PdfSaveOptionsData::ImageColorSpaceExportMode > PdfSaveOptionsData::getImageColorSpaceExportMode() const
    {
        return this->m_ImageColorSpaceExportMode;
    }

    void PdfSaveOptionsData::setImageColorSpaceExportMode(std::shared_ptr< aspose::words::cloud::models::PdfSaveOptionsData::ImageColorSpaceExportMode > value)
    {
        this->m_ImageColorSpaceExportMode = value;
    }


    std::shared_ptr< std::wstring > PdfSaveOptionsData::getImageCompression() const
    {
        return this->m_ImageCompression;
    }

    void PdfSaveOptionsData::setImageCompression(std::shared_ptr< std::wstring > value)
    {
        this->m_ImageCompression = value;
    }


    std::shared_ptr< bool > PdfSaveOptionsData::getInterpolateImages() const
    {
        return this->m_InterpolateImages;
    }

    void PdfSaveOptionsData::setInterpolateImages(std::shared_ptr< bool > value)
    {
        this->m_InterpolateImages = value;
    }


    std::shared_ptr< bool > PdfSaveOptionsData::getOpenHyperlinksInNewWindow() const
    {
        return this->m_OpenHyperlinksInNewWindow;
    }

    void PdfSaveOptionsData::setOpenHyperlinksInNewWindow(std::shared_ptr< bool > value)
    {
        this->m_OpenHyperlinksInNewWindow = value;
    }


    std::shared_ptr< aspose::words::cloud::models::OutlineOptionsData > PdfSaveOptionsData::getOutlineOptions() const
    {
        return this->m_OutlineOptions;
    }

    void PdfSaveOptionsData::setOutlineOptions(std::shared_ptr< aspose::words::cloud::models::OutlineOptionsData > value)
    {
        this->m_OutlineOptions = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PdfSaveOptionsData::PageMode > PdfSaveOptionsData::getPageMode() const
    {
        return this->m_PageMode;
    }

    void PdfSaveOptionsData::setPageMode(std::shared_ptr< aspose::words::cloud::models::PdfSaveOptionsData::PageMode > value)
    {
        this->m_PageMode = value;
    }


    std::shared_ptr< bool > PdfSaveOptionsData::getPreblendImages() const
    {
        return this->m_PreblendImages;
    }

    void PdfSaveOptionsData::setPreblendImages(std::shared_ptr< bool > value)
    {
        this->m_PreblendImages = value;
    }


    std::shared_ptr< bool > PdfSaveOptionsData::getPreserveFormFields() const
    {
        return this->m_PreserveFormFields;
    }

    void PdfSaveOptionsData::setPreserveFormFields(std::shared_ptr< bool > value)
    {
        this->m_PreserveFormFields = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PdfSaveOptionsData::TextCompression > PdfSaveOptionsData::getTextCompression() const
    {
        return this->m_TextCompression;
    }

    void PdfSaveOptionsData::setTextCompression(std::shared_ptr< aspose::words::cloud::models::PdfSaveOptionsData::TextCompression > value)
    {
        this->m_TextCompression = value;
    }


    std::shared_ptr< bool > PdfSaveOptionsData::getUseBookFoldPrintingSettings() const
    {
        return this->m_UseBookFoldPrintingSettings;
    }

    void PdfSaveOptionsData::setUseBookFoldPrintingSettings(std::shared_ptr< bool > value)
    {
        this->m_UseBookFoldPrintingSettings = value;
    }


    std::shared_ptr< bool > PdfSaveOptionsData::getUseCoreFonts() const
    {
        return this->m_UseCoreFonts;
    }

    void PdfSaveOptionsData::setUseCoreFonts(std::shared_ptr< bool > value)
    {
        this->m_UseCoreFonts = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior > PdfSaveOptionsData::getZoomBehavior() const
    {
        return this->m_ZoomBehavior;
    }

    void PdfSaveOptionsData::setZoomBehavior(std::shared_ptr< aspose::words::cloud::models::PdfSaveOptionsData::ZoomBehavior > value)
    {
        this->m_ZoomBehavior = value;
    }


    std::shared_ptr< int32_t > PdfSaveOptionsData::getZoomFactor() const
    {
        return this->m_ZoomFactor;
    }

    void PdfSaveOptionsData::setZoomFactor(std::shared_ptr< int32_t > value)
    {
        this->m_ZoomFactor = value;
    }


    std::shared_ptr< std::wstring > PdfSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * PngSaveOptionsData implementation
     */
    void PngSaveOptionsData::toJson(void* jsonIfc) const
    {
        ImageSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void PngSaveOptionsData::fromJson(const void* jsonIfc)
    {
        ImageSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void PngSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void PngSaveOptionsData::validate()
    {
        ImageSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > PngSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * Position implementation
     */
    void Position::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_NodeId) {
            json["NodeId"] = convertUtf16(*(this->m_NodeId));
        }
        if (this->m_Type) {
            json["Type"] = convertUtf16(*(this->m_Type));
        }
    }

    void Position::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("NodeId") && !json["NodeId"].is_null()) {
            this->m_NodeId = std::make_shared< std::wstring >(
                convertUtf8( json["NodeId"].get< std::string >() )
            );
        }
        if (json.contains("Type") && !json["Type"].is_null()) {
            this->m_Type = std::make_shared< std::wstring >(
                convertUtf8( json["Type"].get< std::string >() )
            );
        }
    }

    void Position::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Position::validate()
    {
        if (this->m_NodeId == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property NodeId in Position is required.");
        }

    }

    std::shared_ptr< std::wstring > Position::getNodeId() const
    {
        return this->m_NodeId;
    }

    void Position::setNodeId(std::shared_ptr< std::wstring > value)
    {
        this->m_NodeId = value;
    }


    std::shared_ptr< std::wstring > Position::getType() const
    {
        return this->m_Type;
    }




    /*
     * PositionAfterNode implementation
     */
    void PositionAfterNode::toJson(void* jsonIfc) const
    {
        Position::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Type) {
            json["Type"] = convertUtf16(*(this->m_Type));
        }
    }

    void PositionAfterNode::fromJson(const void* jsonIfc)
    {
        Position::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Type") && !json["Type"].is_null()) {
            this->m_Type = std::make_shared< std::wstring >(
                convertUtf8( json["Type"].get< std::string >() )
            );
        }
    }

    void PositionAfterNode::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void PositionAfterNode::validate()
    {
        Position::validate();
    }

    std::shared_ptr< std::wstring > PositionAfterNode::getType() const
    {
        return this->m_Type;
    }




    /*
     * PositionBeforeNode implementation
     */
    void PositionBeforeNode::toJson(void* jsonIfc) const
    {
        Position::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Type) {
            json["Type"] = convertUtf16(*(this->m_Type));
        }
    }

    void PositionBeforeNode::fromJson(const void* jsonIfc)
    {
        Position::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Type") && !json["Type"].is_null()) {
            this->m_Type = std::make_shared< std::wstring >(
                convertUtf8( json["Type"].get< std::string >() )
            );
        }
    }

    void PositionBeforeNode::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void PositionBeforeNode::validate()
    {
        Position::validate();
    }

    std::shared_ptr< std::wstring > PositionBeforeNode::getType() const
    {
        return this->m_Type;
    }




    /*
     * PositionInsideNode implementation
     */
    void PositionInsideNode::toJson(void* jsonIfc) const
    {
        Position::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Type) {
            json["Type"] = convertUtf16(*(this->m_Type));
        }
        if (this->m_Offset) {
            json["Offset"] = *(this->m_Offset);
        }
    }

    void PositionInsideNode::fromJson(const void* jsonIfc)
    {
        Position::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Type") && !json["Type"].is_null()) {
            this->m_Type = std::make_shared< std::wstring >(
                convertUtf8( json["Type"].get< std::string >() )
            );
        }
        if (json.contains("Offset") && !json["Offset"].is_null()) {
            this->m_Offset = std::make_shared< int32_t >(
                json["Offset"].get< int32_t >()
            );
        }
    }

    void PositionInsideNode::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void PositionInsideNode::validate()
    {
        Position::validate();
    }

    std::shared_ptr< std::wstring > PositionInsideNode::getType() const
    {
        return this->m_Type;
    }



    std::shared_ptr< int32_t > PositionInsideNode::getOffset() const
    {
        return this->m_Offset;
    }

    void PositionInsideNode::setOffset(std::shared_ptr< int32_t > value)
    {
        this->m_Offset = value;
    }



    /*
     * PreferredWidth implementation
     */
    inline std::string preferredWidthTypeToString(aspose::words::cloud::models::PreferredWidth::Type value)
    {
        if (value == aspose::words::cloud::models::PreferredWidth::Type::AUTO) return "Auto";
        if (value == aspose::words::cloud::models::PreferredWidth::Type::PERCENT) return "Percent";
        if (value == aspose::words::cloud::models::PreferredWidth::Type::POINTS) return "Points";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::PreferredWidth::Type preferredWidthTypeFromString(const std::string& value)
    {
        if (value == "Auto") return aspose::words::cloud::models::PreferredWidth::Type::AUTO;
        if (value == "Percent") return aspose::words::cloud::models::PreferredWidth::Type::PERCENT;
        if (value == "Points") return aspose::words::cloud::models::PreferredWidth::Type::POINTS;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void PreferredWidth::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Type) {
            json["Type"] = preferredWidthTypeToString(*(this->m_Type));
        }
        if (this->m_Value) {
            json["Value"] = *(this->m_Value);
        }
    }

    void PreferredWidth::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Type") && !json["Type"].is_null()) {
            this->m_Type = std::make_shared< aspose::words::cloud::models::PreferredWidth::Type >(
                preferredWidthTypeFromString(json["Type"].get< std::string >())
            );
        }
        if (json.contains("Value") && !json["Value"].is_null()) {
            this->m_Value = std::make_shared< double >(
                json["Value"].get< double >()
            );
        }
    }

    void PreferredWidth::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void PreferredWidth::validate()
    {
        if (this->m_Type == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Type in PreferredWidth is required.");
        }

    }

    std::shared_ptr< aspose::words::cloud::models::PreferredWidth::Type > PreferredWidth::getType() const
    {
        return this->m_Type;
    }

    void PreferredWidth::setType(std::shared_ptr< aspose::words::cloud::models::PreferredWidth::Type > value)
    {
        this->m_Type = value;
    }


    std::shared_ptr< double > PreferredWidth::getValue() const
    {
        return this->m_Value;
    }

    void PreferredWidth::setValue(std::shared_ptr< double > value)
    {
        this->m_Value = value;
    }



    /*
     * ProtectionData implementation
     */
    inline std::string protectionDataProtectionTypeToString(aspose::words::cloud::models::ProtectionData::ProtectionType value)
    {
        if (value == aspose::words::cloud::models::ProtectionData::ProtectionType::ALLOW_ONLY_REVISIONS) return "AllowOnlyRevisions";
        if (value == aspose::words::cloud::models::ProtectionData::ProtectionType::ALLOW_ONLY_COMMENTS) return "AllowOnlyComments";
        if (value == aspose::words::cloud::models::ProtectionData::ProtectionType::ALLOW_ONLY_FORM_FIELDS) return "AllowOnlyFormFields";
        if (value == aspose::words::cloud::models::ProtectionData::ProtectionType::READ_ONLY) return "ReadOnly";
        if (value == aspose::words::cloud::models::ProtectionData::ProtectionType::NO_PROTECTION) return "NoProtection";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ProtectionData::ProtectionType protectionDataProtectionTypeFromString(const std::string& value)
    {
        if (value == "AllowOnlyRevisions") return aspose::words::cloud::models::ProtectionData::ProtectionType::ALLOW_ONLY_REVISIONS;
        if (value == "AllowOnlyComments") return aspose::words::cloud::models::ProtectionData::ProtectionType::ALLOW_ONLY_COMMENTS;
        if (value == "AllowOnlyFormFields") return aspose::words::cloud::models::ProtectionData::ProtectionType::ALLOW_ONLY_FORM_FIELDS;
        if (value == "ReadOnly") return aspose::words::cloud::models::ProtectionData::ProtectionType::READ_ONLY;
        if (value == "NoProtection") return aspose::words::cloud::models::ProtectionData::ProtectionType::NO_PROTECTION;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void ProtectionData::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ProtectionType) {
            json["ProtectionType"] = protectionDataProtectionTypeToString(*(this->m_ProtectionType));
        }
    }

    void ProtectionData::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ProtectionType") && !json["ProtectionType"].is_null()) {
            this->m_ProtectionType = std::make_shared< aspose::words::cloud::models::ProtectionData::ProtectionType >(
                protectionDataProtectionTypeFromString(json["ProtectionType"].get< std::string >())
            );
        }
    }

    void ProtectionData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ProtectionData::validate()
    {
        if (this->m_ProtectionType == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property ProtectionType in ProtectionData is required.");
        }

    }

    std::shared_ptr< aspose::words::cloud::models::ProtectionData::ProtectionType > ProtectionData::getProtectionType() const
    {
        return this->m_ProtectionType;
    }

    void ProtectionData::setProtectionType(std::shared_ptr< aspose::words::cloud::models::ProtectionData::ProtectionType > value)
    {
        this->m_ProtectionType = value;
    }



    /*
     * ProtectionDataResponse implementation
     */
    void ProtectionDataResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_DocumentLink) {
            this->m_DocumentLink->toJson(&json["DocumentLink"]);
        }
        if (this->m_ProtectionData) {
            this->m_ProtectionData->toJson(&json["ProtectionData"]);
        }
    }

    void ProtectionDataResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("DocumentLink") && !json["DocumentLink"].is_null()) {
            this->m_DocumentLink = createModelInstance< aspose::words::cloud::models::FileLink >(L"FileLink, _", json["DocumentLink"]);
        }
        if (json.contains("ProtectionData") && !json["ProtectionData"].is_null()) {
            this->m_ProtectionData = createModelInstance< aspose::words::cloud::models::ProtectionData >(L"ProtectionData, _", json["ProtectionData"]);
        }
    }

    void ProtectionDataResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ProtectionDataResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_DocumentLink != nullptr)
        {
            this->m_DocumentLink->validate();
        }



        if (this->m_ProtectionData != nullptr)
        {
            this->m_ProtectionData->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::FileLink > ProtectionDataResponse::getDocumentLink() const
    {
        return this->m_DocumentLink;
    }

    void ProtectionDataResponse::setDocumentLink(std::shared_ptr< aspose::words::cloud::models::FileLink > value)
    {
        this->m_DocumentLink = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ProtectionData > ProtectionDataResponse::getProtectionData() const
    {
        return this->m_ProtectionData;
    }

    void ProtectionDataResponse::setProtectionData(std::shared_ptr< aspose::words::cloud::models::ProtectionData > value)
    {
        this->m_ProtectionData = value;
    }



    /*
     * ProtectionRequest implementation
     */
    void ProtectionRequest::toJson(void* jsonIfc) const
    {
        ProtectionRequestBase::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_NewPassword) {
            json["NewPassword"] = convertUtf16(*(this->m_NewPassword));
        }
        if (this->m_Password) {
            json["Password"] = convertUtf16(*(this->m_Password));
        }
        if (this->m_ProtectionType) {
            json["ProtectionType"] = convertUtf16(*(this->m_ProtectionType));
        }
    }

    void ProtectionRequest::fromJson(const void* jsonIfc)
    {
        ProtectionRequestBase::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("NewPassword") && !json["NewPassword"].is_null()) {
            this->m_NewPassword = std::make_shared< std::wstring >(
                convertUtf8( json["NewPassword"].get< std::string >() )
            );
        }
        if (json.contains("Password") && !json["Password"].is_null()) {
            this->m_Password = std::make_shared< std::wstring >(
                convertUtf8( json["Password"].get< std::string >() )
            );
        }
        if (json.contains("ProtectionType") && !json["ProtectionType"].is_null()) {
            this->m_ProtectionType = std::make_shared< std::wstring >(
                convertUtf8( json["ProtectionType"].get< std::string >() )
            );
        }
    }

    void ProtectionRequest::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ProtectionRequest::validate()
    {
        ProtectionRequestBase::validate();
        if (this->m_Password == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Password in ProtectionRequest is required.");
        }

    }

    std::shared_ptr< std::wstring > ProtectionRequest::getNewPassword() const
    {
        return this->m_NewPassword;
    }

    void ProtectionRequest::setNewPassword(std::shared_ptr< std::wstring > value)
    {
        this->m_NewPassword = value;
    }


    std::shared_ptr< std::wstring > ProtectionRequest::getPassword() const
    {
        return this->m_Password;
    }

    void ProtectionRequest::setPassword(std::shared_ptr< std::wstring > value)
    {
        this->m_Password = value;
    }


    std::shared_ptr< std::wstring > ProtectionRequest::getProtectionType() const
    {
        return this->m_ProtectionType;
    }

    void ProtectionRequest::setProtectionType(std::shared_ptr< std::wstring > value)
    {
        this->m_ProtectionType = value;
    }



    /*
     * ProtectionRequestBase implementation
     */
    void ProtectionRequestBase::toJson(void* jsonIfc) const
    {
    }

    void ProtectionRequestBase::fromJson(const void* jsonIfc)
    {
    }

    void ProtectionRequestBase::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ProtectionRequestBase::validate()
    {
    }




    /*
     * ProtectionRequestV2 implementation
     */
    inline std::string protectionRequestV2ProtectionTypeToString(aspose::words::cloud::models::ProtectionRequestV2::ProtectionType value)
    {
        if (value == aspose::words::cloud::models::ProtectionRequestV2::ProtectionType::ALLOW_ONLY_REVISIONS) return "AllowOnlyRevisions";
        if (value == aspose::words::cloud::models::ProtectionRequestV2::ProtectionType::ALLOW_ONLY_COMMENTS) return "AllowOnlyComments";
        if (value == aspose::words::cloud::models::ProtectionRequestV2::ProtectionType::ALLOW_ONLY_FORM_FIELDS) return "AllowOnlyFormFields";
        if (value == aspose::words::cloud::models::ProtectionRequestV2::ProtectionType::READ_ONLY) return "ReadOnly";
        if (value == aspose::words::cloud::models::ProtectionRequestV2::ProtectionType::NO_PROTECTION) return "NoProtection";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ProtectionRequestV2::ProtectionType protectionRequestV2ProtectionTypeFromString(const std::string& value)
    {
        if (value == "AllowOnlyRevisions") return aspose::words::cloud::models::ProtectionRequestV2::ProtectionType::ALLOW_ONLY_REVISIONS;
        if (value == "AllowOnlyComments") return aspose::words::cloud::models::ProtectionRequestV2::ProtectionType::ALLOW_ONLY_COMMENTS;
        if (value == "AllowOnlyFormFields") return aspose::words::cloud::models::ProtectionRequestV2::ProtectionType::ALLOW_ONLY_FORM_FIELDS;
        if (value == "ReadOnly") return aspose::words::cloud::models::ProtectionRequestV2::ProtectionType::READ_ONLY;
        if (value == "NoProtection") return aspose::words::cloud::models::ProtectionRequestV2::ProtectionType::NO_PROTECTION;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void ProtectionRequestV2::toJson(void* jsonIfc) const
    {
        ProtectionRequestBase::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ProtectionPassword) {
            json["ProtectionPassword"] = convertUtf16(*(this->m_ProtectionPassword));
        }
        if (this->m_ProtectionType) {
            json["ProtectionType"] = protectionRequestV2ProtectionTypeToString(*(this->m_ProtectionType));
        }
    }

    void ProtectionRequestV2::fromJson(const void* jsonIfc)
    {
        ProtectionRequestBase::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ProtectionPassword") && !json["ProtectionPassword"].is_null()) {
            this->m_ProtectionPassword = std::make_shared< std::wstring >(
                convertUtf8( json["ProtectionPassword"].get< std::string >() )
            );
        }
        if (json.contains("ProtectionType") && !json["ProtectionType"].is_null()) {
            this->m_ProtectionType = std::make_shared< aspose::words::cloud::models::ProtectionRequestV2::ProtectionType >(
                protectionRequestV2ProtectionTypeFromString(json["ProtectionType"].get< std::string >())
            );
        }
    }

    void ProtectionRequestV2::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ProtectionRequestV2::validate()
    {
        ProtectionRequestBase::validate();
        if (this->m_ProtectionPassword == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property ProtectionPassword in ProtectionRequestV2 is required.");
        }

        if (this->m_ProtectionType == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property ProtectionType in ProtectionRequestV2 is required.");
        }

    }

    std::shared_ptr< std::wstring > ProtectionRequestV2::getProtectionPassword() const
    {
        return this->m_ProtectionPassword;
    }

    void ProtectionRequestV2::setProtectionPassword(std::shared_ptr< std::wstring > value)
    {
        this->m_ProtectionPassword = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ProtectionRequestV2::ProtectionType > ProtectionRequestV2::getProtectionType() const
    {
        return this->m_ProtectionType;
    }

    void ProtectionRequestV2::setProtectionType(std::shared_ptr< aspose::words::cloud::models::ProtectionRequestV2::ProtectionType > value)
    {
        this->m_ProtectionType = value;
    }



    /*
     * PsSaveOptionsData implementation
     */
    void PsSaveOptionsData::toJson(void* jsonIfc) const
    {
        FixedPageSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_UseBookFoldPrintingSettings) {
            json["UseBookFoldPrintingSettings"] = *(this->m_UseBookFoldPrintingSettings);
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void PsSaveOptionsData::fromJson(const void* jsonIfc)
    {
        FixedPageSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("UseBookFoldPrintingSettings") && !json["UseBookFoldPrintingSettings"].is_null()) {
            this->m_UseBookFoldPrintingSettings = std::make_shared< bool >(
                json["UseBookFoldPrintingSettings"].get< bool >()
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void PsSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void PsSaveOptionsData::validate()
    {
        FixedPageSaveOptionsData::validate();
    }

    std::shared_ptr< bool > PsSaveOptionsData::getUseBookFoldPrintingSettings() const
    {
        return this->m_UseBookFoldPrintingSettings;
    }

    void PsSaveOptionsData::setUseBookFoldPrintingSettings(std::shared_ptr< bool > value)
    {
        this->m_UseBookFoldPrintingSettings = value;
    }


    std::shared_ptr< std::wstring > PsSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * PublicKeyResponse implementation
     */
    void PublicKeyResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Exponent) {
            json["Exponent"] = convertUtf16(*(this->m_Exponent));
        }
        if (this->m_Modulus) {
            json["Modulus"] = convertUtf16(*(this->m_Modulus));
        }
    }

    void PublicKeyResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Exponent") && !json["Exponent"].is_null()) {
            this->m_Exponent = std::make_shared< std::wstring >(
                convertUtf8( json["Exponent"].get< std::string >() )
            );
        }
        if (json.contains("Modulus") && !json["Modulus"].is_null()) {
            this->m_Modulus = std::make_shared< std::wstring >(
                convertUtf8( json["Modulus"].get< std::string >() )
            );
        }
    }

    void PublicKeyResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void PublicKeyResponse::validate()
    {
        WordsResponse::validate();
    }

    std::shared_ptr< std::wstring > PublicKeyResponse::getExponent() const
    {
        return this->m_Exponent;
    }

    void PublicKeyResponse::setExponent(std::shared_ptr< std::wstring > value)
    {
        this->m_Exponent = value;
    }


    std::shared_ptr< std::wstring > PublicKeyResponse::getModulus() const
    {
        return this->m_Modulus;
    }

    void PublicKeyResponse::setModulus(std::shared_ptr< std::wstring > value)
    {
        this->m_Modulus = value;
    }



    /*
     * RangeDocument implementation
     */
    void RangeDocument::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_DocumentName) {
            json["DocumentName"] = convertUtf16(*(this->m_DocumentName));
        }
    }

    void RangeDocument::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("DocumentName") && !json["DocumentName"].is_null()) {
            this->m_DocumentName = std::make_shared< std::wstring >(
                convertUtf8( json["DocumentName"].get< std::string >() )
            );
        }
    }

    void RangeDocument::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void RangeDocument::validate()
    {
        if (this->m_DocumentName == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property DocumentName in RangeDocument is required.");
        }

    }

    std::shared_ptr< std::wstring > RangeDocument::getDocumentName() const
    {
        return this->m_DocumentName;
    }

    void RangeDocument::setDocumentName(std::shared_ptr< std::wstring > value)
    {
        this->m_DocumentName = value;
    }



    /*
     * RangeTextResponse implementation
     */
    void RangeTextResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Text) {
            json["Text"] = convertUtf16(*(this->m_Text));
        }
    }

    void RangeTextResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Text") && !json["Text"].is_null()) {
            this->m_Text = std::make_shared< std::wstring >(
                convertUtf8( json["Text"].get< std::string >() )
            );
        }
    }

    void RangeTextResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void RangeTextResponse::validate()
    {
        WordsResponse::validate();
    }

    std::shared_ptr< std::wstring > RangeTextResponse::getText() const
    {
        return this->m_Text;
    }

    void RangeTextResponse::setText(std::shared_ptr< std::wstring > value)
    {
        this->m_Text = value;
    }



    /*
     * ReplaceRange implementation
     */
    inline std::string replaceRangeTextTypeToString(aspose::words::cloud::models::ReplaceRange::TextType value)
    {
        if (value == aspose::words::cloud::models::ReplaceRange::TextType::TEXT) return "Text";
        if (value == aspose::words::cloud::models::ReplaceRange::TextType::HTML) return "Html";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ReplaceRange::TextType replaceRangeTextTypeFromString(const std::string& value)
    {
        if (value == "Text") return aspose::words::cloud::models::ReplaceRange::TextType::TEXT;
        if (value == "Html") return aspose::words::cloud::models::ReplaceRange::TextType::HTML;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void ReplaceRange::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Text) {
            json["Text"] = convertUtf16(*(this->m_Text));
        }
        if (this->m_TextType) {
            json["TextType"] = replaceRangeTextTypeToString(*(this->m_TextType));
        }
    }

    void ReplaceRange::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Text") && !json["Text"].is_null()) {
            this->m_Text = std::make_shared< std::wstring >(
                convertUtf8( json["Text"].get< std::string >() )
            );
        }
        if (json.contains("TextType") && !json["TextType"].is_null()) {
            this->m_TextType = std::make_shared< aspose::words::cloud::models::ReplaceRange::TextType >(
                replaceRangeTextTypeFromString(json["TextType"].get< std::string >())
            );
        }
    }

    void ReplaceRange::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ReplaceRange::validate()
    {
        if (this->m_Text == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Text in ReplaceRange is required.");
        }

    }

    std::shared_ptr< std::wstring > ReplaceRange::getText() const
    {
        return this->m_Text;
    }

    void ReplaceRange::setText(std::shared_ptr< std::wstring > value)
    {
        this->m_Text = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ReplaceRange::TextType > ReplaceRange::getTextType() const
    {
        return this->m_TextType;
    }

    void ReplaceRange::setTextType(std::shared_ptr< aspose::words::cloud::models::ReplaceRange::TextType > value)
    {
        this->m_TextType = value;
    }



    /*
     * ReplaceTextParameters implementation
     */
    void ReplaceTextParameters::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_IsMatchCase) {
            json["IsMatchCase"] = *(this->m_IsMatchCase);
        }
        if (this->m_IsMatchWholeWord) {
            json["IsMatchWholeWord"] = *(this->m_IsMatchWholeWord);
        }
        if (this->m_IsOldValueRegex) {
            json["IsOldValueRegex"] = *(this->m_IsOldValueRegex);
        }
        if (this->m_NewValue) {
            json["NewValue"] = convertUtf16(*(this->m_NewValue));
        }
        if (this->m_OldValue) {
            json["OldValue"] = convertUtf16(*(this->m_OldValue));
        }
    }

    void ReplaceTextParameters::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("IsMatchCase") && !json["IsMatchCase"].is_null()) {
            this->m_IsMatchCase = std::make_shared< bool >(
                json["IsMatchCase"].get< bool >()
            );
        }
        if (json.contains("IsMatchWholeWord") && !json["IsMatchWholeWord"].is_null()) {
            this->m_IsMatchWholeWord = std::make_shared< bool >(
                json["IsMatchWholeWord"].get< bool >()
            );
        }
        if (json.contains("IsOldValueRegex") && !json["IsOldValueRegex"].is_null()) {
            this->m_IsOldValueRegex = std::make_shared< bool >(
                json["IsOldValueRegex"].get< bool >()
            );
        }
        if (json.contains("NewValue") && !json["NewValue"].is_null()) {
            this->m_NewValue = std::make_shared< std::wstring >(
                convertUtf8( json["NewValue"].get< std::string >() )
            );
        }
        if (json.contains("OldValue") && !json["OldValue"].is_null()) {
            this->m_OldValue = std::make_shared< std::wstring >(
                convertUtf8( json["OldValue"].get< std::string >() )
            );
        }
    }

    void ReplaceTextParameters::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ReplaceTextParameters::validate()
    {
        if (this->m_IsMatchCase == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property IsMatchCase in ReplaceTextParameters is required.");
        }

        if (this->m_IsMatchWholeWord == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property IsMatchWholeWord in ReplaceTextParameters is required.");
        }

        if (this->m_IsOldValueRegex == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property IsOldValueRegex in ReplaceTextParameters is required.");
        }

        if (this->m_NewValue == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property NewValue in ReplaceTextParameters is required.");
        }

        if (this->m_OldValue == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property OldValue in ReplaceTextParameters is required.");
        }

    }

    std::shared_ptr< bool > ReplaceTextParameters::getIsMatchCase() const
    {
        return this->m_IsMatchCase;
    }

    void ReplaceTextParameters::setIsMatchCase(std::shared_ptr< bool > value)
    {
        this->m_IsMatchCase = value;
    }


    std::shared_ptr< bool > ReplaceTextParameters::getIsMatchWholeWord() const
    {
        return this->m_IsMatchWholeWord;
    }

    void ReplaceTextParameters::setIsMatchWholeWord(std::shared_ptr< bool > value)
    {
        this->m_IsMatchWholeWord = value;
    }


    std::shared_ptr< bool > ReplaceTextParameters::getIsOldValueRegex() const
    {
        return this->m_IsOldValueRegex;
    }

    void ReplaceTextParameters::setIsOldValueRegex(std::shared_ptr< bool > value)
    {
        this->m_IsOldValueRegex = value;
    }


    std::shared_ptr< std::wstring > ReplaceTextParameters::getNewValue() const
    {
        return this->m_NewValue;
    }

    void ReplaceTextParameters::setNewValue(std::shared_ptr< std::wstring > value)
    {
        this->m_NewValue = value;
    }


    std::shared_ptr< std::wstring > ReplaceTextParameters::getOldValue() const
    {
        return this->m_OldValue;
    }

    void ReplaceTextParameters::setOldValue(std::shared_ptr< std::wstring > value)
    {
        this->m_OldValue = value;
    }



    /*
     * ReplaceTextResponse implementation
     */
    void ReplaceTextResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_DocumentLink) {
            this->m_DocumentLink->toJson(&json["DocumentLink"]);
        }
        if (this->m_Matches) {
            json["Matches"] = *(this->m_Matches);
        }
    }

    void ReplaceTextResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("DocumentLink") && !json["DocumentLink"].is_null()) {
            this->m_DocumentLink = createModelInstance< aspose::words::cloud::models::FileLink >(L"FileLink, _", json["DocumentLink"]);
        }
        if (json.contains("Matches") && !json["Matches"].is_null()) {
            this->m_Matches = std::make_shared< int32_t >(
                json["Matches"].get< int32_t >()
            );
        }
    }

    void ReplaceTextResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ReplaceTextResponse::validate()
    {
        WordsResponse::validate();
        if (this->m_Matches == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Matches in ReplaceTextResponse is required.");
        }


        if (this->m_DocumentLink != nullptr)
        {
            this->m_DocumentLink->validate();
        }


    }

    std::shared_ptr< aspose::words::cloud::models::FileLink > ReplaceTextResponse::getDocumentLink() const
    {
        return this->m_DocumentLink;
    }

    void ReplaceTextResponse::setDocumentLink(std::shared_ptr< aspose::words::cloud::models::FileLink > value)
    {
        this->m_DocumentLink = value;
    }


    std::shared_ptr< int32_t > ReplaceTextResponse::getMatches() const
    {
        return this->m_Matches;
    }

    void ReplaceTextResponse::setMatches(std::shared_ptr< int32_t > value)
    {
        this->m_Matches = value;
    }



    /*
     * ReportEngineSettings implementation
     */
    inline std::string reportEngineSettingsDataSourceTypeToString(aspose::words::cloud::models::ReportEngineSettings::DataSourceType value)
    {
        if (value == aspose::words::cloud::models::ReportEngineSettings::DataSourceType::XML) return "Xml";
        if (value == aspose::words::cloud::models::ReportEngineSettings::DataSourceType::JSON) return "Json";
        if (value == aspose::words::cloud::models::ReportEngineSettings::DataSourceType::CSV) return "Csv";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ReportEngineSettings::DataSourceType reportEngineSettingsDataSourceTypeFromString(const std::string& value)
    {
        if (value == "Xml") return aspose::words::cloud::models::ReportEngineSettings::DataSourceType::XML;
        if (value == "Json") return aspose::words::cloud::models::ReportEngineSettings::DataSourceType::JSON;
        if (value == "Csv") return aspose::words::cloud::models::ReportEngineSettings::DataSourceType::CSV;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string reportEngineSettingsReportBuildOptionsToString(aspose::words::cloud::models::ReportBuildOptions value)
    {
        if (value == aspose::words::cloud::models::ReportBuildOptions::NONE) return "None";
        if (value == aspose::words::cloud::models::ReportBuildOptions::ALLOW_MISSING_MEMBERS) return "AllowMissingMembers";
        if (value == aspose::words::cloud::models::ReportBuildOptions::REMOVE_EMPTY_PARAGRAPHS) return "RemoveEmptyParagraphs";
        if (value == aspose::words::cloud::models::ReportBuildOptions::INLINE_ERROR_MESSAGES) return "InlineErrorMessages";
        if (value == aspose::words::cloud::models::ReportBuildOptions::USE_LEGACY_HEADER_FOOTER_VISITING) return "UseLegacyHeaderFooterVisiting";
        if (value == aspose::words::cloud::models::ReportBuildOptions::RESPECT_JPEG_EXIF_ORIENTATION) return "RespectJpegExifOrientation";
        if (value == aspose::words::cloud::models::ReportBuildOptions::UPDATE_FIELDS_SYNTAX_AWARE) return "UpdateFieldsSyntaxAware";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::ReportBuildOptions reportEngineSettingsReportBuildOptionsFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::ReportBuildOptions::NONE;
        if (value == "AllowMissingMembers") return aspose::words::cloud::models::ReportBuildOptions::ALLOW_MISSING_MEMBERS;
        if (value == "RemoveEmptyParagraphs") return aspose::words::cloud::models::ReportBuildOptions::REMOVE_EMPTY_PARAGRAPHS;
        if (value == "InlineErrorMessages") return aspose::words::cloud::models::ReportBuildOptions::INLINE_ERROR_MESSAGES;
        if (value == "UseLegacyHeaderFooterVisiting") return aspose::words::cloud::models::ReportBuildOptions::USE_LEGACY_HEADER_FOOTER_VISITING;
        if (value == "RespectJpegExifOrientation") return aspose::words::cloud::models::ReportBuildOptions::RESPECT_JPEG_EXIF_ORIENTATION;
        if (value == "UpdateFieldsSyntaxAware") return aspose::words::cloud::models::ReportBuildOptions::UPDATE_FIELDS_SYNTAX_AWARE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void ReportEngineSettings::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_CsvDataLoadOptions) {
            this->m_CsvDataLoadOptions->toJson(&json["CsvDataLoadOptions"]);
        }
        if (this->m_DataSourceName) {
            json["DataSourceName"] = convertUtf16(*(this->m_DataSourceName));
        }
        if (this->m_DataSourceType) {
            json["DataSourceType"] = reportEngineSettingsDataSourceTypeToString(*(this->m_DataSourceType));
        }
        if (this->m_JsonDataLoadOptions) {
            this->m_JsonDataLoadOptions->toJson(&json["JsonDataLoadOptions"]);
        }
        if (this->m_ReportBuildOptions) {
            json["ReportBuildOptions"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_ReportBuildOptions)) {
                json["ReportBuildOptions"].push_back(reportBuildOptionsToString(*element));
            }
        }
        if (this->m_XmlDataLoadOptions) {
            this->m_XmlDataLoadOptions->toJson(&json["XmlDataLoadOptions"]);
        }
    }

    void ReportEngineSettings::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("CsvDataLoadOptions") && !json["CsvDataLoadOptions"].is_null()) {
            this->m_CsvDataLoadOptions = createModelInstance< aspose::words::cloud::models::CsvDataLoadOptions >(L"CsvDataLoadOptions, _", json["CsvDataLoadOptions"]);
        }
        if (json.contains("DataSourceName") && !json["DataSourceName"].is_null()) {
            this->m_DataSourceName = std::make_shared< std::wstring >(
                convertUtf8( json["DataSourceName"].get< std::string >() )
            );
        }
        if (json.contains("DataSourceType") && !json["DataSourceType"].is_null()) {
            this->m_DataSourceType = std::make_shared< aspose::words::cloud::models::ReportEngineSettings::DataSourceType >(
                reportEngineSettingsDataSourceTypeFromString(json["DataSourceType"].get< std::string >())
            );
        }
        if (json.contains("JsonDataLoadOptions") && !json["JsonDataLoadOptions"].is_null()) {
            this->m_JsonDataLoadOptions = createModelInstance< aspose::words::cloud::models::JsonDataLoadOptions >(L"JsonDataLoadOptions, _", json["JsonDataLoadOptions"]);
        }
        if (json.contains("ReportBuildOptions") && !json["ReportBuildOptions"].is_null()) {
            this->m_ReportBuildOptions = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::ReportBuildOptions>> >();
            for (auto& element : json["ReportBuildOptions"]) {
                this->m_ReportBuildOptions->push_back(std::make_shared< aspose::words::cloud::models::ReportBuildOptions >(reportBuildOptionsFromString(element.get< std::string >())));
            }
        }
        if (json.contains("XmlDataLoadOptions") && !json["XmlDataLoadOptions"].is_null()) {
            this->m_XmlDataLoadOptions = createModelInstance< aspose::words::cloud::models::XmlDataLoadOptions >(L"XmlDataLoadOptions, _", json["XmlDataLoadOptions"]);
        }
    }

    void ReportEngineSettings::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void ReportEngineSettings::validate()
    {
        if (this->m_DataSourceType == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property DataSourceType in ReportEngineSettings is required.");
        }


        if (this->m_CsvDataLoadOptions != nullptr)
        {
            this->m_CsvDataLoadOptions->validate();
        }





        if (this->m_JsonDataLoadOptions != nullptr)
        {
            this->m_JsonDataLoadOptions->validate();
        }




        if (this->m_XmlDataLoadOptions != nullptr)
        {
            this->m_XmlDataLoadOptions->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::CsvDataLoadOptions > ReportEngineSettings::getCsvDataLoadOptions() const
    {
        return this->m_CsvDataLoadOptions;
    }

    void ReportEngineSettings::setCsvDataLoadOptions(std::shared_ptr< aspose::words::cloud::models::CsvDataLoadOptions > value)
    {
        this->m_CsvDataLoadOptions = value;
    }


    std::shared_ptr< std::wstring > ReportEngineSettings::getDataSourceName() const
    {
        return this->m_DataSourceName;
    }

    void ReportEngineSettings::setDataSourceName(std::shared_ptr< std::wstring > value)
    {
        this->m_DataSourceName = value;
    }


    std::shared_ptr< aspose::words::cloud::models::ReportEngineSettings::DataSourceType > ReportEngineSettings::getDataSourceType() const
    {
        return this->m_DataSourceType;
    }

    void ReportEngineSettings::setDataSourceType(std::shared_ptr< aspose::words::cloud::models::ReportEngineSettings::DataSourceType > value)
    {
        this->m_DataSourceType = value;
    }


    std::shared_ptr< aspose::words::cloud::models::JsonDataLoadOptions > ReportEngineSettings::getJsonDataLoadOptions() const
    {
        return this->m_JsonDataLoadOptions;
    }

    void ReportEngineSettings::setJsonDataLoadOptions(std::shared_ptr< aspose::words::cloud::models::JsonDataLoadOptions > value)
    {
        this->m_JsonDataLoadOptions = value;
    }


    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::ReportBuildOptions>> > ReportEngineSettings::getReportBuildOptions() const
    {
        return this->m_ReportBuildOptions;
    }

    void ReportEngineSettings::setReportBuildOptions(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::ReportBuildOptions>> > value)
    {
        this->m_ReportBuildOptions = value;
    }


    std::shared_ptr< aspose::words::cloud::models::XmlDataLoadOptions > ReportEngineSettings::getXmlDataLoadOptions() const
    {
        return this->m_XmlDataLoadOptions;
    }

    void ReportEngineSettings::setXmlDataLoadOptions(std::shared_ptr< aspose::words::cloud::models::XmlDataLoadOptions > value)
    {
        this->m_XmlDataLoadOptions = value;
    }



    /*
     * RevisionsModificationResponse implementation
     */
    void RevisionsModificationResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Result) {
            this->m_Result->toJson(&json["Result"]);
        }
    }

    void RevisionsModificationResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Result") && !json["Result"].is_null()) {
            this->m_Result = createModelInstance< aspose::words::cloud::models::ModificationOperationResult >(L"ModificationOperationResult, _", json["Result"]);
        }
    }

    void RevisionsModificationResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void RevisionsModificationResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Result != nullptr)
        {
            this->m_Result->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::ModificationOperationResult > RevisionsModificationResponse::getResult() const
    {
        return this->m_Result;
    }

    void RevisionsModificationResponse::setResult(std::shared_ptr< aspose::words::cloud::models::ModificationOperationResult > value)
    {
        this->m_Result = value;
    }



    /*
     * RtfSaveOptionsData implementation
     */
    void RtfSaveOptionsData::toJson(void* jsonIfc) const
    {
        SaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ExportCompactSize) {
            json["ExportCompactSize"] = *(this->m_ExportCompactSize);
        }
        if (this->m_ExportImagesForOldReaders) {
            json["ExportImagesForOldReaders"] = *(this->m_ExportImagesForOldReaders);
        }
        if (this->m_PrettyFormat) {
            json["PrettyFormat"] = *(this->m_PrettyFormat);
        }
        if (this->m_SaveImagesAsWmf) {
            json["SaveImagesAsWmf"] = *(this->m_SaveImagesAsWmf);
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void RtfSaveOptionsData::fromJson(const void* jsonIfc)
    {
        SaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ExportCompactSize") && !json["ExportCompactSize"].is_null()) {
            this->m_ExportCompactSize = std::make_shared< bool >(
                json["ExportCompactSize"].get< bool >()
            );
        }
        if (json.contains("ExportImagesForOldReaders") && !json["ExportImagesForOldReaders"].is_null()) {
            this->m_ExportImagesForOldReaders = std::make_shared< bool >(
                json["ExportImagesForOldReaders"].get< bool >()
            );
        }
        if (json.contains("PrettyFormat") && !json["PrettyFormat"].is_null()) {
            this->m_PrettyFormat = std::make_shared< bool >(
                json["PrettyFormat"].get< bool >()
            );
        }
        if (json.contains("SaveImagesAsWmf") && !json["SaveImagesAsWmf"].is_null()) {
            this->m_SaveImagesAsWmf = std::make_shared< bool >(
                json["SaveImagesAsWmf"].get< bool >()
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void RtfSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void RtfSaveOptionsData::validate()
    {
        SaveOptionsData::validate();
    }

    std::shared_ptr< bool > RtfSaveOptionsData::getExportCompactSize() const
    {
        return this->m_ExportCompactSize;
    }

    void RtfSaveOptionsData::setExportCompactSize(std::shared_ptr< bool > value)
    {
        this->m_ExportCompactSize = value;
    }


    std::shared_ptr< bool > RtfSaveOptionsData::getExportImagesForOldReaders() const
    {
        return this->m_ExportImagesForOldReaders;
    }

    void RtfSaveOptionsData::setExportImagesForOldReaders(std::shared_ptr< bool > value)
    {
        this->m_ExportImagesForOldReaders = value;
    }


    std::shared_ptr< bool > RtfSaveOptionsData::getPrettyFormat() const
    {
        return this->m_PrettyFormat;
    }

    void RtfSaveOptionsData::setPrettyFormat(std::shared_ptr< bool > value)
    {
        this->m_PrettyFormat = value;
    }


    std::shared_ptr< bool > RtfSaveOptionsData::getSaveImagesAsWmf() const
    {
        return this->m_SaveImagesAsWmf;
    }

    void RtfSaveOptionsData::setSaveImagesAsWmf(std::shared_ptr< bool > value)
    {
        this->m_SaveImagesAsWmf = value;
    }


    std::shared_ptr< std::wstring > RtfSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * Run implementation
     */
    void Run::toJson(void* jsonIfc) const
    {
        RunLink::toJson(jsonIfc);
    }

    void Run::fromJson(const void* jsonIfc)
    {
        RunLink::fromJson(jsonIfc);
    }

    void Run::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Run::validate()
    {
        RunLink::validate();
    }




    /*
     * RunBase implementation
     */
    void RunBase::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Text) {
            json["Text"] = convertUtf16(*(this->m_Text));
        }
    }

    void RunBase::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Text") && !json["Text"].is_null()) {
            this->m_Text = std::make_shared< std::wstring >(
                convertUtf8( json["Text"].get< std::string >() )
            );
        }
    }

    void RunBase::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void RunBase::validate()
    {
        if (this->m_Text == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Text in RunBase is required.");
        }

    }

    std::shared_ptr< std::wstring > RunBase::getText() const
    {
        return this->m_Text;
    }

    void RunBase::setText(std::shared_ptr< std::wstring > value)
    {
        this->m_Text = value;
    }



    /*
     * RunInsert implementation
     */
    void RunInsert::toJson(void* jsonIfc) const
    {
        RunBase::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Position) {
            this->m_Position->toJson(&json["Position"]);
        }
    }

    void RunInsert::fromJson(const void* jsonIfc)
    {
        RunBase::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Position") && !json["Position"].is_null()) {
            this->m_Position = createModelInstance< aspose::words::cloud::models::Position >(L"Position, _", json["Position"]);
        }
    }

    void RunInsert::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void RunInsert::validate()
    {
        RunBase::validate();

        if (this->m_Position != nullptr)
        {
            this->m_Position->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Position > RunInsert::getPosition() const
    {
        return this->m_Position;
    }

    void RunInsert::setPosition(std::shared_ptr< aspose::words::cloud::models::Position > value)
    {
        this->m_Position = value;
    }



    /*
     * RunLink implementation
     */
    void RunLink::toJson(void* jsonIfc) const
    {
        NodeLink::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Text) {
            json["Text"] = convertUtf16(*(this->m_Text));
        }
    }

    void RunLink::fromJson(const void* jsonIfc)
    {
        NodeLink::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Text") && !json["Text"].is_null()) {
            this->m_Text = std::make_shared< std::wstring >(
                convertUtf8( json["Text"].get< std::string >() )
            );
        }
    }

    void RunLink::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void RunLink::validate()
    {
        NodeLink::validate();
    }

    std::shared_ptr< std::wstring > RunLink::getText() const
    {
        return this->m_Text;
    }

    void RunLink::setText(std::shared_ptr< std::wstring > value)
    {
        this->m_Text = value;
    }



    /*
     * RunResponse implementation
     */
    void RunResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Run) {
            this->m_Run->toJson(&json["Run"]);
        }
    }

    void RunResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Run") && !json["Run"].is_null()) {
            this->m_Run = createModelInstance< aspose::words::cloud::models::Run >(L"Run, _", json["Run"]);
        }
    }

    void RunResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void RunResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Run != nullptr)
        {
            this->m_Run->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Run > RunResponse::getRun() const
    {
        return this->m_Run;
    }

    void RunResponse::setRun(std::shared_ptr< aspose::words::cloud::models::Run > value)
    {
        this->m_Run = value;
    }



    /*
     * Runs implementation
     */
    void Runs::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_List) {
            json["List"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_List)) {
                element->toJson(&json["List"].emplace_back());
            }
        }
    }

    void Runs::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("List") && !json["List"].is_null()) {
            this->m_List = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::Run>> >();
            for (auto& element : json["List"]) {
                this->m_List->emplace_back(createModelInstance< aspose::words::cloud::models::Run >(L"Run, _", element));
            }
        }
    }

    void Runs::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Runs::validate()
    {
        LinkElement::validate();

        if (this->m_List != nullptr)
        {
            for (auto& elementList : *(this->m_List))
            {
                if (elementList != nullptr)
                {
                    elementList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Run>> > Runs::getList() const
    {
        return this->m_List;
    }

    void Runs::setList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Run>> > value)
    {
        this->m_List = value;
    }



    /*
     * RunsResponse implementation
     */
    void RunsResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Runs) {
            this->m_Runs->toJson(&json["Runs"]);
        }
    }

    void RunsResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Runs") && !json["Runs"].is_null()) {
            this->m_Runs = createModelInstance< aspose::words::cloud::models::Runs >(L"Runs, _", json["Runs"]);
        }
    }

    void RunsResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void RunsResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Runs != nullptr)
        {
            this->m_Runs->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Runs > RunsResponse::getRuns() const
    {
        return this->m_Runs;
    }

    void RunsResponse::setRuns(std::shared_ptr< aspose::words::cloud::models::Runs > value)
    {
        this->m_Runs = value;
    }



    /*
     * RunUpdate implementation
     */
    void RunUpdate::toJson(void* jsonIfc) const
    {
        RunBase::toJson(jsonIfc);
    }

    void RunUpdate::fromJson(const void* jsonIfc)
    {
        RunBase::fromJson(jsonIfc);
    }

    void RunUpdate::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void RunUpdate::validate()
    {
        RunBase::validate();
    }




    /*
     * SaveOptionsData implementation
     */
    inline std::string saveOptionsDataDml3DEffectsRenderingModeToString(aspose::words::cloud::models::SaveOptionsData::Dml3DEffectsRenderingMode value)
    {
        if (value == aspose::words::cloud::models::SaveOptionsData::Dml3DEffectsRenderingMode::BASIC) return "Basic";
        if (value == aspose::words::cloud::models::SaveOptionsData::Dml3DEffectsRenderingMode::ADVANCED) return "Advanced";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::SaveOptionsData::Dml3DEffectsRenderingMode saveOptionsDataDml3DEffectsRenderingModeFromString(const std::string& value)
    {
        if (value == "Basic") return aspose::words::cloud::models::SaveOptionsData::Dml3DEffectsRenderingMode::BASIC;
        if (value == "Advanced") return aspose::words::cloud::models::SaveOptionsData::Dml3DEffectsRenderingMode::ADVANCED;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string saveOptionsDataDmlEffectsRenderingModeToString(aspose::words::cloud::models::SaveOptionsData::DmlEffectsRenderingMode value)
    {
        if (value == aspose::words::cloud::models::SaveOptionsData::DmlEffectsRenderingMode::SIMPLIFIED) return "Simplified";
        if (value == aspose::words::cloud::models::SaveOptionsData::DmlEffectsRenderingMode::NONE) return "None";
        if (value == aspose::words::cloud::models::SaveOptionsData::DmlEffectsRenderingMode::FINE) return "Fine";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::SaveOptionsData::DmlEffectsRenderingMode saveOptionsDataDmlEffectsRenderingModeFromString(const std::string& value)
    {
        if (value == "Simplified") return aspose::words::cloud::models::SaveOptionsData::DmlEffectsRenderingMode::SIMPLIFIED;
        if (value == "None") return aspose::words::cloud::models::SaveOptionsData::DmlEffectsRenderingMode::NONE;
        if (value == "Fine") return aspose::words::cloud::models::SaveOptionsData::DmlEffectsRenderingMode::FINE;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string saveOptionsDataDmlRenderingModeToString(aspose::words::cloud::models::SaveOptionsData::DmlRenderingMode value)
    {
        if (value == aspose::words::cloud::models::SaveOptionsData::DmlRenderingMode::FALLBACK) return "Fallback";
        if (value == aspose::words::cloud::models::SaveOptionsData::DmlRenderingMode::DRAWING_ML) return "DrawingML";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::SaveOptionsData::DmlRenderingMode saveOptionsDataDmlRenderingModeFromString(const std::string& value)
    {
        if (value == "Fallback") return aspose::words::cloud::models::SaveOptionsData::DmlRenderingMode::FALLBACK;
        if (value == "DrawingML") return aspose::words::cloud::models::SaveOptionsData::DmlRenderingMode::DRAWING_ML;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string saveOptionsDataImlRenderingModeToString(aspose::words::cloud::models::SaveOptionsData::ImlRenderingMode value)
    {
        if (value == aspose::words::cloud::models::SaveOptionsData::ImlRenderingMode::FALLBACK) return "Fallback";
        if (value == aspose::words::cloud::models::SaveOptionsData::ImlRenderingMode::INK_ML) return "InkML";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::SaveOptionsData::ImlRenderingMode saveOptionsDataImlRenderingModeFromString(const std::string& value)
    {
        if (value == "Fallback") return aspose::words::cloud::models::SaveOptionsData::ImlRenderingMode::FALLBACK;
        if (value == "InkML") return aspose::words::cloud::models::SaveOptionsData::ImlRenderingMode::INK_ML;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void SaveOptionsData::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_AllowEmbeddingPostScriptFonts) {
            json["AllowEmbeddingPostScriptFonts"] = *(this->m_AllowEmbeddingPostScriptFonts);
        }
        if (this->m_CustomTimeZoneInfoData) {
            this->m_CustomTimeZoneInfoData->toJson(&json["CustomTimeZoneInfoData"]);
        }
        if (this->m_Dml3DEffectsRenderingMode) {
            json["Dml3DEffectsRenderingMode"] = saveOptionsDataDml3DEffectsRenderingModeToString(*(this->m_Dml3DEffectsRenderingMode));
        }
        if (this->m_DmlEffectsRenderingMode) {
            json["DmlEffectsRenderingMode"] = saveOptionsDataDmlEffectsRenderingModeToString(*(this->m_DmlEffectsRenderingMode));
        }
        if (this->m_DmlRenderingMode) {
            json["DmlRenderingMode"] = saveOptionsDataDmlRenderingModeToString(*(this->m_DmlRenderingMode));
        }
        if (this->m_FileName) {
            json["FileName"] = convertUtf16(*(this->m_FileName));
        }
        if (this->m_ImlRenderingMode) {
            json["ImlRenderingMode"] = saveOptionsDataImlRenderingModeToString(*(this->m_ImlRenderingMode));
        }
        if (this->m_UpdateCreatedTimeProperty) {
            json["UpdateCreatedTimeProperty"] = *(this->m_UpdateCreatedTimeProperty);
        }
        if (this->m_UpdateFields) {
            json["UpdateFields"] = *(this->m_UpdateFields);
        }
        if (this->m_UpdateLastPrintedProperty) {
            json["UpdateLastPrintedProperty"] = *(this->m_UpdateLastPrintedProperty);
        }
        if (this->m_UpdateLastSavedTimeProperty) {
            json["UpdateLastSavedTimeProperty"] = *(this->m_UpdateLastSavedTimeProperty);
        }
        if (this->m_ZipOutput) {
            json["ZipOutput"] = *(this->m_ZipOutput);
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void SaveOptionsData::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("AllowEmbeddingPostScriptFonts") && !json["AllowEmbeddingPostScriptFonts"].is_null()) {
            this->m_AllowEmbeddingPostScriptFonts = std::make_shared< bool >(
                json["AllowEmbeddingPostScriptFonts"].get< bool >()
            );
        }
        if (json.contains("CustomTimeZoneInfoData") && !json["CustomTimeZoneInfoData"].is_null()) {
            this->m_CustomTimeZoneInfoData = createModelInstance< aspose::words::cloud::models::TimeZoneInfoData >(L"TimeZoneInfoData, _", json["CustomTimeZoneInfoData"]);
        }
        if (json.contains("Dml3DEffectsRenderingMode") && !json["Dml3DEffectsRenderingMode"].is_null()) {
            this->m_Dml3DEffectsRenderingMode = std::make_shared< aspose::words::cloud::models::SaveOptionsData::Dml3DEffectsRenderingMode >(
                saveOptionsDataDml3DEffectsRenderingModeFromString(json["Dml3DEffectsRenderingMode"].get< std::string >())
            );
        }
        if (json.contains("DmlEffectsRenderingMode") && !json["DmlEffectsRenderingMode"].is_null()) {
            this->m_DmlEffectsRenderingMode = std::make_shared< aspose::words::cloud::models::SaveOptionsData::DmlEffectsRenderingMode >(
                saveOptionsDataDmlEffectsRenderingModeFromString(json["DmlEffectsRenderingMode"].get< std::string >())
            );
        }
        if (json.contains("DmlRenderingMode") && !json["DmlRenderingMode"].is_null()) {
            this->m_DmlRenderingMode = std::make_shared< aspose::words::cloud::models::SaveOptionsData::DmlRenderingMode >(
                saveOptionsDataDmlRenderingModeFromString(json["DmlRenderingMode"].get< std::string >())
            );
        }
        if (json.contains("FileName") && !json["FileName"].is_null()) {
            this->m_FileName = std::make_shared< std::wstring >(
                convertUtf8( json["FileName"].get< std::string >() )
            );
        }
        if (json.contains("ImlRenderingMode") && !json["ImlRenderingMode"].is_null()) {
            this->m_ImlRenderingMode = std::make_shared< aspose::words::cloud::models::SaveOptionsData::ImlRenderingMode >(
                saveOptionsDataImlRenderingModeFromString(json["ImlRenderingMode"].get< std::string >())
            );
        }
        if (json.contains("UpdateCreatedTimeProperty") && !json["UpdateCreatedTimeProperty"].is_null()) {
            this->m_UpdateCreatedTimeProperty = std::make_shared< bool >(
                json["UpdateCreatedTimeProperty"].get< bool >()
            );
        }
        if (json.contains("UpdateFields") && !json["UpdateFields"].is_null()) {
            this->m_UpdateFields = std::make_shared< bool >(
                json["UpdateFields"].get< bool >()
            );
        }
        if (json.contains("UpdateLastPrintedProperty") && !json["UpdateLastPrintedProperty"].is_null()) {
            this->m_UpdateLastPrintedProperty = std::make_shared< bool >(
                json["UpdateLastPrintedProperty"].get< bool >()
            );
        }
        if (json.contains("UpdateLastSavedTimeProperty") && !json["UpdateLastSavedTimeProperty"].is_null()) {
            this->m_UpdateLastSavedTimeProperty = std::make_shared< bool >(
                json["UpdateLastSavedTimeProperty"].get< bool >()
            );
        }
        if (json.contains("ZipOutput") && !json["ZipOutput"].is_null()) {
            this->m_ZipOutput = std::make_shared< bool >(
                json["ZipOutput"].get< bool >()
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void SaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void SaveOptionsData::validate()
    {
        if (this->m_FileName == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property FileName in SaveOptionsData is required.");
        }


        if (this->m_CustomTimeZoneInfoData != nullptr)
        {
            this->m_CustomTimeZoneInfoData->validate();
        }












    }

    std::shared_ptr< bool > SaveOptionsData::getAllowEmbeddingPostScriptFonts() const
    {
        return this->m_AllowEmbeddingPostScriptFonts;
    }

    void SaveOptionsData::setAllowEmbeddingPostScriptFonts(std::shared_ptr< bool > value)
    {
        this->m_AllowEmbeddingPostScriptFonts = value;
    }


    std::shared_ptr< aspose::words::cloud::models::TimeZoneInfoData > SaveOptionsData::getCustomTimeZoneInfoData() const
    {
        return this->m_CustomTimeZoneInfoData;
    }

    void SaveOptionsData::setCustomTimeZoneInfoData(std::shared_ptr< aspose::words::cloud::models::TimeZoneInfoData > value)
    {
        this->m_CustomTimeZoneInfoData = value;
    }


    std::shared_ptr< aspose::words::cloud::models::SaveOptionsData::Dml3DEffectsRenderingMode > SaveOptionsData::getDml3DEffectsRenderingMode() const
    {
        return this->m_Dml3DEffectsRenderingMode;
    }

    void SaveOptionsData::setDml3DEffectsRenderingMode(std::shared_ptr< aspose::words::cloud::models::SaveOptionsData::Dml3DEffectsRenderingMode > value)
    {
        this->m_Dml3DEffectsRenderingMode = value;
    }


    std::shared_ptr< aspose::words::cloud::models::SaveOptionsData::DmlEffectsRenderingMode > SaveOptionsData::getDmlEffectsRenderingMode() const
    {
        return this->m_DmlEffectsRenderingMode;
    }

    void SaveOptionsData::setDmlEffectsRenderingMode(std::shared_ptr< aspose::words::cloud::models::SaveOptionsData::DmlEffectsRenderingMode > value)
    {
        this->m_DmlEffectsRenderingMode = value;
    }


    std::shared_ptr< aspose::words::cloud::models::SaveOptionsData::DmlRenderingMode > SaveOptionsData::getDmlRenderingMode() const
    {
        return this->m_DmlRenderingMode;
    }

    void SaveOptionsData::setDmlRenderingMode(std::shared_ptr< aspose::words::cloud::models::SaveOptionsData::DmlRenderingMode > value)
    {
        this->m_DmlRenderingMode = value;
    }


    std::shared_ptr< std::wstring > SaveOptionsData::getFileName() const
    {
        return this->m_FileName;
    }

    void SaveOptionsData::setFileName(std::shared_ptr< std::wstring > value)
    {
        this->m_FileName = value;
    }


    std::shared_ptr< aspose::words::cloud::models::SaveOptionsData::ImlRenderingMode > SaveOptionsData::getImlRenderingMode() const
    {
        return this->m_ImlRenderingMode;
    }

    void SaveOptionsData::setImlRenderingMode(std::shared_ptr< aspose::words::cloud::models::SaveOptionsData::ImlRenderingMode > value)
    {
        this->m_ImlRenderingMode = value;
    }


    std::shared_ptr< bool > SaveOptionsData::getUpdateCreatedTimeProperty() const
    {
        return this->m_UpdateCreatedTimeProperty;
    }

    void SaveOptionsData::setUpdateCreatedTimeProperty(std::shared_ptr< bool > value)
    {
        this->m_UpdateCreatedTimeProperty = value;
    }


    std::shared_ptr< bool > SaveOptionsData::getUpdateFields() const
    {
        return this->m_UpdateFields;
    }

    void SaveOptionsData::setUpdateFields(std::shared_ptr< bool > value)
    {
        this->m_UpdateFields = value;
    }


    std::shared_ptr< bool > SaveOptionsData::getUpdateLastPrintedProperty() const
    {
        return this->m_UpdateLastPrintedProperty;
    }

    void SaveOptionsData::setUpdateLastPrintedProperty(std::shared_ptr< bool > value)
    {
        this->m_UpdateLastPrintedProperty = value;
    }


    std::shared_ptr< bool > SaveOptionsData::getUpdateLastSavedTimeProperty() const
    {
        return this->m_UpdateLastSavedTimeProperty;
    }

    void SaveOptionsData::setUpdateLastSavedTimeProperty(std::shared_ptr< bool > value)
    {
        this->m_UpdateLastSavedTimeProperty = value;
    }


    std::shared_ptr< bool > SaveOptionsData::getZipOutput() const
    {
        return this->m_ZipOutput;
    }

    void SaveOptionsData::setZipOutput(std::shared_ptr< bool > value)
    {
        this->m_ZipOutput = value;
    }


    std::shared_ptr< std::wstring > SaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * SaveResponse implementation
     */
    void SaveResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveResult) {
            this->m_SaveResult->toJson(&json["SaveResult"]);
        }
    }

    void SaveResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveResult") && !json["SaveResult"].is_null()) {
            this->m_SaveResult = createModelInstance< aspose::words::cloud::models::SaveResult >(L"SaveResult, _", json["SaveResult"]);
        }
    }

    void SaveResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void SaveResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_SaveResult != nullptr)
        {
            this->m_SaveResult->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::SaveResult > SaveResponse::getSaveResult() const
    {
        return this->m_SaveResult;
    }

    void SaveResponse::setSaveResult(std::shared_ptr< aspose::words::cloud::models::SaveResult > value)
    {
        this->m_SaveResult = value;
    }



    /*
     * SaveResult implementation
     */
    void SaveResult::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_DestDocument) {
            this->m_DestDocument->toJson(&json["DestDocument"]);
        }
        if (this->m_SourceDocument) {
            this->m_SourceDocument->toJson(&json["SourceDocument"]);
        }
        if (this->m_AdditionalItems) {
            json["AdditionalItems"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_AdditionalItems)) {
                element->toJson(&json["AdditionalItems"].emplace_back());
            }
        }
    }

    void SaveResult::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("DestDocument") && !json["DestDocument"].is_null()) {
            this->m_DestDocument = createModelInstance< aspose::words::cloud::models::FileLink >(L"FileLink, _", json["DestDocument"]);
        }
        if (json.contains("SourceDocument") && !json["SourceDocument"].is_null()) {
            this->m_SourceDocument = createModelInstance< aspose::words::cloud::models::FileLink >(L"FileLink, _", json["SourceDocument"]);
        }
        if (json.contains("AdditionalItems") && !json["AdditionalItems"].is_null()) {
            this->m_AdditionalItems = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::FileLink>> >();
            for (auto& element : json["AdditionalItems"]) {
                this->m_AdditionalItems->emplace_back(createModelInstance< aspose::words::cloud::models::FileLink >(L"FileLink, _", element));
            }
        }
    }

    void SaveResult::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void SaveResult::validate()
    {

        if (this->m_DestDocument != nullptr)
        {
            this->m_DestDocument->validate();
        }



        if (this->m_SourceDocument != nullptr)
        {
            this->m_SourceDocument->validate();
        }



        if (this->m_AdditionalItems != nullptr)
        {
            for (auto& elementAdditionalItems : *(this->m_AdditionalItems))
            {
                if (elementAdditionalItems != nullptr)
                {
                    elementAdditionalItems->validate();
                }
            }
        }

    }

    std::shared_ptr< aspose::words::cloud::models::FileLink > SaveResult::getDestDocument() const
    {
        return this->m_DestDocument;
    }

    void SaveResult::setDestDocument(std::shared_ptr< aspose::words::cloud::models::FileLink > value)
    {
        this->m_DestDocument = value;
    }


    std::shared_ptr< aspose::words::cloud::models::FileLink > SaveResult::getSourceDocument() const
    {
        return this->m_SourceDocument;
    }

    void SaveResult::setSourceDocument(std::shared_ptr< aspose::words::cloud::models::FileLink > value)
    {
        this->m_SourceDocument = value;
    }


    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::FileLink>> > SaveResult::getAdditionalItems() const
    {
        return this->m_AdditionalItems;
    }

    void SaveResult::setAdditionalItems(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::FileLink>> > value)
    {
        this->m_AdditionalItems = value;
    }



    /*
     * SearchResponse implementation
     */
    void SearchResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SearchingPattern) {
            json["SearchingPattern"] = convertUtf16(*(this->m_SearchingPattern));
        }
        if (this->m_SearchResults) {
            this->m_SearchResults->toJson(&json["SearchResults"]);
        }
    }

    void SearchResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SearchingPattern") && !json["SearchingPattern"].is_null()) {
            this->m_SearchingPattern = std::make_shared< std::wstring >(
                convertUtf8( json["SearchingPattern"].get< std::string >() )
            );
        }
        if (json.contains("SearchResults") && !json["SearchResults"].is_null()) {
            this->m_SearchResults = createModelInstance< aspose::words::cloud::models::SearchResultsCollection >(L"SearchResultsCollection, _", json["SearchResults"]);
        }
    }

    void SearchResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void SearchResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_SearchResults != nullptr)
        {
            this->m_SearchResults->validate();
        }

    }

    std::shared_ptr< std::wstring > SearchResponse::getSearchingPattern() const
    {
        return this->m_SearchingPattern;
    }

    void SearchResponse::setSearchingPattern(std::shared_ptr< std::wstring > value)
    {
        this->m_SearchingPattern = value;
    }


    std::shared_ptr< aspose::words::cloud::models::SearchResultsCollection > SearchResponse::getSearchResults() const
    {
        return this->m_SearchResults;
    }

    void SearchResponse::setSearchResults(std::shared_ptr< aspose::words::cloud::models::SearchResultsCollection > value)
    {
        this->m_SearchResults = value;
    }



    /*
     * SearchResult implementation
     */
    void SearchResult::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_RangeStart) {
            this->m_RangeStart->toJson(&json["RangeStart"]);
        }
        if (this->m_RangeEnd) {
            this->m_RangeEnd->toJson(&json["RangeEnd"]);
        }
    }

    void SearchResult::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("RangeStart") && !json["RangeStart"].is_null()) {
            this->m_RangeStart = createModelInstance< aspose::words::cloud::models::DocumentPosition >(L"DocumentPosition, _", json["RangeStart"]);
        }
        if (json.contains("RangeEnd") && !json["RangeEnd"].is_null()) {
            this->m_RangeEnd = createModelInstance< aspose::words::cloud::models::DocumentPosition >(L"DocumentPosition, _", json["RangeEnd"]);
        }
    }

    void SearchResult::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void SearchResult::validate()
    {

        if (this->m_RangeStart != nullptr)
        {
            this->m_RangeStart->validate();
        }



        if (this->m_RangeEnd != nullptr)
        {
            this->m_RangeEnd->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::DocumentPosition > SearchResult::getRangeStart() const
    {
        return this->m_RangeStart;
    }

    void SearchResult::setRangeStart(std::shared_ptr< aspose::words::cloud::models::DocumentPosition > value)
    {
        this->m_RangeStart = value;
    }


    std::shared_ptr< aspose::words::cloud::models::DocumentPosition > SearchResult::getRangeEnd() const
    {
        return this->m_RangeEnd;
    }

    void SearchResult::setRangeEnd(std::shared_ptr< aspose::words::cloud::models::DocumentPosition > value)
    {
        this->m_RangeEnd = value;
    }



    /*
     * SearchResultsCollection implementation
     */
    void SearchResultsCollection::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ResultsList) {
            json["ResultsList"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_ResultsList)) {
                element->toJson(&json["ResultsList"].emplace_back());
            }
        }
    }

    void SearchResultsCollection::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ResultsList") && !json["ResultsList"].is_null()) {
            this->m_ResultsList = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::SearchResult>> >();
            for (auto& element : json["ResultsList"]) {
                this->m_ResultsList->emplace_back(createModelInstance< aspose::words::cloud::models::SearchResult >(L"SearchResult, _", element));
            }
        }
    }

    void SearchResultsCollection::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void SearchResultsCollection::validate()
    {
        LinkElement::validate();

        if (this->m_ResultsList != nullptr)
        {
            for (auto& elementResultsList : *(this->m_ResultsList))
            {
                if (elementResultsList != nullptr)
                {
                    elementResultsList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::SearchResult>> > SearchResultsCollection::getResultsList() const
    {
        return this->m_ResultsList;
    }

    void SearchResultsCollection::setResultsList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::SearchResult>> > value)
    {
        this->m_ResultsList = value;
    }



    /*
     * Section implementation
     */
    void Section::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ChildNodes) {
            json["ChildNodes"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_ChildNodes)) {
                element->toJson(&json["ChildNodes"].emplace_back());
            }
        }
        if (this->m_Paragraphs) {
            this->m_Paragraphs->toJson(&json["Paragraphs"]);
        }
        if (this->m_PageSetup) {
            this->m_PageSetup->toJson(&json["PageSetup"]);
        }
        if (this->m_HeaderFooters) {
            this->m_HeaderFooters->toJson(&json["HeaderFooters"]);
        }
        if (this->m_Tables) {
            this->m_Tables->toJson(&json["Tables"]);
        }
    }

    void Section::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ChildNodes") && !json["ChildNodes"].is_null()) {
            this->m_ChildNodes = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::NodeLink>> >();
            for (auto& element : json["ChildNodes"]) {
                this->m_ChildNodes->emplace_back(createModelInstance< aspose::words::cloud::models::NodeLink >(L"NodeLink, _", element));
            }
        }
        if (json.contains("Paragraphs") && !json["Paragraphs"].is_null()) {
            this->m_Paragraphs = createModelInstance< aspose::words::cloud::models::LinkElement >(L"LinkElement, _", json["Paragraphs"]);
        }
        if (json.contains("PageSetup") && !json["PageSetup"].is_null()) {
            this->m_PageSetup = createModelInstance< aspose::words::cloud::models::LinkElement >(L"LinkElement, _", json["PageSetup"]);
        }
        if (json.contains("HeaderFooters") && !json["HeaderFooters"].is_null()) {
            this->m_HeaderFooters = createModelInstance< aspose::words::cloud::models::LinkElement >(L"LinkElement, _", json["HeaderFooters"]);
        }
        if (json.contains("Tables") && !json["Tables"].is_null()) {
            this->m_Tables = createModelInstance< aspose::words::cloud::models::LinkElement >(L"LinkElement, _", json["Tables"]);
        }
    }

    void Section::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Section::validate()
    {
        LinkElement::validate();

        if (this->m_ChildNodes != nullptr)
        {
            for (auto& elementChildNodes : *(this->m_ChildNodes))
            {
                if (elementChildNodes != nullptr)
                {
                    elementChildNodes->validate();
                }
            }
        }



        if (this->m_Paragraphs != nullptr)
        {
            this->m_Paragraphs->validate();
        }



        if (this->m_PageSetup != nullptr)
        {
            this->m_PageSetup->validate();
        }



        if (this->m_HeaderFooters != nullptr)
        {
            this->m_HeaderFooters->validate();
        }



        if (this->m_Tables != nullptr)
        {
            this->m_Tables->validate();
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::NodeLink>> > Section::getChildNodes() const
    {
        return this->m_ChildNodes;
    }

    void Section::setChildNodes(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::NodeLink>> > value)
    {
        this->m_ChildNodes = value;
    }


    std::shared_ptr< aspose::words::cloud::models::LinkElement > Section::getParagraphs() const
    {
        return this->m_Paragraphs;
    }

    void Section::setParagraphs(std::shared_ptr< aspose::words::cloud::models::LinkElement > value)
    {
        this->m_Paragraphs = value;
    }


    std::shared_ptr< aspose::words::cloud::models::LinkElement > Section::getPageSetup() const
    {
        return this->m_PageSetup;
    }

    void Section::setPageSetup(std::shared_ptr< aspose::words::cloud::models::LinkElement > value)
    {
        this->m_PageSetup = value;
    }


    std::shared_ptr< aspose::words::cloud::models::LinkElement > Section::getHeaderFooters() const
    {
        return this->m_HeaderFooters;
    }

    void Section::setHeaderFooters(std::shared_ptr< aspose::words::cloud::models::LinkElement > value)
    {
        this->m_HeaderFooters = value;
    }


    std::shared_ptr< aspose::words::cloud::models::LinkElement > Section::getTables() const
    {
        return this->m_Tables;
    }

    void Section::setTables(std::shared_ptr< aspose::words::cloud::models::LinkElement > value)
    {
        this->m_Tables = value;
    }



    /*
     * SectionLink implementation
     */
    void SectionLink::toJson(void* jsonIfc) const
    {
        NodeLink::toJson(jsonIfc);
    }

    void SectionLink::fromJson(const void* jsonIfc)
    {
        NodeLink::fromJson(jsonIfc);
    }

    void SectionLink::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void SectionLink::validate()
    {
        NodeLink::validate();
    }




    /*
     * SectionLinkCollection implementation
     */
    void SectionLinkCollection::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SectionLinkList) {
            json["SectionLinkList"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_SectionLinkList)) {
                element->toJson(&json["SectionLinkList"].emplace_back());
            }
        }
    }

    void SectionLinkCollection::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SectionLinkList") && !json["SectionLinkList"].is_null()) {
            this->m_SectionLinkList = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::SectionLink>> >();
            for (auto& element : json["SectionLinkList"]) {
                this->m_SectionLinkList->emplace_back(createModelInstance< aspose::words::cloud::models::SectionLink >(L"SectionLink, _", element));
            }
        }
    }

    void SectionLinkCollection::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void SectionLinkCollection::validate()
    {
        LinkElement::validate();

        if (this->m_SectionLinkList != nullptr)
        {
            for (auto& elementSectionLinkList : *(this->m_SectionLinkList))
            {
                if (elementSectionLinkList != nullptr)
                {
                    elementSectionLinkList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::SectionLink>> > SectionLinkCollection::getSectionLinkList() const
    {
        return this->m_SectionLinkList;
    }

    void SectionLinkCollection::setSectionLinkList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::SectionLink>> > value)
    {
        this->m_SectionLinkList = value;
    }



    /*
     * SectionLinkCollectionResponse implementation
     */
    void SectionLinkCollectionResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Sections) {
            this->m_Sections->toJson(&json["Sections"]);
        }
    }

    void SectionLinkCollectionResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Sections") && !json["Sections"].is_null()) {
            this->m_Sections = createModelInstance< aspose::words::cloud::models::SectionLinkCollection >(L"SectionLinkCollection, _", json["Sections"]);
        }
    }

    void SectionLinkCollectionResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void SectionLinkCollectionResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Sections != nullptr)
        {
            this->m_Sections->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::SectionLinkCollection > SectionLinkCollectionResponse::getSections() const
    {
        return this->m_Sections;
    }

    void SectionLinkCollectionResponse::setSections(std::shared_ptr< aspose::words::cloud::models::SectionLinkCollection > value)
    {
        this->m_Sections = value;
    }



    /*
     * SectionPageSetupResponse implementation
     */
    void SectionPageSetupResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_PageSetup) {
            this->m_PageSetup->toJson(&json["PageSetup"]);
        }
    }

    void SectionPageSetupResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("PageSetup") && !json["PageSetup"].is_null()) {
            this->m_PageSetup = createModelInstance< aspose::words::cloud::models::PageSetup >(L"PageSetup, _", json["PageSetup"]);
        }
    }

    void SectionPageSetupResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void SectionPageSetupResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_PageSetup != nullptr)
        {
            this->m_PageSetup->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::PageSetup > SectionPageSetupResponse::getPageSetup() const
    {
        return this->m_PageSetup;
    }

    void SectionPageSetupResponse::setPageSetup(std::shared_ptr< aspose::words::cloud::models::PageSetup > value)
    {
        this->m_PageSetup = value;
    }



    /*
     * SectionResponse implementation
     */
    void SectionResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Section) {
            this->m_Section->toJson(&json["Section"]);
        }
    }

    void SectionResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Section") && !json["Section"].is_null()) {
            this->m_Section = createModelInstance< aspose::words::cloud::models::Section >(L"Section, _", json["Section"]);
        }
    }

    void SectionResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void SectionResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Section != nullptr)
        {
            this->m_Section->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Section > SectionResponse::getSection() const
    {
        return this->m_Section;
    }

    void SectionResponse::setSection(std::shared_ptr< aspose::words::cloud::models::Section > value)
    {
        this->m_Section = value;
    }



    /*
     * Shading implementation
     */
    inline std::string shadingTextureToString(aspose::words::cloud::models::Shading::Texture value)
    {
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE_NONE) return "TextureNone";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE_SOLID) return "TextureSolid";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE5_PERCENT) return "Texture5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE10_PERCENT) return "Texture10Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE20_PERCENT) return "Texture20Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE25_PERCENT) return "Texture25Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE30_PERCENT) return "Texture30Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE40_PERCENT) return "Texture40Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE50_PERCENT) return "Texture50Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE60_PERCENT) return "Texture60Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE70_PERCENT) return "Texture70Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE75_PERCENT) return "Texture75Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE80_PERCENT) return "Texture80Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE90_PERCENT) return "Texture90Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE_DARK_HORIZONTAL) return "TextureDarkHorizontal";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE_DARK_VERTICAL) return "TextureDarkVertical";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE_DARK_DIAGONAL_DOWN) return "TextureDarkDiagonalDown";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE_DARK_DIAGONAL_UP) return "TextureDarkDiagonalUp";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE_DARK_CROSS) return "TextureDarkCross";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE_DARK_DIAGONAL_CROSS) return "TextureDarkDiagonalCross";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE_HORIZONTAL) return "TextureHorizontal";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE_VERTICAL) return "TextureVertical";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE_DIAGONAL_DOWN) return "TextureDiagonalDown";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE_DIAGONAL_UP) return "TextureDiagonalUp";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE_CROSS) return "TextureCross";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE_DIAGONAL_CROSS) return "TextureDiagonalCross";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE2_PT5_PERCENT) return "Texture2Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE7_PT5_PERCENT) return "Texture7Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE12_PT5_PERCENT) return "Texture12Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE15_PERCENT) return "Texture15Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE17_PT5_PERCENT) return "Texture17Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE22_PT5_PERCENT) return "Texture22Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE27_PT5_PERCENT) return "Texture27Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE32_PT5_PERCENT) return "Texture32Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE35_PERCENT) return "Texture35Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE37_PT5_PERCENT) return "Texture37Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE42_PT5_PERCENT) return "Texture42Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE45_PERCENT) return "Texture45Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE47_PT5_PERCENT) return "Texture47Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE52_PT5_PERCENT) return "Texture52Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE55_PERCENT) return "Texture55Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE57_PT5_PERCENT) return "Texture57Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE62_PT5_PERCENT) return "Texture62Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE65_PERCENT) return "Texture65Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE67_PT5_PERCENT) return "Texture67Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE72_PT5_PERCENT) return "Texture72Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE77_PT5_PERCENT) return "Texture77Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE82_PT5_PERCENT) return "Texture82Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE85_PERCENT) return "Texture85Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE87_PT5_PERCENT) return "Texture87Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE92_PT5_PERCENT) return "Texture92Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE95_PERCENT) return "Texture95Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE97_PT5_PERCENT) return "Texture97Pt5Percent";
        if (value == aspose::words::cloud::models::Shading::Texture::TEXTURE_NIL) return "TextureNil";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::Shading::Texture shadingTextureFromString(const std::string& value)
    {
        if (value == "TextureNone") return aspose::words::cloud::models::Shading::Texture::TEXTURE_NONE;
        if (value == "TextureSolid") return aspose::words::cloud::models::Shading::Texture::TEXTURE_SOLID;
        if (value == "Texture5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE5_PERCENT;
        if (value == "Texture10Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE10_PERCENT;
        if (value == "Texture20Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE20_PERCENT;
        if (value == "Texture25Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE25_PERCENT;
        if (value == "Texture30Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE30_PERCENT;
        if (value == "Texture40Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE40_PERCENT;
        if (value == "Texture50Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE50_PERCENT;
        if (value == "Texture60Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE60_PERCENT;
        if (value == "Texture70Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE70_PERCENT;
        if (value == "Texture75Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE75_PERCENT;
        if (value == "Texture80Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE80_PERCENT;
        if (value == "Texture90Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE90_PERCENT;
        if (value == "TextureDarkHorizontal") return aspose::words::cloud::models::Shading::Texture::TEXTURE_DARK_HORIZONTAL;
        if (value == "TextureDarkVertical") return aspose::words::cloud::models::Shading::Texture::TEXTURE_DARK_VERTICAL;
        if (value == "TextureDarkDiagonalDown") return aspose::words::cloud::models::Shading::Texture::TEXTURE_DARK_DIAGONAL_DOWN;
        if (value == "TextureDarkDiagonalUp") return aspose::words::cloud::models::Shading::Texture::TEXTURE_DARK_DIAGONAL_UP;
        if (value == "TextureDarkCross") return aspose::words::cloud::models::Shading::Texture::TEXTURE_DARK_CROSS;
        if (value == "TextureDarkDiagonalCross") return aspose::words::cloud::models::Shading::Texture::TEXTURE_DARK_DIAGONAL_CROSS;
        if (value == "TextureHorizontal") return aspose::words::cloud::models::Shading::Texture::TEXTURE_HORIZONTAL;
        if (value == "TextureVertical") return aspose::words::cloud::models::Shading::Texture::TEXTURE_VERTICAL;
        if (value == "TextureDiagonalDown") return aspose::words::cloud::models::Shading::Texture::TEXTURE_DIAGONAL_DOWN;
        if (value == "TextureDiagonalUp") return aspose::words::cloud::models::Shading::Texture::TEXTURE_DIAGONAL_UP;
        if (value == "TextureCross") return aspose::words::cloud::models::Shading::Texture::TEXTURE_CROSS;
        if (value == "TextureDiagonalCross") return aspose::words::cloud::models::Shading::Texture::TEXTURE_DIAGONAL_CROSS;
        if (value == "Texture2Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE2_PT5_PERCENT;
        if (value == "Texture7Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE7_PT5_PERCENT;
        if (value == "Texture12Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE12_PT5_PERCENT;
        if (value == "Texture15Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE15_PERCENT;
        if (value == "Texture17Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE17_PT5_PERCENT;
        if (value == "Texture22Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE22_PT5_PERCENT;
        if (value == "Texture27Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE27_PT5_PERCENT;
        if (value == "Texture32Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE32_PT5_PERCENT;
        if (value == "Texture35Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE35_PERCENT;
        if (value == "Texture37Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE37_PT5_PERCENT;
        if (value == "Texture42Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE42_PT5_PERCENT;
        if (value == "Texture45Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE45_PERCENT;
        if (value == "Texture47Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE47_PT5_PERCENT;
        if (value == "Texture52Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE52_PT5_PERCENT;
        if (value == "Texture55Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE55_PERCENT;
        if (value == "Texture57Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE57_PT5_PERCENT;
        if (value == "Texture62Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE62_PT5_PERCENT;
        if (value == "Texture65Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE65_PERCENT;
        if (value == "Texture67Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE67_PT5_PERCENT;
        if (value == "Texture72Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE72_PT5_PERCENT;
        if (value == "Texture77Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE77_PT5_PERCENT;
        if (value == "Texture82Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE82_PT5_PERCENT;
        if (value == "Texture85Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE85_PERCENT;
        if (value == "Texture87Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE87_PT5_PERCENT;
        if (value == "Texture92Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE92_PT5_PERCENT;
        if (value == "Texture95Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE95_PERCENT;
        if (value == "Texture97Pt5Percent") return aspose::words::cloud::models::Shading::Texture::TEXTURE97_PT5_PERCENT;
        if (value == "TextureNil") return aspose::words::cloud::models::Shading::Texture::TEXTURE_NIL;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void Shading::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_BackgroundPatternColor) {
            this->m_BackgroundPatternColor->toJson(&json["BackgroundPatternColor"]);
        }
        if (this->m_ForegroundPatternColor) {
            this->m_ForegroundPatternColor->toJson(&json["ForegroundPatternColor"]);
        }
        if (this->m_Texture) {
            json["Texture"] = shadingTextureToString(*(this->m_Texture));
        }
    }

    void Shading::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("BackgroundPatternColor") && !json["BackgroundPatternColor"].is_null()) {
            this->m_BackgroundPatternColor = createModelInstance< aspose::words::cloud::models::XmlColor >(L"XmlColor, _", json["BackgroundPatternColor"]);
        }
        if (json.contains("ForegroundPatternColor") && !json["ForegroundPatternColor"].is_null()) {
            this->m_ForegroundPatternColor = createModelInstance< aspose::words::cloud::models::XmlColor >(L"XmlColor, _", json["ForegroundPatternColor"]);
        }
        if (json.contains("Texture") && !json["Texture"].is_null()) {
            this->m_Texture = std::make_shared< aspose::words::cloud::models::Shading::Texture >(
                shadingTextureFromString(json["Texture"].get< std::string >())
            );
        }
    }

    void Shading::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Shading::validate()
    {

        if (this->m_BackgroundPatternColor != nullptr)
        {
            this->m_BackgroundPatternColor->validate();
        }



        if (this->m_ForegroundPatternColor != nullptr)
        {
            this->m_ForegroundPatternColor->validate();
        }


    }

    std::shared_ptr< aspose::words::cloud::models::XmlColor > Shading::getBackgroundPatternColor() const
    {
        return this->m_BackgroundPatternColor;
    }

    void Shading::setBackgroundPatternColor(std::shared_ptr< aspose::words::cloud::models::XmlColor > value)
    {
        this->m_BackgroundPatternColor = value;
    }


    std::shared_ptr< aspose::words::cloud::models::XmlColor > Shading::getForegroundPatternColor() const
    {
        return this->m_ForegroundPatternColor;
    }

    void Shading::setForegroundPatternColor(std::shared_ptr< aspose::words::cloud::models::XmlColor > value)
    {
        this->m_ForegroundPatternColor = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Shading::Texture > Shading::getTexture() const
    {
        return this->m_Texture;
    }

    void Shading::setTexture(std::shared_ptr< aspose::words::cloud::models::Shading::Texture > value)
    {
        this->m_Texture = value;
    }



    /*
     * SplitDocumentResponse implementation
     */
    void SplitDocumentResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SplitResult) {
            this->m_SplitResult->toJson(&json["SplitResult"]);
        }
    }

    void SplitDocumentResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SplitResult") && !json["SplitResult"].is_null()) {
            this->m_SplitResult = createModelInstance< aspose::words::cloud::models::SplitDocumentResult >(L"SplitDocumentResult, _", json["SplitResult"]);
        }
    }

    void SplitDocumentResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void SplitDocumentResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_SplitResult != nullptr)
        {
            this->m_SplitResult->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::SplitDocumentResult > SplitDocumentResponse::getSplitResult() const
    {
        return this->m_SplitResult;
    }

    void SplitDocumentResponse::setSplitResult(std::shared_ptr< aspose::words::cloud::models::SplitDocumentResult > value)
    {
        this->m_SplitResult = value;
    }



    /*
     * SplitDocumentResult implementation
     */
    void SplitDocumentResult::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SourceDocument) {
            this->m_SourceDocument->toJson(&json["SourceDocument"]);
        }
        if (this->m_ZippedPages) {
            this->m_ZippedPages->toJson(&json["ZippedPages"]);
        }
        if (this->m_Pages) {
            json["Pages"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_Pages)) {
                element->toJson(&json["Pages"].emplace_back());
            }
        }
    }

    void SplitDocumentResult::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SourceDocument") && !json["SourceDocument"].is_null()) {
            this->m_SourceDocument = createModelInstance< aspose::words::cloud::models::FileLink >(L"FileLink, _", json["SourceDocument"]);
        }
        if (json.contains("ZippedPages") && !json["ZippedPages"].is_null()) {
            this->m_ZippedPages = createModelInstance< aspose::words::cloud::models::FileLink >(L"FileLink, _", json["ZippedPages"]);
        }
        if (json.contains("Pages") && !json["Pages"].is_null()) {
            this->m_Pages = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::FileLink>> >();
            for (auto& element : json["Pages"]) {
                this->m_Pages->emplace_back(createModelInstance< aspose::words::cloud::models::FileLink >(L"FileLink, _", element));
            }
        }
    }

    void SplitDocumentResult::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void SplitDocumentResult::validate()
    {

        if (this->m_SourceDocument != nullptr)
        {
            this->m_SourceDocument->validate();
        }



        if (this->m_ZippedPages != nullptr)
        {
            this->m_ZippedPages->validate();
        }



        if (this->m_Pages != nullptr)
        {
            for (auto& elementPages : *(this->m_Pages))
            {
                if (elementPages != nullptr)
                {
                    elementPages->validate();
                }
            }
        }

    }

    std::shared_ptr< aspose::words::cloud::models::FileLink > SplitDocumentResult::getSourceDocument() const
    {
        return this->m_SourceDocument;
    }

    void SplitDocumentResult::setSourceDocument(std::shared_ptr< aspose::words::cloud::models::FileLink > value)
    {
        this->m_SourceDocument = value;
    }


    std::shared_ptr< aspose::words::cloud::models::FileLink > SplitDocumentResult::getZippedPages() const
    {
        return this->m_ZippedPages;
    }

    void SplitDocumentResult::setZippedPages(std::shared_ptr< aspose::words::cloud::models::FileLink > value)
    {
        this->m_ZippedPages = value;
    }


    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::FileLink>> > SplitDocumentResult::getPages() const
    {
        return this->m_Pages;
    }

    void SplitDocumentResult::setPages(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::FileLink>> > value)
    {
        this->m_Pages = value;
    }



    /*
     * StatDataResponse implementation
     */
    void StatDataResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_DocumentLink) {
            this->m_DocumentLink->toJson(&json["DocumentLink"]);
        }
        if (this->m_StatData) {
            this->m_StatData->toJson(&json["StatData"]);
        }
    }

    void StatDataResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("DocumentLink") && !json["DocumentLink"].is_null()) {
            this->m_DocumentLink = createModelInstance< aspose::words::cloud::models::FileLink >(L"FileLink, _", json["DocumentLink"]);
        }
        if (json.contains("StatData") && !json["StatData"].is_null()) {
            this->m_StatData = createModelInstance< aspose::words::cloud::models::DocumentStatData >(L"DocumentStatData, _", json["StatData"]);
        }
    }

    void StatDataResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StatDataResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_DocumentLink != nullptr)
        {
            this->m_DocumentLink->validate();
        }



        if (this->m_StatData != nullptr)
        {
            this->m_StatData->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::FileLink > StatDataResponse::getDocumentLink() const
    {
        return this->m_DocumentLink;
    }

    void StatDataResponse::setDocumentLink(std::shared_ptr< aspose::words::cloud::models::FileLink > value)
    {
        this->m_DocumentLink = value;
    }


    std::shared_ptr< aspose::words::cloud::models::DocumentStatData > StatDataResponse::getStatData() const
    {
        return this->m_StatData;
    }

    void StatDataResponse::setStatData(std::shared_ptr< aspose::words::cloud::models::DocumentStatData > value)
    {
        this->m_StatData = value;
    }



    /*
     * StorageFile implementation
     */
    void StorageFile::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_IsFolder) {
            json["IsFolder"] = *(this->m_IsFolder);
        }
        if (this->m_ModifiedDate) {
            json["ModifiedDate"] = convertUtf16(*(this->m_ModifiedDate));
        }
        if (this->m_Name) {
            json["Name"] = convertUtf16(*(this->m_Name));
        }
        if (this->m_Path) {
            json["Path"] = convertUtf16(*(this->m_Path));
        }
        if (this->m_Size) {
            json["Size"] = *(this->m_Size);
        }
    }

    void StorageFile::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("IsFolder") && !json["IsFolder"].is_null()) {
            this->m_IsFolder = std::make_shared< bool >(
                json["IsFolder"].get< bool >()
            );
        }
        if (json.contains("ModifiedDate") && !json["ModifiedDate"].is_null()) {
            this->m_ModifiedDate = std::make_shared< std::wstring >(
                convertUtf8( json["ModifiedDate"].get< std::string >() )
            );
        }
        if (json.contains("Name") && !json["Name"].is_null()) {
            this->m_Name = std::make_shared< std::wstring >(
                convertUtf8( json["Name"].get< std::string >() )
            );
        }
        if (json.contains("Path") && !json["Path"].is_null()) {
            this->m_Path = std::make_shared< std::wstring >(
                convertUtf8( json["Path"].get< std::string >() )
            );
        }
        if (json.contains("Size") && !json["Size"].is_null()) {
            this->m_Size = std::make_shared< int32_t >(
                json["Size"].get< int32_t >()
            );
        }
    }

    void StorageFile::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StorageFile::validate()
    {
        if (this->m_IsFolder == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property IsFolder in StorageFile is required.");
        }

        if (this->m_Size == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Size in StorageFile is required.");
        }

    }

    std::shared_ptr< bool > StorageFile::getIsFolder() const
    {
        return this->m_IsFolder;
    }

    void StorageFile::setIsFolder(std::shared_ptr< bool > value)
    {
        this->m_IsFolder = value;
    }


    std::shared_ptr< std::wstring > StorageFile::getModifiedDate() const
    {
        return this->m_ModifiedDate;
    }

    void StorageFile::setModifiedDate(std::shared_ptr< std::wstring > value)
    {
        this->m_ModifiedDate = value;
    }


    std::shared_ptr< std::wstring > StorageFile::getName() const
    {
        return this->m_Name;
    }

    void StorageFile::setName(std::shared_ptr< std::wstring > value)
    {
        this->m_Name = value;
    }


    std::shared_ptr< std::wstring > StorageFile::getPath() const
    {
        return this->m_Path;
    }

    void StorageFile::setPath(std::shared_ptr< std::wstring > value)
    {
        this->m_Path = value;
    }


    std::shared_ptr< int32_t > StorageFile::getSize() const
    {
        return this->m_Size;
    }

    void StorageFile::setSize(std::shared_ptr< int32_t > value)
    {
        this->m_Size = value;
    }



    /*
     * StoryChildNodes implementation
     */
    void StoryChildNodes::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ChildNodes) {
            json["ChildNodes"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_ChildNodes)) {
                element->toJson(&json["ChildNodes"].emplace_back());
            }
        }
    }

    void StoryChildNodes::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ChildNodes") && !json["ChildNodes"].is_null()) {
            this->m_ChildNodes = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::NodeLink>> >();
            for (auto& element : json["ChildNodes"]) {
                this->m_ChildNodes->emplace_back(createModelInstance< aspose::words::cloud::models::NodeLink >(L"NodeLink, _", element));
            }
        }
    }

    void StoryChildNodes::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StoryChildNodes::validate()
    {

        if (this->m_ChildNodes != nullptr)
        {
            for (auto& elementChildNodes : *(this->m_ChildNodes))
            {
                if (elementChildNodes != nullptr)
                {
                    elementChildNodes->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::NodeLink>> > StoryChildNodes::getChildNodes() const
    {
        return this->m_ChildNodes;
    }

    void StoryChildNodes::setChildNodes(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::NodeLink>> > value)
    {
        this->m_ChildNodes = value;
    }



    /*
     * StructuredDocumentTag implementation
     */
    inline std::string structuredDocumentTagLevelToString(aspose::words::cloud::models::StructuredDocumentTag::Level value)
    {
        if (value == aspose::words::cloud::models::StructuredDocumentTag::Level::UNKNOWN) return "Unknown";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::Level::INLINE) return "Inline";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::Level::BLOCK) return "Block";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::Level::ROW) return "Row";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::Level::CELL) return "Cell";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::StructuredDocumentTag::Level structuredDocumentTagLevelFromString(const std::string& value)
    {
        if (value == "Unknown") return aspose::words::cloud::models::StructuredDocumentTag::Level::UNKNOWN;
        if (value == "Inline") return aspose::words::cloud::models::StructuredDocumentTag::Level::INLINE;
        if (value == "Block") return aspose::words::cloud::models::StructuredDocumentTag::Level::BLOCK;
        if (value == "Row") return aspose::words::cloud::models::StructuredDocumentTag::Level::ROW;
        if (value == "Cell") return aspose::words::cloud::models::StructuredDocumentTag::Level::CELL;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string structuredDocumentTagSdtTypeToString(aspose::words::cloud::models::StructuredDocumentTag::SdtType value)
    {
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::NONE) return "None";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::BIBLIOGRAPHY) return "Bibliography";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::CITATION) return "Citation";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::EQUATION) return "Equation";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::DROP_DOWN_LIST) return "DropDownList";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::COMBO_BOX) return "ComboBox";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::DATE) return "Date";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::BUILDING_BLOCK_GALLERY) return "BuildingBlockGallery";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::DOC_PART_OBJ) return "DocPartObj";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::GROUP) return "Group";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::PICTURE) return "Picture";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::RICH_TEXT) return "RichText";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::PLAIN_TEXT) return "PlainText";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::CHECKBOX) return "Checkbox";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::REPEATING_SECTION) return "RepeatingSection";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::REPEATING_SECTION_ITEM) return "RepeatingSectionItem";
        if (value == aspose::words::cloud::models::StructuredDocumentTag::SdtType::ENTITY_PICKER) return "EntityPicker";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::StructuredDocumentTag::SdtType structuredDocumentTagSdtTypeFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::NONE;
        if (value == "Bibliography") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::BIBLIOGRAPHY;
        if (value == "Citation") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::CITATION;
        if (value == "Equation") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::EQUATION;
        if (value == "DropDownList") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::DROP_DOWN_LIST;
        if (value == "ComboBox") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::COMBO_BOX;
        if (value == "Date") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::DATE;
        if (value == "BuildingBlockGallery") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::BUILDING_BLOCK_GALLERY;
        if (value == "DocPartObj") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::DOC_PART_OBJ;
        if (value == "Group") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::GROUP;
        if (value == "Picture") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::PICTURE;
        if (value == "RichText") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::RICH_TEXT;
        if (value == "PlainText") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::PLAIN_TEXT;
        if (value == "Checkbox") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::CHECKBOX;
        if (value == "RepeatingSection") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::REPEATING_SECTION;
        if (value == "RepeatingSectionItem") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::REPEATING_SECTION_ITEM;
        if (value == "EntityPicker") return aspose::words::cloud::models::StructuredDocumentTag::SdtType::ENTITY_PICKER;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void StructuredDocumentTag::toJson(void* jsonIfc) const
    {
        StructuredDocumentTagBase::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Level) {
            json["Level"] = structuredDocumentTagLevelToString(*(this->m_Level));
        }
        if (this->m_SdtType) {
            json["SdtType"] = structuredDocumentTagSdtTypeToString(*(this->m_SdtType));
        }
    }

    void StructuredDocumentTag::fromJson(const void* jsonIfc)
    {
        StructuredDocumentTagBase::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Level") && !json["Level"].is_null()) {
            this->m_Level = std::make_shared< aspose::words::cloud::models::StructuredDocumentTag::Level >(
                structuredDocumentTagLevelFromString(json["Level"].get< std::string >())
            );
        }
        if (json.contains("SdtType") && !json["SdtType"].is_null()) {
            this->m_SdtType = std::make_shared< aspose::words::cloud::models::StructuredDocumentTag::SdtType >(
                structuredDocumentTagSdtTypeFromString(json["SdtType"].get< std::string >())
            );
        }
    }

    void StructuredDocumentTag::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StructuredDocumentTag::validate()
    {
        StructuredDocumentTagBase::validate();
    }

    std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTag::Level > StructuredDocumentTag::getLevel() const
    {
        return this->m_Level;
    }

    void StructuredDocumentTag::setLevel(std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTag::Level > value)
    {
        this->m_Level = value;
    }


    std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTag::SdtType > StructuredDocumentTag::getSdtType() const
    {
        return this->m_SdtType;
    }

    void StructuredDocumentTag::setSdtType(std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTag::SdtType > value)
    {
        this->m_SdtType = value;
    }



    /*
     * StructuredDocumentTagBase implementation
     */
    inline std::string structuredDocumentTagBaseAppearanceToString(aspose::words::cloud::models::StructuredDocumentTagBase::Appearance value)
    {
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::Appearance::BOUNDING_BOX) return "BoundingBox";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::Appearance::DEFAULT) return "Default";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::Appearance::TAGS) return "Tags";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::Appearance::HIDDEN) return "Hidden";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::StructuredDocumentTagBase::Appearance structuredDocumentTagBaseAppearanceFromString(const std::string& value)
    {
        if (value == "BoundingBox") return aspose::words::cloud::models::StructuredDocumentTagBase::Appearance::BOUNDING_BOX;
        if (value == "Default") return aspose::words::cloud::models::StructuredDocumentTagBase::Appearance::DEFAULT;
        if (value == "Tags") return aspose::words::cloud::models::StructuredDocumentTagBase::Appearance::TAGS;
        if (value == "Hidden") return aspose::words::cloud::models::StructuredDocumentTagBase::Appearance::HIDDEN;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string structuredDocumentTagBaseDateStorageFormatToString(aspose::words::cloud::models::StructuredDocumentTagBase::DateStorageFormat value)
    {
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::DateStorageFormat::DATE) return "Date";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::DateStorageFormat::DATE_TIME) return "DateTime";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::DateStorageFormat::DEFAULT) return "Default";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::DateStorageFormat::TEXT) return "Text";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::StructuredDocumentTagBase::DateStorageFormat structuredDocumentTagBaseDateStorageFormatFromString(const std::string& value)
    {
        if (value == "Date") return aspose::words::cloud::models::StructuredDocumentTagBase::DateStorageFormat::DATE;
        if (value == "DateTime") return aspose::words::cloud::models::StructuredDocumentTagBase::DateStorageFormat::DATE_TIME;
        if (value == "Default") return aspose::words::cloud::models::StructuredDocumentTagBase::DateStorageFormat::DEFAULT;
        if (value == "Text") return aspose::words::cloud::models::StructuredDocumentTagBase::DateStorageFormat::TEXT;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string structuredDocumentTagBaseCalendarTypeToString(aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType value)
    {
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::DEFAULT) return "Default";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::GREGORIAN) return "Gregorian";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::GREGORIAN_ARABIC) return "GregorianArabic";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::GREGORIAN_ME_FRENCH) return "GregorianMeFrench";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::GREGORIAN_US) return "GregorianUs";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::GREGORIAN_XLIT_ENGLISH) return "GregorianXlitEnglish";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::GREGORIAN_XLIT_FRENCH) return "GregorianXlitFrench";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::HEBREW) return "Hebrew";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::HIJRI) return "Hijri";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::JAPAN) return "Japan";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::KOREA) return "Korea";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::NONE) return "None";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::SAKA) return "Saka";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::TAIWAN) return "Taiwan";
        if (value == aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::THAI) return "Thai";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType structuredDocumentTagBaseCalendarTypeFromString(const std::string& value)
    {
        if (value == "Default") return aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::DEFAULT;
        if (value == "Gregorian") return aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::GREGORIAN;
        if (value == "GregorianArabic") return aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::GREGORIAN_ARABIC;
        if (value == "GregorianMeFrench") return aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::GREGORIAN_ME_FRENCH;
        if (value == "GregorianUs") return aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::GREGORIAN_US;
        if (value == "GregorianXlitEnglish") return aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::GREGORIAN_XLIT_ENGLISH;
        if (value == "GregorianXlitFrench") return aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::GREGORIAN_XLIT_FRENCH;
        if (value == "Hebrew") return aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::HEBREW;
        if (value == "Hijri") return aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::HIJRI;
        if (value == "Japan") return aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::JAPAN;
        if (value == "Korea") return aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::KOREA;
        if (value == "None") return aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::NONE;
        if (value == "Saka") return aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::SAKA;
        if (value == "Taiwan") return aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::TAIWAN;
        if (value == "Thai") return aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType::THAI;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void StructuredDocumentTagBase::toJson(void* jsonIfc) const
    {
        NodeLink::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ListItems) {
            json["ListItems"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_ListItems)) {
                element->toJson(&json["ListItems"].emplace_back());
            }
        }
        if (this->m_Checked) {
            json["Checked"] = *(this->m_Checked);
        }
        if (this->m_Appearance) {
            json["Appearance"] = structuredDocumentTagBaseAppearanceToString(*(this->m_Appearance));
        }
        if (this->m_DateDisplayLocale) {
            json["DateDisplayLocale"] = *(this->m_DateDisplayLocale);
        }
        if (this->m_DateDisplayFormat) {
            json["DateDisplayFormat"] = convertUtf16(*(this->m_DateDisplayFormat));
        }
        if (this->m_FullDate) {
            json["FullDate"] = convertUtf16(*(this->m_FullDate));
        }
        if (this->m_Title) {
            json["Title"] = convertUtf16(*(this->m_Title));
        }
        if (this->m_DateStorageFormat) {
            json["DateStorageFormat"] = structuredDocumentTagBaseDateStorageFormatToString(*(this->m_DateStorageFormat));
        }
        if (this->m_BuildingBlockGallery) {
            json["BuildingBlockGallery"] = convertUtf16(*(this->m_BuildingBlockGallery));
        }
        if (this->m_BuildingBlockCategory) {
            json["BuildingBlockCategory"] = convertUtf16(*(this->m_BuildingBlockCategory));
        }
        if (this->m_Multiline) {
            json["Multiline"] = *(this->m_Multiline);
        }
        if (this->m_Color) {
            this->m_Color->toJson(&json["Color"]);
        }
        if (this->m_StyleName) {
            json["StyleName"] = convertUtf16(*(this->m_StyleName));
        }
        if (this->m_CalendarType) {
            json["CalendarType"] = structuredDocumentTagBaseCalendarTypeToString(*(this->m_CalendarType));
        }
        if (this->m_IsTemporary) {
            json["IsTemporary"] = *(this->m_IsTemporary);
        }
        if (this->m_PlaceholderName) {
            json["PlaceholderName"] = convertUtf16(*(this->m_PlaceholderName));
        }
        if (this->m_LockContentControl) {
            json["LockContentControl"] = *(this->m_LockContentControl);
        }
        if (this->m_LockContents) {
            json["LockContents"] = *(this->m_LockContents);
        }
        if (this->m_IsShowingPlaceholderText) {
            json["IsShowingPlaceholderText"] = *(this->m_IsShowingPlaceholderText);
        }
        if (this->m_Tag) {
            json["Tag"] = convertUtf16(*(this->m_Tag));
        }
        if (this->m_Id) {
            json["Id"] = *(this->m_Id);
        }
        if (this->m_WordOpenXML) {
            json["WordOpenXML"] = convertUtf16(*(this->m_WordOpenXML));
        }
    }

    void StructuredDocumentTagBase::fromJson(const void* jsonIfc)
    {
        NodeLink::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ListItems") && !json["ListItems"].is_null()) {
            this->m_ListItems = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::StructuredDocumentTagListItem>> >();
            for (auto& element : json["ListItems"]) {
                this->m_ListItems->emplace_back(createModelInstance< aspose::words::cloud::models::StructuredDocumentTagListItem >(L"StructuredDocumentTagListItem, _", element));
            }
        }
        if (json.contains("Checked") && !json["Checked"].is_null()) {
            this->m_Checked = std::make_shared< bool >(
                json["Checked"].get< bool >()
            );
        }
        if (json.contains("Appearance") && !json["Appearance"].is_null()) {
            this->m_Appearance = std::make_shared< aspose::words::cloud::models::StructuredDocumentTagBase::Appearance >(
                structuredDocumentTagBaseAppearanceFromString(json["Appearance"].get< std::string >())
            );
        }
        if (json.contains("DateDisplayLocale") && !json["DateDisplayLocale"].is_null()) {
            this->m_DateDisplayLocale = std::make_shared< int32_t >(
                json["DateDisplayLocale"].get< int32_t >()
            );
        }
        if (json.contains("DateDisplayFormat") && !json["DateDisplayFormat"].is_null()) {
            this->m_DateDisplayFormat = std::make_shared< std::wstring >(
                convertUtf8( json["DateDisplayFormat"].get< std::string >() )
            );
        }
        if (json.contains("FullDate") && !json["FullDate"].is_null()) {
            this->m_FullDate = std::make_shared< std::wstring >(
                convertUtf8( json["FullDate"].get< std::string >() )
            );
        }
        if (json.contains("Title") && !json["Title"].is_null()) {
            this->m_Title = std::make_shared< std::wstring >(
                convertUtf8( json["Title"].get< std::string >() )
            );
        }
        if (json.contains("DateStorageFormat") && !json["DateStorageFormat"].is_null()) {
            this->m_DateStorageFormat = std::make_shared< aspose::words::cloud::models::StructuredDocumentTagBase::DateStorageFormat >(
                structuredDocumentTagBaseDateStorageFormatFromString(json["DateStorageFormat"].get< std::string >())
            );
        }
        if (json.contains("BuildingBlockGallery") && !json["BuildingBlockGallery"].is_null()) {
            this->m_BuildingBlockGallery = std::make_shared< std::wstring >(
                convertUtf8( json["BuildingBlockGallery"].get< std::string >() )
            );
        }
        if (json.contains("BuildingBlockCategory") && !json["BuildingBlockCategory"].is_null()) {
            this->m_BuildingBlockCategory = std::make_shared< std::wstring >(
                convertUtf8( json["BuildingBlockCategory"].get< std::string >() )
            );
        }
        if (json.contains("Multiline") && !json["Multiline"].is_null()) {
            this->m_Multiline = std::make_shared< bool >(
                json["Multiline"].get< bool >()
            );
        }
        if (json.contains("Color") && !json["Color"].is_null()) {
            this->m_Color = createModelInstance< aspose::words::cloud::models::XmlColor >(L"XmlColor, _", json["Color"]);
        }
        if (json.contains("StyleName") && !json["StyleName"].is_null()) {
            this->m_StyleName = std::make_shared< std::wstring >(
                convertUtf8( json["StyleName"].get< std::string >() )
            );
        }
        if (json.contains("CalendarType") && !json["CalendarType"].is_null()) {
            this->m_CalendarType = std::make_shared< aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType >(
                structuredDocumentTagBaseCalendarTypeFromString(json["CalendarType"].get< std::string >())
            );
        }
        if (json.contains("IsTemporary") && !json["IsTemporary"].is_null()) {
            this->m_IsTemporary = std::make_shared< bool >(
                json["IsTemporary"].get< bool >()
            );
        }
        if (json.contains("PlaceholderName") && !json["PlaceholderName"].is_null()) {
            this->m_PlaceholderName = std::make_shared< std::wstring >(
                convertUtf8( json["PlaceholderName"].get< std::string >() )
            );
        }
        if (json.contains("LockContentControl") && !json["LockContentControl"].is_null()) {
            this->m_LockContentControl = std::make_shared< bool >(
                json["LockContentControl"].get< bool >()
            );
        }
        if (json.contains("LockContents") && !json["LockContents"].is_null()) {
            this->m_LockContents = std::make_shared< bool >(
                json["LockContents"].get< bool >()
            );
        }
        if (json.contains("IsShowingPlaceholderText") && !json["IsShowingPlaceholderText"].is_null()) {
            this->m_IsShowingPlaceholderText = std::make_shared< bool >(
                json["IsShowingPlaceholderText"].get< bool >()
            );
        }
        if (json.contains("Tag") && !json["Tag"].is_null()) {
            this->m_Tag = std::make_shared< std::wstring >(
                convertUtf8( json["Tag"].get< std::string >() )
            );
        }
        if (json.contains("Id") && !json["Id"].is_null()) {
            this->m_Id = std::make_shared< int32_t >(
                json["Id"].get< int32_t >()
            );
        }
        if (json.contains("WordOpenXML") && !json["WordOpenXML"].is_null()) {
            this->m_WordOpenXML = std::make_shared< std::wstring >(
                convertUtf8( json["WordOpenXML"].get< std::string >() )
            );
        }
    }

    void StructuredDocumentTagBase::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StructuredDocumentTagBase::validate()
    {
        NodeLink::validate();

        if (this->m_ListItems != nullptr)
        {
            for (auto& elementListItems : *(this->m_ListItems))
            {
                if (elementListItems != nullptr)
                {
                    elementListItems->validate();
                }
            }
        }













        if (this->m_Color != nullptr)
        {
            this->m_Color->validate();
        }











    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::StructuredDocumentTagListItem>> > StructuredDocumentTagBase::getListItems() const
    {
        return this->m_ListItems;
    }

    void StructuredDocumentTagBase::setListItems(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::StructuredDocumentTagListItem>> > value)
    {
        this->m_ListItems = value;
    }


    std::shared_ptr< bool > StructuredDocumentTagBase::getChecked() const
    {
        return this->m_Checked;
    }

    void StructuredDocumentTagBase::setChecked(std::shared_ptr< bool > value)
    {
        this->m_Checked = value;
    }


    std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTagBase::Appearance > StructuredDocumentTagBase::getAppearance() const
    {
        return this->m_Appearance;
    }

    void StructuredDocumentTagBase::setAppearance(std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTagBase::Appearance > value)
    {
        this->m_Appearance = value;
    }


    std::shared_ptr< int32_t > StructuredDocumentTagBase::getDateDisplayLocale() const
    {
        return this->m_DateDisplayLocale;
    }

    void StructuredDocumentTagBase::setDateDisplayLocale(std::shared_ptr< int32_t > value)
    {
        this->m_DateDisplayLocale = value;
    }


    std::shared_ptr< std::wstring > StructuredDocumentTagBase::getDateDisplayFormat() const
    {
        return this->m_DateDisplayFormat;
    }

    void StructuredDocumentTagBase::setDateDisplayFormat(std::shared_ptr< std::wstring > value)
    {
        this->m_DateDisplayFormat = value;
    }


    std::shared_ptr< std::wstring > StructuredDocumentTagBase::getFullDate() const
    {
        return this->m_FullDate;
    }

    void StructuredDocumentTagBase::setFullDate(std::shared_ptr< std::wstring > value)
    {
        this->m_FullDate = value;
    }


    std::shared_ptr< std::wstring > StructuredDocumentTagBase::getTitle() const
    {
        return this->m_Title;
    }

    void StructuredDocumentTagBase::setTitle(std::shared_ptr< std::wstring > value)
    {
        this->m_Title = value;
    }


    std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTagBase::DateStorageFormat > StructuredDocumentTagBase::getDateStorageFormat() const
    {
        return this->m_DateStorageFormat;
    }

    void StructuredDocumentTagBase::setDateStorageFormat(std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTagBase::DateStorageFormat > value)
    {
        this->m_DateStorageFormat = value;
    }


    std::shared_ptr< std::wstring > StructuredDocumentTagBase::getBuildingBlockGallery() const
    {
        return this->m_BuildingBlockGallery;
    }

    void StructuredDocumentTagBase::setBuildingBlockGallery(std::shared_ptr< std::wstring > value)
    {
        this->m_BuildingBlockGallery = value;
    }


    std::shared_ptr< std::wstring > StructuredDocumentTagBase::getBuildingBlockCategory() const
    {
        return this->m_BuildingBlockCategory;
    }

    void StructuredDocumentTagBase::setBuildingBlockCategory(std::shared_ptr< std::wstring > value)
    {
        this->m_BuildingBlockCategory = value;
    }


    std::shared_ptr< bool > StructuredDocumentTagBase::getMultiline() const
    {
        return this->m_Multiline;
    }

    void StructuredDocumentTagBase::setMultiline(std::shared_ptr< bool > value)
    {
        this->m_Multiline = value;
    }


    std::shared_ptr< aspose::words::cloud::models::XmlColor > StructuredDocumentTagBase::getColor() const
    {
        return this->m_Color;
    }

    void StructuredDocumentTagBase::setColor(std::shared_ptr< aspose::words::cloud::models::XmlColor > value)
    {
        this->m_Color = value;
    }


    std::shared_ptr< std::wstring > StructuredDocumentTagBase::getStyleName() const
    {
        return this->m_StyleName;
    }

    void StructuredDocumentTagBase::setStyleName(std::shared_ptr< std::wstring > value)
    {
        this->m_StyleName = value;
    }


    std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType > StructuredDocumentTagBase::getCalendarType() const
    {
        return this->m_CalendarType;
    }

    void StructuredDocumentTagBase::setCalendarType(std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTagBase::CalendarType > value)
    {
        this->m_CalendarType = value;
    }


    std::shared_ptr< bool > StructuredDocumentTagBase::getIsTemporary() const
    {
        return this->m_IsTemporary;
    }

    void StructuredDocumentTagBase::setIsTemporary(std::shared_ptr< bool > value)
    {
        this->m_IsTemporary = value;
    }


    std::shared_ptr< std::wstring > StructuredDocumentTagBase::getPlaceholderName() const
    {
        return this->m_PlaceholderName;
    }

    void StructuredDocumentTagBase::setPlaceholderName(std::shared_ptr< std::wstring > value)
    {
        this->m_PlaceholderName = value;
    }


    std::shared_ptr< bool > StructuredDocumentTagBase::getLockContentControl() const
    {
        return this->m_LockContentControl;
    }

    void StructuredDocumentTagBase::setLockContentControl(std::shared_ptr< bool > value)
    {
        this->m_LockContentControl = value;
    }


    std::shared_ptr< bool > StructuredDocumentTagBase::getLockContents() const
    {
        return this->m_LockContents;
    }

    void StructuredDocumentTagBase::setLockContents(std::shared_ptr< bool > value)
    {
        this->m_LockContents = value;
    }


    std::shared_ptr< bool > StructuredDocumentTagBase::getIsShowingPlaceholderText() const
    {
        return this->m_IsShowingPlaceholderText;
    }

    void StructuredDocumentTagBase::setIsShowingPlaceholderText(std::shared_ptr< bool > value)
    {
        this->m_IsShowingPlaceholderText = value;
    }


    std::shared_ptr< std::wstring > StructuredDocumentTagBase::getTag() const
    {
        return this->m_Tag;
    }

    void StructuredDocumentTagBase::setTag(std::shared_ptr< std::wstring > value)
    {
        this->m_Tag = value;
    }


    std::shared_ptr< int32_t > StructuredDocumentTagBase::getId() const
    {
        return this->m_Id;
    }

    void StructuredDocumentTagBase::setId(std::shared_ptr< int32_t > value)
    {
        this->m_Id = value;
    }


    std::shared_ptr< std::wstring > StructuredDocumentTagBase::getWordOpenXML() const
    {
        return this->m_WordOpenXML;
    }




    /*
     * StructuredDocumentTagCollection implementation
     */
    void StructuredDocumentTagCollection::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_List) {
            json["List"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_List)) {
                element->toJson(&json["List"].emplace_back());
            }
        }
    }

    void StructuredDocumentTagCollection::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("List") && !json["List"].is_null()) {
            this->m_List = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::StructuredDocumentTag>> >();
            for (auto& element : json["List"]) {
                this->m_List->emplace_back(createModelInstance< aspose::words::cloud::models::StructuredDocumentTag >(L"StructuredDocumentTag, _", element));
            }
        }
    }

    void StructuredDocumentTagCollection::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StructuredDocumentTagCollection::validate()
    {
        LinkElement::validate();

        if (this->m_List != nullptr)
        {
            for (auto& elementList : *(this->m_List))
            {
                if (elementList != nullptr)
                {
                    elementList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::StructuredDocumentTag>> > StructuredDocumentTagCollection::getList() const
    {
        return this->m_List;
    }

    void StructuredDocumentTagCollection::setList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::StructuredDocumentTag>> > value)
    {
        this->m_List = value;
    }



    /*
     * StructuredDocumentTagInsert implementation
     */
    inline std::string structuredDocumentTagInsertLevelToString(aspose::words::cloud::models::StructuredDocumentTagInsert::Level value)
    {
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::Level::UNKNOWN) return "Unknown";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::Level::INLINE) return "Inline";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::Level::BLOCK) return "Block";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::Level::ROW) return "Row";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::Level::CELL) return "Cell";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::StructuredDocumentTagInsert::Level structuredDocumentTagInsertLevelFromString(const std::string& value)
    {
        if (value == "Unknown") return aspose::words::cloud::models::StructuredDocumentTagInsert::Level::UNKNOWN;
        if (value == "Inline") return aspose::words::cloud::models::StructuredDocumentTagInsert::Level::INLINE;
        if (value == "Block") return aspose::words::cloud::models::StructuredDocumentTagInsert::Level::BLOCK;
        if (value == "Row") return aspose::words::cloud::models::StructuredDocumentTagInsert::Level::ROW;
        if (value == "Cell") return aspose::words::cloud::models::StructuredDocumentTagInsert::Level::CELL;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string structuredDocumentTagInsertSdtTypeToString(aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType value)
    {
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::NONE) return "None";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::BIBLIOGRAPHY) return "Bibliography";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::CITATION) return "Citation";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::EQUATION) return "Equation";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::DROP_DOWN_LIST) return "DropDownList";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::COMBO_BOX) return "ComboBox";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::DATE) return "Date";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::BUILDING_BLOCK_GALLERY) return "BuildingBlockGallery";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::DOC_PART_OBJ) return "DocPartObj";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::GROUP) return "Group";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::PICTURE) return "Picture";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::RICH_TEXT) return "RichText";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::PLAIN_TEXT) return "PlainText";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::CHECKBOX) return "Checkbox";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::REPEATING_SECTION) return "RepeatingSection";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::REPEATING_SECTION_ITEM) return "RepeatingSectionItem";
        if (value == aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::ENTITY_PICKER) return "EntityPicker";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType structuredDocumentTagInsertSdtTypeFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::NONE;
        if (value == "Bibliography") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::BIBLIOGRAPHY;
        if (value == "Citation") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::CITATION;
        if (value == "Equation") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::EQUATION;
        if (value == "DropDownList") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::DROP_DOWN_LIST;
        if (value == "ComboBox") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::COMBO_BOX;
        if (value == "Date") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::DATE;
        if (value == "BuildingBlockGallery") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::BUILDING_BLOCK_GALLERY;
        if (value == "DocPartObj") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::DOC_PART_OBJ;
        if (value == "Group") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::GROUP;
        if (value == "Picture") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::PICTURE;
        if (value == "RichText") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::RICH_TEXT;
        if (value == "PlainText") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::PLAIN_TEXT;
        if (value == "Checkbox") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::CHECKBOX;
        if (value == "RepeatingSection") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::REPEATING_SECTION;
        if (value == "RepeatingSectionItem") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::REPEATING_SECTION_ITEM;
        if (value == "EntityPicker") return aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType::ENTITY_PICKER;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void StructuredDocumentTagInsert::toJson(void* jsonIfc) const
    {
        StructuredDocumentTagBase::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Level) {
            json["Level"] = structuredDocumentTagInsertLevelToString(*(this->m_Level));
        }
        if (this->m_SdtType) {
            json["SdtType"] = structuredDocumentTagInsertSdtTypeToString(*(this->m_SdtType));
        }
        if (this->m_Position) {
            this->m_Position->toJson(&json["Position"]);
        }
    }

    void StructuredDocumentTagInsert::fromJson(const void* jsonIfc)
    {
        StructuredDocumentTagBase::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Level") && !json["Level"].is_null()) {
            this->m_Level = std::make_shared< aspose::words::cloud::models::StructuredDocumentTagInsert::Level >(
                structuredDocumentTagInsertLevelFromString(json["Level"].get< std::string >())
            );
        }
        if (json.contains("SdtType") && !json["SdtType"].is_null()) {
            this->m_SdtType = std::make_shared< aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType >(
                structuredDocumentTagInsertSdtTypeFromString(json["SdtType"].get< std::string >())
            );
        }
        if (json.contains("Position") && !json["Position"].is_null()) {
            this->m_Position = createModelInstance< aspose::words::cloud::models::Position >(L"Position, _", json["Position"]);
        }
    }

    void StructuredDocumentTagInsert::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StructuredDocumentTagInsert::validate()
    {
        StructuredDocumentTagBase::validate();
        if (this->m_Level == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Level in StructuredDocumentTagInsert is required.");
        }

        if (this->m_SdtType == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property SdtType in StructuredDocumentTagInsert is required.");
        }


        if (this->m_Position != nullptr)
        {
            this->m_Position->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTagInsert::Level > StructuredDocumentTagInsert::getLevel() const
    {
        return this->m_Level;
    }

    void StructuredDocumentTagInsert::setLevel(std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTagInsert::Level > value)
    {
        this->m_Level = value;
    }


    std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType > StructuredDocumentTagInsert::getSdtType() const
    {
        return this->m_SdtType;
    }

    void StructuredDocumentTagInsert::setSdtType(std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTagInsert::SdtType > value)
    {
        this->m_SdtType = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Position > StructuredDocumentTagInsert::getPosition() const
    {
        return this->m_Position;
    }

    void StructuredDocumentTagInsert::setPosition(std::shared_ptr< aspose::words::cloud::models::Position > value)
    {
        this->m_Position = value;
    }



    /*
     * StructuredDocumentTagListItem implementation
     */
    void StructuredDocumentTagListItem::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_DisplayText) {
            json["DisplayText"] = convertUtf16(*(this->m_DisplayText));
        }
        if (this->m_Value) {
            json["Value"] = convertUtf16(*(this->m_Value));
        }
    }

    void StructuredDocumentTagListItem::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("DisplayText") && !json["DisplayText"].is_null()) {
            this->m_DisplayText = std::make_shared< std::wstring >(
                convertUtf8( json["DisplayText"].get< std::string >() )
            );
        }
        if (json.contains("Value") && !json["Value"].is_null()) {
            this->m_Value = std::make_shared< std::wstring >(
                convertUtf8( json["Value"].get< std::string >() )
            );
        }
    }

    void StructuredDocumentTagListItem::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StructuredDocumentTagListItem::validate()
    {
    }

    std::shared_ptr< std::wstring > StructuredDocumentTagListItem::getDisplayText() const
    {
        return this->m_DisplayText;
    }

    void StructuredDocumentTagListItem::setDisplayText(std::shared_ptr< std::wstring > value)
    {
        this->m_DisplayText = value;
    }


    std::shared_ptr< std::wstring > StructuredDocumentTagListItem::getValue() const
    {
        return this->m_Value;
    }

    void StructuredDocumentTagListItem::setValue(std::shared_ptr< std::wstring > value)
    {
        this->m_Value = value;
    }



    /*
     * StructuredDocumentTagResponse implementation
     */
    void StructuredDocumentTagResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_StructuredDocumentTag) {
            this->m_StructuredDocumentTag->toJson(&json["StructuredDocumentTag"]);
        }
    }

    void StructuredDocumentTagResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("StructuredDocumentTag") && !json["StructuredDocumentTag"].is_null()) {
            this->m_StructuredDocumentTag = createModelInstance< aspose::words::cloud::models::StructuredDocumentTag >(L"StructuredDocumentTag, _", json["StructuredDocumentTag"]);
        }
    }

    void StructuredDocumentTagResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StructuredDocumentTagResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_StructuredDocumentTag != nullptr)
        {
            this->m_StructuredDocumentTag->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTag > StructuredDocumentTagResponse::getStructuredDocumentTag() const
    {
        return this->m_StructuredDocumentTag;
    }

    void StructuredDocumentTagResponse::setStructuredDocumentTag(std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTag > value)
    {
        this->m_StructuredDocumentTag = value;
    }



    /*
     * StructuredDocumentTagsResponse implementation
     */
    void StructuredDocumentTagsResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_StructuredDocumentTags) {
            this->m_StructuredDocumentTags->toJson(&json["StructuredDocumentTags"]);
        }
    }

    void StructuredDocumentTagsResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("StructuredDocumentTags") && !json["StructuredDocumentTags"].is_null()) {
            this->m_StructuredDocumentTags = createModelInstance< aspose::words::cloud::models::StructuredDocumentTagCollection >(L"StructuredDocumentTagCollection, _", json["StructuredDocumentTags"]);
        }
    }

    void StructuredDocumentTagsResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StructuredDocumentTagsResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_StructuredDocumentTags != nullptr)
        {
            this->m_StructuredDocumentTags->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTagCollection > StructuredDocumentTagsResponse::getStructuredDocumentTags() const
    {
        return this->m_StructuredDocumentTags;
    }

    void StructuredDocumentTagsResponse::setStructuredDocumentTags(std::shared_ptr< aspose::words::cloud::models::StructuredDocumentTagCollection > value)
    {
        this->m_StructuredDocumentTags = value;
    }



    /*
     * StructuredDocumentTagUpdate implementation
     */
    void StructuredDocumentTagUpdate::toJson(void* jsonIfc) const
    {
        StructuredDocumentTag::toJson(jsonIfc);
    }

    void StructuredDocumentTagUpdate::fromJson(const void* jsonIfc)
    {
        StructuredDocumentTag::fromJson(jsonIfc);
    }

    void StructuredDocumentTagUpdate::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StructuredDocumentTagUpdate::validate()
    {
        StructuredDocumentTag::validate();
    }




    /*
     * Style implementation
     */
    inline std::string styleTypeToString(aspose::words::cloud::models::Style::Type value)
    {
        if (value == aspose::words::cloud::models::Style::Type::PARAGRAPH) return "Paragraph";
        if (value == aspose::words::cloud::models::Style::Type::CHARACTER) return "Character";
        if (value == aspose::words::cloud::models::Style::Type::TABLE) return "Table";
        if (value == aspose::words::cloud::models::Style::Type::LIST) return "List";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::Style::Type styleTypeFromString(const std::string& value)
    {
        if (value == "Paragraph") return aspose::words::cloud::models::Style::Type::PARAGRAPH;
        if (value == "Character") return aspose::words::cloud::models::Style::Type::CHARACTER;
        if (value == "Table") return aspose::words::cloud::models::Style::Type::TABLE;
        if (value == "List") return aspose::words::cloud::models::Style::Type::LIST;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string styleStyleIdentifierToString(aspose::words::cloud::models::Style::StyleIdentifier value)
    {
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::NORMAL) return "Normal";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HEADING1) return "Heading1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HEADING2) return "Heading2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HEADING3) return "Heading3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HEADING4) return "Heading4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HEADING5) return "Heading5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HEADING6) return "Heading6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HEADING7) return "Heading7";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HEADING8) return "Heading8";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HEADING9) return "Heading9";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::INDEX1) return "Index1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::INDEX2) return "Index2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::INDEX3) return "Index3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::INDEX4) return "Index4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::INDEX5) return "Index5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::INDEX6) return "Index6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::INDEX7) return "Index7";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::INDEX8) return "Index8";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::INDEX9) return "Index9";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TOC1) return "Toc1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TOC2) return "Toc2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TOC3) return "Toc3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TOC4) return "Toc4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TOC5) return "Toc5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TOC6) return "Toc6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TOC7) return "Toc7";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TOC8) return "Toc8";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TOC9) return "Toc9";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::NORMAL_INDENT) return "NormalIndent";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::FOOTNOTE_TEXT) return "FootnoteText";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COMMENT_TEXT) return "CommentText";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HEADER) return "Header";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::FOOTER) return "Footer";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::INDEX_HEADING) return "IndexHeading";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::CAPTION) return "Caption";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_OF_FIGURES) return "TableOfFigures";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::ENVELOPE_ADDRESS) return "EnvelopeAddress";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::ENVELOPE_RETURN) return "EnvelopeReturn";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::FOOTNOTE_REFERENCE) return "FootnoteReference";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COMMENT_REFERENCE) return "CommentReference";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LINE_NUMBER) return "LineNumber";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::PAGE_NUMBER) return "PageNumber";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::ENDNOTE_REFERENCE) return "EndnoteReference";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::ENDNOTE_TEXT) return "EndnoteText";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_OF_AUTHORITIES) return "TableOfAuthorities";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MACRO) return "Macro";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TOA_HEADING) return "ToaHeading";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST) return "List";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_BULLET) return "ListBullet";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_NUMBER) return "ListNumber";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST2) return "List2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST3) return "List3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST4) return "List4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST5) return "List5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_BULLET2) return "ListBullet2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_BULLET3) return "ListBullet3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_BULLET4) return "ListBullet4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_BULLET5) return "ListBullet5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_NUMBER2) return "ListNumber2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_NUMBER3) return "ListNumber3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_NUMBER4) return "ListNumber4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_NUMBER5) return "ListNumber5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TITLE) return "Title";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::CLOSING) return "Closing";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::SIGNATURE) return "Signature";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::DEFAULT_PARAGRAPH_FONT) return "DefaultParagraphFont";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::BODY_TEXT) return "BodyText";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::BODY_TEXT_IND) return "BodyTextInd";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_CONTINUE) return "ListContinue";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_CONTINUE2) return "ListContinue2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_CONTINUE3) return "ListContinue3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_CONTINUE4) return "ListContinue4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_CONTINUE5) return "ListContinue5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MESSAGE_HEADER) return "MessageHeader";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::SUBTITLE) return "Subtitle";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::SALUTATION) return "Salutation";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::DATE) return "Date";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::BODY_TEXT1_I) return "BodyText1I";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::BODY_TEXT1_I2) return "BodyText1I2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::NOTE_HEADING) return "NoteHeading";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::BODY_TEXT2) return "BodyText2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::BODY_TEXT3) return "BodyText3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::BODY_TEXT_IND2) return "BodyTextInd2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::BODY_TEXT_IND3) return "BodyTextInd3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::BLOCK_TEXT) return "BlockText";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HYPERLINK) return "Hyperlink";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::FOLLOWED_HYPERLINK) return "FollowedHyperlink";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::STRONG) return "Strong";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::EMPHASIS) return "Emphasis";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::DOCUMENT_MAP) return "DocumentMap";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::PLAIN_TEXT) return "PlainText";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::EMAIL_SIGNATURE) return "EmailSignature";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HTML_TOP_OF_FORM) return "HtmlTopOfForm";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HTML_BOTTOM_OF_FORM) return "HtmlBottomOfForm";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::NORMAL_WEB) return "NormalWeb";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HTML_ACRONYM) return "HtmlAcronym";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HTML_ADDRESS) return "HtmlAddress";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HTML_CITE) return "HtmlCite";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HTML_CODE) return "HtmlCode";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HTML_DEFINITION) return "HtmlDefinition";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HTML_KEYBOARD) return "HtmlKeyboard";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HTML_PREFORMATTED) return "HtmlPreformatted";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HTML_SAMPLE) return "HtmlSample";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HTML_TYPEWRITER) return "HtmlTypewriter";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HTML_VARIABLE) return "HtmlVariable";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_NORMAL) return "TableNormal";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COMMENT_SUBJECT) return "CommentSubject";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::NO_LIST) return "NoList";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::OUTLINE_LIST1) return "OutlineList1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::OUTLINE_LIST2) return "OutlineList2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::OUTLINE_LIST3) return "OutlineList3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_SIMPLE1) return "TableSimple1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_SIMPLE2) return "TableSimple2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_SIMPLE3) return "TableSimple3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_CLASSIC1) return "TableClassic1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_CLASSIC2) return "TableClassic2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_CLASSIC3) return "TableClassic3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_CLASSIC4) return "TableClassic4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_COLORFUL1) return "TableColorful1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_COLORFUL2) return "TableColorful2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_COLORFUL3) return "TableColorful3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_COLUMNS1) return "TableColumns1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_COLUMNS2) return "TableColumns2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_COLUMNS3) return "TableColumns3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_COLUMNS4) return "TableColumns4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_COLUMNS5) return "TableColumns5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID1) return "TableGrid1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID2) return "TableGrid2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID3) return "TableGrid3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID4) return "TableGrid4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID5) return "TableGrid5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID6) return "TableGrid6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID7) return "TableGrid7";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID8) return "TableGrid8";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_LIST1) return "TableList1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_LIST2) return "TableList2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_LIST3) return "TableList3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_LIST4) return "TableList4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_LIST5) return "TableList5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_LIST6) return "TableList6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_LIST7) return "TableList7";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_LIST8) return "TableList8";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE3_D_EFFECTS1) return "Table3DEffects1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE3_D_EFFECTS2) return "Table3DEffects2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE3_D_EFFECTS3) return "Table3DEffects3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_CONTEMPORARY) return "TableContemporary";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_ELEGANT) return "TableElegant";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_PROFESSIONAL) return "TableProfessional";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_SUBTLE1) return "TableSubtle1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_SUBTLE2) return "TableSubtle2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_WEB1) return "TableWeb1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_WEB2) return "TableWeb2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_WEB3) return "TableWeb3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::BALLOON_TEXT) return "BalloonText";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID) return "TableGrid";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_THEME) return "TableTheme";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::PLACEHOLDER_TEXT) return "PlaceholderText";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::NO_SPACING) return "NoSpacing";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_SHADING) return "LightShading";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_LIST) return "LightList";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_GRID) return "LightGrid";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING1) return "MediumShading1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING2) return "MediumShading2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST1) return "MediumList1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST2) return "MediumList2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID1) return "MediumGrid1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID2) return "MediumGrid2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID3) return "MediumGrid3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::DARK_LIST) return "DarkList";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_SHADING) return "ColorfulShading";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_LIST) return "ColorfulList";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_GRID) return "ColorfulGrid";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_SHADING_ACCENT1) return "LightShadingAccent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_LIST_ACCENT1) return "LightListAccent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_GRID_ACCENT1) return "LightGridAccent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING1_ACCENT1) return "MediumShading1Accent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING2_ACCENT1) return "MediumShading2Accent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST1_ACCENT1) return "MediumList1Accent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::REVISION) return "Revision";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_PARAGRAPH) return "ListParagraph";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::QUOTE) return "Quote";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::INTENSE_QUOTE) return "IntenseQuote";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST2_ACCENT1) return "MediumList2Accent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID1_ACCENT1) return "MediumGrid1Accent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID2_ACCENT1) return "MediumGrid2Accent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID3_ACCENT1) return "MediumGrid3Accent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::DARK_LIST_ACCENT1) return "DarkListAccent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_SHADING_ACCENT1) return "ColorfulShadingAccent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_LIST_ACCENT1) return "ColorfulListAccent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_GRID_ACCENT1) return "ColorfulGridAccent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_SHADING_ACCENT2) return "LightShadingAccent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_LIST_ACCENT2) return "LightListAccent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_GRID_ACCENT2) return "LightGridAccent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING1_ACCENT2) return "MediumShading1Accent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING2_ACCENT2) return "MediumShading2Accent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST1_ACCENT2) return "MediumList1Accent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST2_ACCENT2) return "MediumList2Accent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID1_ACCENT2) return "MediumGrid1Accent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID2_ACCENT2) return "MediumGrid2Accent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID3_ACCENT2) return "MediumGrid3Accent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::DARK_LIST_ACCENT2) return "DarkListAccent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_SHADING_ACCENT2) return "ColorfulShadingAccent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_LIST_ACCENT2) return "ColorfulListAccent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_GRID_ACCENT2) return "ColorfulGridAccent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_SHADING_ACCENT3) return "LightShadingAccent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_LIST_ACCENT3) return "LightListAccent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_GRID_ACCENT3) return "LightGridAccent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING1_ACCENT3) return "MediumShading1Accent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING2_ACCENT3) return "MediumShading2Accent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST1_ACCENT3) return "MediumList1Accent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST2_ACCENT3) return "MediumList2Accent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID1_ACCENT3) return "MediumGrid1Accent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID2_ACCENT3) return "MediumGrid2Accent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID3_ACCENT3) return "MediumGrid3Accent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::DARK_LIST_ACCENT3) return "DarkListAccent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_SHADING_ACCENT3) return "ColorfulShadingAccent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_LIST_ACCENT3) return "ColorfulListAccent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_GRID_ACCENT3) return "ColorfulGridAccent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_SHADING_ACCENT4) return "LightShadingAccent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_LIST_ACCENT4) return "LightListAccent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_GRID_ACCENT4) return "LightGridAccent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING1_ACCENT4) return "MediumShading1Accent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING2_ACCENT4) return "MediumShading2Accent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST1_ACCENT4) return "MediumList1Accent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST2_ACCENT4) return "MediumList2Accent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID1_ACCENT4) return "MediumGrid1Accent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID2_ACCENT4) return "MediumGrid2Accent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID3_ACCENT4) return "MediumGrid3Accent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::DARK_LIST_ACCENT4) return "DarkListAccent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_SHADING_ACCENT4) return "ColorfulShadingAccent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_LIST_ACCENT4) return "ColorfulListAccent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_GRID_ACCENT4) return "ColorfulGridAccent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_SHADING_ACCENT5) return "LightShadingAccent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_LIST_ACCENT5) return "LightListAccent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_GRID_ACCENT5) return "LightGridAccent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING1_ACCENT5) return "MediumShading1Accent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING2_ACCENT5) return "MediumShading2Accent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST1_ACCENT5) return "MediumList1Accent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST2_ACCENT5) return "MediumList2Accent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID1_ACCENT5) return "MediumGrid1Accent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID2_ACCENT5) return "MediumGrid2Accent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID3_ACCENT5) return "MediumGrid3Accent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::DARK_LIST_ACCENT5) return "DarkListAccent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_SHADING_ACCENT5) return "ColorfulShadingAccent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_LIST_ACCENT5) return "ColorfulListAccent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_GRID_ACCENT5) return "ColorfulGridAccent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_SHADING_ACCENT6) return "LightShadingAccent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_LIST_ACCENT6) return "LightListAccent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_GRID_ACCENT6) return "LightGridAccent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING1_ACCENT6) return "MediumShading1Accent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING2_ACCENT6) return "MediumShading2Accent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST1_ACCENT6) return "MediumList1Accent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST2_ACCENT6) return "MediumList2Accent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID1_ACCENT6) return "MediumGrid1Accent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID2_ACCENT6) return "MediumGrid2Accent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID3_ACCENT6) return "MediumGrid3Accent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::DARK_LIST_ACCENT6) return "DarkListAccent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_SHADING_ACCENT6) return "ColorfulShadingAccent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_LIST_ACCENT6) return "ColorfulListAccent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_GRID_ACCENT6) return "ColorfulGridAccent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::SUBTLE_EMPHASIS) return "SubtleEmphasis";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::INTENSE_EMPHASIS) return "IntenseEmphasis";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::SUBTLE_REFERENCE) return "SubtleReference";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::INTENSE_REFERENCE) return "IntenseReference";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::BOOK_TITLE) return "BookTitle";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::BIBLIOGRAPHY) return "Bibliography";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TOC_HEADING) return "TocHeading";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::PLAIN_TABLE1) return "PlainTable1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::PLAIN_TABLE2) return "PlainTable2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::PLAIN_TABLE3) return "PlainTable3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::PLAIN_TABLE4) return "PlainTable4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::PLAIN_TABLE5) return "PlainTable5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID_LIGHT) return "TableGridLight";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE1_LIGHT) return "GridTable1Light";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE2) return "GridTable2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE3) return "GridTable3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE4) return "GridTable4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE5_DARK) return "GridTable5Dark";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE6_COLORFUL) return "GridTable6Colorful";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE7_COLORFUL) return "GridTable7Colorful";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT1) return "GridTable1LightAccent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE2_ACCENT1) return "GridTable2Accent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE3_ACCENT1) return "GridTable3Accent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE4_ACCENT1) return "GridTable4Accent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE5_DARK_ACCENT1) return "GridTable5DarkAccent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT1) return "GridTable6ColorfulAccent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT1) return "GridTable7ColorfulAccent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT2) return "GridTable1LightAccent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE2_ACCENT2) return "GridTable2Accent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE3_ACCENT2) return "GridTable3Accent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE4_ACCENT2) return "GridTable4Accent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE5_DARK_ACCENT2) return "GridTable5DarkAccent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT2) return "GridTable6ColorfulAccent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT2) return "GridTable7ColorfulAccent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT3) return "GridTable1LightAccent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE2_ACCENT3) return "GridTable2Accent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE3_ACCENT3) return "GridTable3Accent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE4_ACCENT3) return "GridTable4Accent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE5_DARK_ACCENT3) return "GridTable5DarkAccent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT3) return "GridTable6ColorfulAccent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT3) return "GridTable7ColorfulAccent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT4) return "GridTable1LightAccent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE2_ACCENT4) return "GridTable2Accent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE3_ACCENT4) return "GridTable3Accent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE4_ACCENT4) return "GridTable4Accent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE5_DARK_ACCENT4) return "GridTable5DarkAccent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT4) return "GridTable6ColorfulAccent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT4) return "GridTable7ColorfulAccent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT5) return "GridTable1LightAccent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE2_ACCENT5) return "GridTable2Accent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE3_ACCENT5) return "GridTable3Accent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE4_ACCENT5) return "GridTable4Accent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE5_DARK_ACCENT5) return "GridTable5DarkAccent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT5) return "GridTable6ColorfulAccent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT5) return "GridTable7ColorfulAccent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT6) return "GridTable1LightAccent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE2_ACCENT6) return "GridTable2Accent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE3_ACCENT6) return "GridTable3Accent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE4_ACCENT6) return "GridTable4Accent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE5_DARK_ACCENT6) return "GridTable5DarkAccent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT6) return "GridTable6ColorfulAccent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT6) return "GridTable7ColorfulAccent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE1_LIGHT) return "ListTable1Light";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE2) return "ListTable2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE3) return "ListTable3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE4) return "ListTable4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE5_DARK) return "ListTable5Dark";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE6_COLORFUL) return "ListTable6Colorful";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE7_COLORFUL) return "ListTable7Colorful";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT1) return "ListTable1LightAccent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE2_ACCENT1) return "ListTable2Accent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE3_ACCENT1) return "ListTable3Accent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE4_ACCENT1) return "ListTable4Accent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE5_DARK_ACCENT1) return "ListTable5DarkAccent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT1) return "ListTable6ColorfulAccent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT1) return "ListTable7ColorfulAccent1";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT2) return "ListTable1LightAccent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE2_ACCENT2) return "ListTable2Accent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE3_ACCENT2) return "ListTable3Accent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE4_ACCENT2) return "ListTable4Accent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE5_DARK_ACCENT2) return "ListTable5DarkAccent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT2) return "ListTable6ColorfulAccent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT2) return "ListTable7ColorfulAccent2";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT3) return "ListTable1LightAccent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE2_ACCENT3) return "ListTable2Accent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE3_ACCENT3) return "ListTable3Accent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE4_ACCENT3) return "ListTable4Accent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE5_DARK_ACCENT3) return "ListTable5DarkAccent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT3) return "ListTable6ColorfulAccent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT3) return "ListTable7ColorfulAccent3";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT4) return "ListTable1LightAccent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE2_ACCENT4) return "ListTable2Accent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE3_ACCENT4) return "ListTable3Accent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE4_ACCENT4) return "ListTable4Accent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE5_DARK_ACCENT4) return "ListTable5DarkAccent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT4) return "ListTable6ColorfulAccent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT4) return "ListTable7ColorfulAccent4";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT5) return "ListTable1LightAccent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE2_ACCENT5) return "ListTable2Accent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE3_ACCENT5) return "ListTable3Accent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE4_ACCENT5) return "ListTable4Accent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE5_DARK_ACCENT5) return "ListTable5DarkAccent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT5) return "ListTable6ColorfulAccent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT5) return "ListTable7ColorfulAccent5";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT6) return "ListTable1LightAccent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE2_ACCENT6) return "ListTable2Accent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE3_ACCENT6) return "ListTable3Accent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE4_ACCENT6) return "ListTable4Accent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE5_DARK_ACCENT6) return "ListTable5DarkAccent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT6) return "ListTable6ColorfulAccent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT6) return "ListTable7ColorfulAccent6";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::SMART_LINK) return "SmartLink";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::MENTION) return "Mention";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::SMART_HYPERLINK) return "SmartHyperlink";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::HASHTAG) return "Hashtag";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::UNRESOLVED_MENTION) return "UnresolvedMention";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::USER) return "User";
        if (value == aspose::words::cloud::models::Style::StyleIdentifier::NIL) return "Nil";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::Style::StyleIdentifier styleStyleIdentifierFromString(const std::string& value)
    {
        if (value == "Normal") return aspose::words::cloud::models::Style::StyleIdentifier::NORMAL;
        if (value == "Heading1") return aspose::words::cloud::models::Style::StyleIdentifier::HEADING1;
        if (value == "Heading2") return aspose::words::cloud::models::Style::StyleIdentifier::HEADING2;
        if (value == "Heading3") return aspose::words::cloud::models::Style::StyleIdentifier::HEADING3;
        if (value == "Heading4") return aspose::words::cloud::models::Style::StyleIdentifier::HEADING4;
        if (value == "Heading5") return aspose::words::cloud::models::Style::StyleIdentifier::HEADING5;
        if (value == "Heading6") return aspose::words::cloud::models::Style::StyleIdentifier::HEADING6;
        if (value == "Heading7") return aspose::words::cloud::models::Style::StyleIdentifier::HEADING7;
        if (value == "Heading8") return aspose::words::cloud::models::Style::StyleIdentifier::HEADING8;
        if (value == "Heading9") return aspose::words::cloud::models::Style::StyleIdentifier::HEADING9;
        if (value == "Index1") return aspose::words::cloud::models::Style::StyleIdentifier::INDEX1;
        if (value == "Index2") return aspose::words::cloud::models::Style::StyleIdentifier::INDEX2;
        if (value == "Index3") return aspose::words::cloud::models::Style::StyleIdentifier::INDEX3;
        if (value == "Index4") return aspose::words::cloud::models::Style::StyleIdentifier::INDEX4;
        if (value == "Index5") return aspose::words::cloud::models::Style::StyleIdentifier::INDEX5;
        if (value == "Index6") return aspose::words::cloud::models::Style::StyleIdentifier::INDEX6;
        if (value == "Index7") return aspose::words::cloud::models::Style::StyleIdentifier::INDEX7;
        if (value == "Index8") return aspose::words::cloud::models::Style::StyleIdentifier::INDEX8;
        if (value == "Index9") return aspose::words::cloud::models::Style::StyleIdentifier::INDEX9;
        if (value == "Toc1") return aspose::words::cloud::models::Style::StyleIdentifier::TOC1;
        if (value == "Toc2") return aspose::words::cloud::models::Style::StyleIdentifier::TOC2;
        if (value == "Toc3") return aspose::words::cloud::models::Style::StyleIdentifier::TOC3;
        if (value == "Toc4") return aspose::words::cloud::models::Style::StyleIdentifier::TOC4;
        if (value == "Toc5") return aspose::words::cloud::models::Style::StyleIdentifier::TOC5;
        if (value == "Toc6") return aspose::words::cloud::models::Style::StyleIdentifier::TOC6;
        if (value == "Toc7") return aspose::words::cloud::models::Style::StyleIdentifier::TOC7;
        if (value == "Toc8") return aspose::words::cloud::models::Style::StyleIdentifier::TOC8;
        if (value == "Toc9") return aspose::words::cloud::models::Style::StyleIdentifier::TOC9;
        if (value == "NormalIndent") return aspose::words::cloud::models::Style::StyleIdentifier::NORMAL_INDENT;
        if (value == "FootnoteText") return aspose::words::cloud::models::Style::StyleIdentifier::FOOTNOTE_TEXT;
        if (value == "CommentText") return aspose::words::cloud::models::Style::StyleIdentifier::COMMENT_TEXT;
        if (value == "Header") return aspose::words::cloud::models::Style::StyleIdentifier::HEADER;
        if (value == "Footer") return aspose::words::cloud::models::Style::StyleIdentifier::FOOTER;
        if (value == "IndexHeading") return aspose::words::cloud::models::Style::StyleIdentifier::INDEX_HEADING;
        if (value == "Caption") return aspose::words::cloud::models::Style::StyleIdentifier::CAPTION;
        if (value == "TableOfFigures") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_OF_FIGURES;
        if (value == "EnvelopeAddress") return aspose::words::cloud::models::Style::StyleIdentifier::ENVELOPE_ADDRESS;
        if (value == "EnvelopeReturn") return aspose::words::cloud::models::Style::StyleIdentifier::ENVELOPE_RETURN;
        if (value == "FootnoteReference") return aspose::words::cloud::models::Style::StyleIdentifier::FOOTNOTE_REFERENCE;
        if (value == "CommentReference") return aspose::words::cloud::models::Style::StyleIdentifier::COMMENT_REFERENCE;
        if (value == "LineNumber") return aspose::words::cloud::models::Style::StyleIdentifier::LINE_NUMBER;
        if (value == "PageNumber") return aspose::words::cloud::models::Style::StyleIdentifier::PAGE_NUMBER;
        if (value == "EndnoteReference") return aspose::words::cloud::models::Style::StyleIdentifier::ENDNOTE_REFERENCE;
        if (value == "EndnoteText") return aspose::words::cloud::models::Style::StyleIdentifier::ENDNOTE_TEXT;
        if (value == "TableOfAuthorities") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_OF_AUTHORITIES;
        if (value == "Macro") return aspose::words::cloud::models::Style::StyleIdentifier::MACRO;
        if (value == "ToaHeading") return aspose::words::cloud::models::Style::StyleIdentifier::TOA_HEADING;
        if (value == "List") return aspose::words::cloud::models::Style::StyleIdentifier::LIST;
        if (value == "ListBullet") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_BULLET;
        if (value == "ListNumber") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_NUMBER;
        if (value == "List2") return aspose::words::cloud::models::Style::StyleIdentifier::LIST2;
        if (value == "List3") return aspose::words::cloud::models::Style::StyleIdentifier::LIST3;
        if (value == "List4") return aspose::words::cloud::models::Style::StyleIdentifier::LIST4;
        if (value == "List5") return aspose::words::cloud::models::Style::StyleIdentifier::LIST5;
        if (value == "ListBullet2") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_BULLET2;
        if (value == "ListBullet3") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_BULLET3;
        if (value == "ListBullet4") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_BULLET4;
        if (value == "ListBullet5") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_BULLET5;
        if (value == "ListNumber2") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_NUMBER2;
        if (value == "ListNumber3") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_NUMBER3;
        if (value == "ListNumber4") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_NUMBER4;
        if (value == "ListNumber5") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_NUMBER5;
        if (value == "Title") return aspose::words::cloud::models::Style::StyleIdentifier::TITLE;
        if (value == "Closing") return aspose::words::cloud::models::Style::StyleIdentifier::CLOSING;
        if (value == "Signature") return aspose::words::cloud::models::Style::StyleIdentifier::SIGNATURE;
        if (value == "DefaultParagraphFont") return aspose::words::cloud::models::Style::StyleIdentifier::DEFAULT_PARAGRAPH_FONT;
        if (value == "BodyText") return aspose::words::cloud::models::Style::StyleIdentifier::BODY_TEXT;
        if (value == "BodyTextInd") return aspose::words::cloud::models::Style::StyleIdentifier::BODY_TEXT_IND;
        if (value == "ListContinue") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_CONTINUE;
        if (value == "ListContinue2") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_CONTINUE2;
        if (value == "ListContinue3") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_CONTINUE3;
        if (value == "ListContinue4") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_CONTINUE4;
        if (value == "ListContinue5") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_CONTINUE5;
        if (value == "MessageHeader") return aspose::words::cloud::models::Style::StyleIdentifier::MESSAGE_HEADER;
        if (value == "Subtitle") return aspose::words::cloud::models::Style::StyleIdentifier::SUBTITLE;
        if (value == "Salutation") return aspose::words::cloud::models::Style::StyleIdentifier::SALUTATION;
        if (value == "Date") return aspose::words::cloud::models::Style::StyleIdentifier::DATE;
        if (value == "BodyText1I") return aspose::words::cloud::models::Style::StyleIdentifier::BODY_TEXT1_I;
        if (value == "BodyText1I2") return aspose::words::cloud::models::Style::StyleIdentifier::BODY_TEXT1_I2;
        if (value == "NoteHeading") return aspose::words::cloud::models::Style::StyleIdentifier::NOTE_HEADING;
        if (value == "BodyText2") return aspose::words::cloud::models::Style::StyleIdentifier::BODY_TEXT2;
        if (value == "BodyText3") return aspose::words::cloud::models::Style::StyleIdentifier::BODY_TEXT3;
        if (value == "BodyTextInd2") return aspose::words::cloud::models::Style::StyleIdentifier::BODY_TEXT_IND2;
        if (value == "BodyTextInd3") return aspose::words::cloud::models::Style::StyleIdentifier::BODY_TEXT_IND3;
        if (value == "BlockText") return aspose::words::cloud::models::Style::StyleIdentifier::BLOCK_TEXT;
        if (value == "Hyperlink") return aspose::words::cloud::models::Style::StyleIdentifier::HYPERLINK;
        if (value == "FollowedHyperlink") return aspose::words::cloud::models::Style::StyleIdentifier::FOLLOWED_HYPERLINK;
        if (value == "Strong") return aspose::words::cloud::models::Style::StyleIdentifier::STRONG;
        if (value == "Emphasis") return aspose::words::cloud::models::Style::StyleIdentifier::EMPHASIS;
        if (value == "DocumentMap") return aspose::words::cloud::models::Style::StyleIdentifier::DOCUMENT_MAP;
        if (value == "PlainText") return aspose::words::cloud::models::Style::StyleIdentifier::PLAIN_TEXT;
        if (value == "EmailSignature") return aspose::words::cloud::models::Style::StyleIdentifier::EMAIL_SIGNATURE;
        if (value == "HtmlTopOfForm") return aspose::words::cloud::models::Style::StyleIdentifier::HTML_TOP_OF_FORM;
        if (value == "HtmlBottomOfForm") return aspose::words::cloud::models::Style::StyleIdentifier::HTML_BOTTOM_OF_FORM;
        if (value == "NormalWeb") return aspose::words::cloud::models::Style::StyleIdentifier::NORMAL_WEB;
        if (value == "HtmlAcronym") return aspose::words::cloud::models::Style::StyleIdentifier::HTML_ACRONYM;
        if (value == "HtmlAddress") return aspose::words::cloud::models::Style::StyleIdentifier::HTML_ADDRESS;
        if (value == "HtmlCite") return aspose::words::cloud::models::Style::StyleIdentifier::HTML_CITE;
        if (value == "HtmlCode") return aspose::words::cloud::models::Style::StyleIdentifier::HTML_CODE;
        if (value == "HtmlDefinition") return aspose::words::cloud::models::Style::StyleIdentifier::HTML_DEFINITION;
        if (value == "HtmlKeyboard") return aspose::words::cloud::models::Style::StyleIdentifier::HTML_KEYBOARD;
        if (value == "HtmlPreformatted") return aspose::words::cloud::models::Style::StyleIdentifier::HTML_PREFORMATTED;
        if (value == "HtmlSample") return aspose::words::cloud::models::Style::StyleIdentifier::HTML_SAMPLE;
        if (value == "HtmlTypewriter") return aspose::words::cloud::models::Style::StyleIdentifier::HTML_TYPEWRITER;
        if (value == "HtmlVariable") return aspose::words::cloud::models::Style::StyleIdentifier::HTML_VARIABLE;
        if (value == "TableNormal") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_NORMAL;
        if (value == "CommentSubject") return aspose::words::cloud::models::Style::StyleIdentifier::COMMENT_SUBJECT;
        if (value == "NoList") return aspose::words::cloud::models::Style::StyleIdentifier::NO_LIST;
        if (value == "OutlineList1") return aspose::words::cloud::models::Style::StyleIdentifier::OUTLINE_LIST1;
        if (value == "OutlineList2") return aspose::words::cloud::models::Style::StyleIdentifier::OUTLINE_LIST2;
        if (value == "OutlineList3") return aspose::words::cloud::models::Style::StyleIdentifier::OUTLINE_LIST3;
        if (value == "TableSimple1") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_SIMPLE1;
        if (value == "TableSimple2") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_SIMPLE2;
        if (value == "TableSimple3") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_SIMPLE3;
        if (value == "TableClassic1") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_CLASSIC1;
        if (value == "TableClassic2") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_CLASSIC2;
        if (value == "TableClassic3") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_CLASSIC3;
        if (value == "TableClassic4") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_CLASSIC4;
        if (value == "TableColorful1") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_COLORFUL1;
        if (value == "TableColorful2") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_COLORFUL2;
        if (value == "TableColorful3") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_COLORFUL3;
        if (value == "TableColumns1") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_COLUMNS1;
        if (value == "TableColumns2") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_COLUMNS2;
        if (value == "TableColumns3") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_COLUMNS3;
        if (value == "TableColumns4") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_COLUMNS4;
        if (value == "TableColumns5") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_COLUMNS5;
        if (value == "TableGrid1") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID1;
        if (value == "TableGrid2") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID2;
        if (value == "TableGrid3") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID3;
        if (value == "TableGrid4") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID4;
        if (value == "TableGrid5") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID5;
        if (value == "TableGrid6") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID6;
        if (value == "TableGrid7") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID7;
        if (value == "TableGrid8") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID8;
        if (value == "TableList1") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_LIST1;
        if (value == "TableList2") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_LIST2;
        if (value == "TableList3") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_LIST3;
        if (value == "TableList4") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_LIST4;
        if (value == "TableList5") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_LIST5;
        if (value == "TableList6") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_LIST6;
        if (value == "TableList7") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_LIST7;
        if (value == "TableList8") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_LIST8;
        if (value == "Table3DEffects1") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE3_D_EFFECTS1;
        if (value == "Table3DEffects2") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE3_D_EFFECTS2;
        if (value == "Table3DEffects3") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE3_D_EFFECTS3;
        if (value == "TableContemporary") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_CONTEMPORARY;
        if (value == "TableElegant") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_ELEGANT;
        if (value == "TableProfessional") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_PROFESSIONAL;
        if (value == "TableSubtle1") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_SUBTLE1;
        if (value == "TableSubtle2") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_SUBTLE2;
        if (value == "TableWeb1") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_WEB1;
        if (value == "TableWeb2") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_WEB2;
        if (value == "TableWeb3") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_WEB3;
        if (value == "BalloonText") return aspose::words::cloud::models::Style::StyleIdentifier::BALLOON_TEXT;
        if (value == "TableGrid") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID;
        if (value == "TableTheme") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_THEME;
        if (value == "PlaceholderText") return aspose::words::cloud::models::Style::StyleIdentifier::PLACEHOLDER_TEXT;
        if (value == "NoSpacing") return aspose::words::cloud::models::Style::StyleIdentifier::NO_SPACING;
        if (value == "LightShading") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_SHADING;
        if (value == "LightList") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_LIST;
        if (value == "LightGrid") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_GRID;
        if (value == "MediumShading1") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING1;
        if (value == "MediumShading2") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING2;
        if (value == "MediumList1") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST1;
        if (value == "MediumList2") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST2;
        if (value == "MediumGrid1") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID1;
        if (value == "MediumGrid2") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID2;
        if (value == "MediumGrid3") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID3;
        if (value == "DarkList") return aspose::words::cloud::models::Style::StyleIdentifier::DARK_LIST;
        if (value == "ColorfulShading") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_SHADING;
        if (value == "ColorfulList") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_LIST;
        if (value == "ColorfulGrid") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_GRID;
        if (value == "LightShadingAccent1") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_SHADING_ACCENT1;
        if (value == "LightListAccent1") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_LIST_ACCENT1;
        if (value == "LightGridAccent1") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_GRID_ACCENT1;
        if (value == "MediumShading1Accent1") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING1_ACCENT1;
        if (value == "MediumShading2Accent1") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING2_ACCENT1;
        if (value == "MediumList1Accent1") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST1_ACCENT1;
        if (value == "Revision") return aspose::words::cloud::models::Style::StyleIdentifier::REVISION;
        if (value == "ListParagraph") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_PARAGRAPH;
        if (value == "Quote") return aspose::words::cloud::models::Style::StyleIdentifier::QUOTE;
        if (value == "IntenseQuote") return aspose::words::cloud::models::Style::StyleIdentifier::INTENSE_QUOTE;
        if (value == "MediumList2Accent1") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST2_ACCENT1;
        if (value == "MediumGrid1Accent1") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID1_ACCENT1;
        if (value == "MediumGrid2Accent1") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID2_ACCENT1;
        if (value == "MediumGrid3Accent1") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID3_ACCENT1;
        if (value == "DarkListAccent1") return aspose::words::cloud::models::Style::StyleIdentifier::DARK_LIST_ACCENT1;
        if (value == "ColorfulShadingAccent1") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_SHADING_ACCENT1;
        if (value == "ColorfulListAccent1") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_LIST_ACCENT1;
        if (value == "ColorfulGridAccent1") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_GRID_ACCENT1;
        if (value == "LightShadingAccent2") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_SHADING_ACCENT2;
        if (value == "LightListAccent2") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_LIST_ACCENT2;
        if (value == "LightGridAccent2") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_GRID_ACCENT2;
        if (value == "MediumShading1Accent2") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING1_ACCENT2;
        if (value == "MediumShading2Accent2") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING2_ACCENT2;
        if (value == "MediumList1Accent2") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST1_ACCENT2;
        if (value == "MediumList2Accent2") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST2_ACCENT2;
        if (value == "MediumGrid1Accent2") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID1_ACCENT2;
        if (value == "MediumGrid2Accent2") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID2_ACCENT2;
        if (value == "MediumGrid3Accent2") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID3_ACCENT2;
        if (value == "DarkListAccent2") return aspose::words::cloud::models::Style::StyleIdentifier::DARK_LIST_ACCENT2;
        if (value == "ColorfulShadingAccent2") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_SHADING_ACCENT2;
        if (value == "ColorfulListAccent2") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_LIST_ACCENT2;
        if (value == "ColorfulGridAccent2") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_GRID_ACCENT2;
        if (value == "LightShadingAccent3") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_SHADING_ACCENT3;
        if (value == "LightListAccent3") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_LIST_ACCENT3;
        if (value == "LightGridAccent3") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_GRID_ACCENT3;
        if (value == "MediumShading1Accent3") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING1_ACCENT3;
        if (value == "MediumShading2Accent3") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING2_ACCENT3;
        if (value == "MediumList1Accent3") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST1_ACCENT3;
        if (value == "MediumList2Accent3") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST2_ACCENT3;
        if (value == "MediumGrid1Accent3") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID1_ACCENT3;
        if (value == "MediumGrid2Accent3") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID2_ACCENT3;
        if (value == "MediumGrid3Accent3") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID3_ACCENT3;
        if (value == "DarkListAccent3") return aspose::words::cloud::models::Style::StyleIdentifier::DARK_LIST_ACCENT3;
        if (value == "ColorfulShadingAccent3") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_SHADING_ACCENT3;
        if (value == "ColorfulListAccent3") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_LIST_ACCENT3;
        if (value == "ColorfulGridAccent3") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_GRID_ACCENT3;
        if (value == "LightShadingAccent4") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_SHADING_ACCENT4;
        if (value == "LightListAccent4") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_LIST_ACCENT4;
        if (value == "LightGridAccent4") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_GRID_ACCENT4;
        if (value == "MediumShading1Accent4") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING1_ACCENT4;
        if (value == "MediumShading2Accent4") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING2_ACCENT4;
        if (value == "MediumList1Accent4") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST1_ACCENT4;
        if (value == "MediumList2Accent4") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST2_ACCENT4;
        if (value == "MediumGrid1Accent4") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID1_ACCENT4;
        if (value == "MediumGrid2Accent4") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID2_ACCENT4;
        if (value == "MediumGrid3Accent4") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID3_ACCENT4;
        if (value == "DarkListAccent4") return aspose::words::cloud::models::Style::StyleIdentifier::DARK_LIST_ACCENT4;
        if (value == "ColorfulShadingAccent4") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_SHADING_ACCENT4;
        if (value == "ColorfulListAccent4") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_LIST_ACCENT4;
        if (value == "ColorfulGridAccent4") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_GRID_ACCENT4;
        if (value == "LightShadingAccent5") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_SHADING_ACCENT5;
        if (value == "LightListAccent5") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_LIST_ACCENT5;
        if (value == "LightGridAccent5") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_GRID_ACCENT5;
        if (value == "MediumShading1Accent5") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING1_ACCENT5;
        if (value == "MediumShading2Accent5") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING2_ACCENT5;
        if (value == "MediumList1Accent5") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST1_ACCENT5;
        if (value == "MediumList2Accent5") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST2_ACCENT5;
        if (value == "MediumGrid1Accent5") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID1_ACCENT5;
        if (value == "MediumGrid2Accent5") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID2_ACCENT5;
        if (value == "MediumGrid3Accent5") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID3_ACCENT5;
        if (value == "DarkListAccent5") return aspose::words::cloud::models::Style::StyleIdentifier::DARK_LIST_ACCENT5;
        if (value == "ColorfulShadingAccent5") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_SHADING_ACCENT5;
        if (value == "ColorfulListAccent5") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_LIST_ACCENT5;
        if (value == "ColorfulGridAccent5") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_GRID_ACCENT5;
        if (value == "LightShadingAccent6") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_SHADING_ACCENT6;
        if (value == "LightListAccent6") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_LIST_ACCENT6;
        if (value == "LightGridAccent6") return aspose::words::cloud::models::Style::StyleIdentifier::LIGHT_GRID_ACCENT6;
        if (value == "MediumShading1Accent6") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING1_ACCENT6;
        if (value == "MediumShading2Accent6") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_SHADING2_ACCENT6;
        if (value == "MediumList1Accent6") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST1_ACCENT6;
        if (value == "MediumList2Accent6") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_LIST2_ACCENT6;
        if (value == "MediumGrid1Accent6") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID1_ACCENT6;
        if (value == "MediumGrid2Accent6") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID2_ACCENT6;
        if (value == "MediumGrid3Accent6") return aspose::words::cloud::models::Style::StyleIdentifier::MEDIUM_GRID3_ACCENT6;
        if (value == "DarkListAccent6") return aspose::words::cloud::models::Style::StyleIdentifier::DARK_LIST_ACCENT6;
        if (value == "ColorfulShadingAccent6") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_SHADING_ACCENT6;
        if (value == "ColorfulListAccent6") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_LIST_ACCENT6;
        if (value == "ColorfulGridAccent6") return aspose::words::cloud::models::Style::StyleIdentifier::COLORFUL_GRID_ACCENT6;
        if (value == "SubtleEmphasis") return aspose::words::cloud::models::Style::StyleIdentifier::SUBTLE_EMPHASIS;
        if (value == "IntenseEmphasis") return aspose::words::cloud::models::Style::StyleIdentifier::INTENSE_EMPHASIS;
        if (value == "SubtleReference") return aspose::words::cloud::models::Style::StyleIdentifier::SUBTLE_REFERENCE;
        if (value == "IntenseReference") return aspose::words::cloud::models::Style::StyleIdentifier::INTENSE_REFERENCE;
        if (value == "BookTitle") return aspose::words::cloud::models::Style::StyleIdentifier::BOOK_TITLE;
        if (value == "Bibliography") return aspose::words::cloud::models::Style::StyleIdentifier::BIBLIOGRAPHY;
        if (value == "TocHeading") return aspose::words::cloud::models::Style::StyleIdentifier::TOC_HEADING;
        if (value == "PlainTable1") return aspose::words::cloud::models::Style::StyleIdentifier::PLAIN_TABLE1;
        if (value == "PlainTable2") return aspose::words::cloud::models::Style::StyleIdentifier::PLAIN_TABLE2;
        if (value == "PlainTable3") return aspose::words::cloud::models::Style::StyleIdentifier::PLAIN_TABLE3;
        if (value == "PlainTable4") return aspose::words::cloud::models::Style::StyleIdentifier::PLAIN_TABLE4;
        if (value == "PlainTable5") return aspose::words::cloud::models::Style::StyleIdentifier::PLAIN_TABLE5;
        if (value == "TableGridLight") return aspose::words::cloud::models::Style::StyleIdentifier::TABLE_GRID_LIGHT;
        if (value == "GridTable1Light") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE1_LIGHT;
        if (value == "GridTable2") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE2;
        if (value == "GridTable3") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE3;
        if (value == "GridTable4") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE4;
        if (value == "GridTable5Dark") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE5_DARK;
        if (value == "GridTable6Colorful") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE6_COLORFUL;
        if (value == "GridTable7Colorful") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE7_COLORFUL;
        if (value == "GridTable1LightAccent1") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT1;
        if (value == "GridTable2Accent1") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE2_ACCENT1;
        if (value == "GridTable3Accent1") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE3_ACCENT1;
        if (value == "GridTable4Accent1") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE4_ACCENT1;
        if (value == "GridTable5DarkAccent1") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE5_DARK_ACCENT1;
        if (value == "GridTable6ColorfulAccent1") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT1;
        if (value == "GridTable7ColorfulAccent1") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT1;
        if (value == "GridTable1LightAccent2") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT2;
        if (value == "GridTable2Accent2") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE2_ACCENT2;
        if (value == "GridTable3Accent2") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE3_ACCENT2;
        if (value == "GridTable4Accent2") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE4_ACCENT2;
        if (value == "GridTable5DarkAccent2") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE5_DARK_ACCENT2;
        if (value == "GridTable6ColorfulAccent2") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT2;
        if (value == "GridTable7ColorfulAccent2") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT2;
        if (value == "GridTable1LightAccent3") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT3;
        if (value == "GridTable2Accent3") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE2_ACCENT3;
        if (value == "GridTable3Accent3") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE3_ACCENT3;
        if (value == "GridTable4Accent3") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE4_ACCENT3;
        if (value == "GridTable5DarkAccent3") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE5_DARK_ACCENT3;
        if (value == "GridTable6ColorfulAccent3") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT3;
        if (value == "GridTable7ColorfulAccent3") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT3;
        if (value == "GridTable1LightAccent4") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT4;
        if (value == "GridTable2Accent4") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE2_ACCENT4;
        if (value == "GridTable3Accent4") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE3_ACCENT4;
        if (value == "GridTable4Accent4") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE4_ACCENT4;
        if (value == "GridTable5DarkAccent4") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE5_DARK_ACCENT4;
        if (value == "GridTable6ColorfulAccent4") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT4;
        if (value == "GridTable7ColorfulAccent4") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT4;
        if (value == "GridTable1LightAccent5") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT5;
        if (value == "GridTable2Accent5") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE2_ACCENT5;
        if (value == "GridTable3Accent5") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE3_ACCENT5;
        if (value == "GridTable4Accent5") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE4_ACCENT5;
        if (value == "GridTable5DarkAccent5") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE5_DARK_ACCENT5;
        if (value == "GridTable6ColorfulAccent5") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT5;
        if (value == "GridTable7ColorfulAccent5") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT5;
        if (value == "GridTable1LightAccent6") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT6;
        if (value == "GridTable2Accent6") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE2_ACCENT6;
        if (value == "GridTable3Accent6") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE3_ACCENT6;
        if (value == "GridTable4Accent6") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE4_ACCENT6;
        if (value == "GridTable5DarkAccent6") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE5_DARK_ACCENT6;
        if (value == "GridTable6ColorfulAccent6") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT6;
        if (value == "GridTable7ColorfulAccent6") return aspose::words::cloud::models::Style::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT6;
        if (value == "ListTable1Light") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE1_LIGHT;
        if (value == "ListTable2") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE2;
        if (value == "ListTable3") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE3;
        if (value == "ListTable4") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE4;
        if (value == "ListTable5Dark") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE5_DARK;
        if (value == "ListTable6Colorful") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE6_COLORFUL;
        if (value == "ListTable7Colorful") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE7_COLORFUL;
        if (value == "ListTable1LightAccent1") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT1;
        if (value == "ListTable2Accent1") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE2_ACCENT1;
        if (value == "ListTable3Accent1") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE3_ACCENT1;
        if (value == "ListTable4Accent1") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE4_ACCENT1;
        if (value == "ListTable5DarkAccent1") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE5_DARK_ACCENT1;
        if (value == "ListTable6ColorfulAccent1") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT1;
        if (value == "ListTable7ColorfulAccent1") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT1;
        if (value == "ListTable1LightAccent2") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT2;
        if (value == "ListTable2Accent2") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE2_ACCENT2;
        if (value == "ListTable3Accent2") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE3_ACCENT2;
        if (value == "ListTable4Accent2") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE4_ACCENT2;
        if (value == "ListTable5DarkAccent2") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE5_DARK_ACCENT2;
        if (value == "ListTable6ColorfulAccent2") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT2;
        if (value == "ListTable7ColorfulAccent2") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT2;
        if (value == "ListTable1LightAccent3") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT3;
        if (value == "ListTable2Accent3") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE2_ACCENT3;
        if (value == "ListTable3Accent3") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE3_ACCENT3;
        if (value == "ListTable4Accent3") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE4_ACCENT3;
        if (value == "ListTable5DarkAccent3") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE5_DARK_ACCENT3;
        if (value == "ListTable6ColorfulAccent3") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT3;
        if (value == "ListTable7ColorfulAccent3") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT3;
        if (value == "ListTable1LightAccent4") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT4;
        if (value == "ListTable2Accent4") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE2_ACCENT4;
        if (value == "ListTable3Accent4") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE3_ACCENT4;
        if (value == "ListTable4Accent4") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE4_ACCENT4;
        if (value == "ListTable5DarkAccent4") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE5_DARK_ACCENT4;
        if (value == "ListTable6ColorfulAccent4") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT4;
        if (value == "ListTable7ColorfulAccent4") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT4;
        if (value == "ListTable1LightAccent5") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT5;
        if (value == "ListTable2Accent5") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE2_ACCENT5;
        if (value == "ListTable3Accent5") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE3_ACCENT5;
        if (value == "ListTable4Accent5") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE4_ACCENT5;
        if (value == "ListTable5DarkAccent5") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE5_DARK_ACCENT5;
        if (value == "ListTable6ColorfulAccent5") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT5;
        if (value == "ListTable7ColorfulAccent5") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT5;
        if (value == "ListTable1LightAccent6") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT6;
        if (value == "ListTable2Accent6") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE2_ACCENT6;
        if (value == "ListTable3Accent6") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE3_ACCENT6;
        if (value == "ListTable4Accent6") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE4_ACCENT6;
        if (value == "ListTable5DarkAccent6") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE5_DARK_ACCENT6;
        if (value == "ListTable6ColorfulAccent6") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT6;
        if (value == "ListTable7ColorfulAccent6") return aspose::words::cloud::models::Style::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT6;
        if (value == "SmartLink") return aspose::words::cloud::models::Style::StyleIdentifier::SMART_LINK;
        if (value == "Mention") return aspose::words::cloud::models::Style::StyleIdentifier::MENTION;
        if (value == "SmartHyperlink") return aspose::words::cloud::models::Style::StyleIdentifier::SMART_HYPERLINK;
        if (value == "Hashtag") return aspose::words::cloud::models::Style::StyleIdentifier::HASHTAG;
        if (value == "UnresolvedMention") return aspose::words::cloud::models::Style::StyleIdentifier::UNRESOLVED_MENTION;
        if (value == "User") return aspose::words::cloud::models::Style::StyleIdentifier::USER;
        if (value == "Nil") return aspose::words::cloud::models::Style::StyleIdentifier::NIL;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void Style::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Font) {
            this->m_Font->toJson(&json["Font"]);
        }
        if (this->m_BuiltIn) {
            json["BuiltIn"] = *(this->m_BuiltIn);
        }
        if (this->m_NextParagraphStyleName) {
            json["NextParagraphStyleName"] = convertUtf16(*(this->m_NextParagraphStyleName));
        }
        if (this->m_BaseStyleName) {
            json["BaseStyleName"] = convertUtf16(*(this->m_BaseStyleName));
        }
        if (this->m_IsQuickStyle) {
            json["IsQuickStyle"] = *(this->m_IsQuickStyle);
        }
        if (this->m_LinkedStyleName) {
            json["LinkedStyleName"] = convertUtf16(*(this->m_LinkedStyleName));
        }
        if (this->m_Type) {
            json["Type"] = styleTypeToString(*(this->m_Type));
        }
        if (this->m_IsHeading) {
            json["IsHeading"] = *(this->m_IsHeading);
        }
        if (this->m_Aliases) {
            json["Aliases"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_Aliases)) {
                json["Aliases"].push_back(convertUtf16(*element));
            }
        }
        if (this->m_StyleIdentifier) {
            json["StyleIdentifier"] = styleStyleIdentifierToString(*(this->m_StyleIdentifier));
        }
        if (this->m_Name) {
            json["Name"] = convertUtf16(*(this->m_Name));
        }
    }

    void Style::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Font") && !json["Font"].is_null()) {
            this->m_Font = createModelInstance< aspose::words::cloud::models::Font >(L"Font, _", json["Font"]);
        }
        if (json.contains("BuiltIn") && !json["BuiltIn"].is_null()) {
            this->m_BuiltIn = std::make_shared< bool >(
                json["BuiltIn"].get< bool >()
            );
        }
        if (json.contains("NextParagraphStyleName") && !json["NextParagraphStyleName"].is_null()) {
            this->m_NextParagraphStyleName = std::make_shared< std::wstring >(
                convertUtf8( json["NextParagraphStyleName"].get< std::string >() )
            );
        }
        if (json.contains("BaseStyleName") && !json["BaseStyleName"].is_null()) {
            this->m_BaseStyleName = std::make_shared< std::wstring >(
                convertUtf8( json["BaseStyleName"].get< std::string >() )
            );
        }
        if (json.contains("IsQuickStyle") && !json["IsQuickStyle"].is_null()) {
            this->m_IsQuickStyle = std::make_shared< bool >(
                json["IsQuickStyle"].get< bool >()
            );
        }
        if (json.contains("LinkedStyleName") && !json["LinkedStyleName"].is_null()) {
            this->m_LinkedStyleName = std::make_shared< std::wstring >(
                convertUtf8( json["LinkedStyleName"].get< std::string >() )
            );
        }
        if (json.contains("Type") && !json["Type"].is_null()) {
            this->m_Type = std::make_shared< aspose::words::cloud::models::Style::Type >(
                styleTypeFromString(json["Type"].get< std::string >())
            );
        }
        if (json.contains("IsHeading") && !json["IsHeading"].is_null()) {
            this->m_IsHeading = std::make_shared< bool >(
                json["IsHeading"].get< bool >()
            );
        }
        if (json.contains("Aliases") && !json["Aliases"].is_null()) {
            this->m_Aliases = std::make_shared< std::vector<std::shared_ptr<std::wstring>> >();
            for (auto& element : json["Aliases"]) {
                this->m_Aliases->push_back(std::make_shared< std::wstring >(convertUtf8( element.get< std::string >() )));
            }
        }
        if (json.contains("StyleIdentifier") && !json["StyleIdentifier"].is_null()) {
            this->m_StyleIdentifier = std::make_shared< aspose::words::cloud::models::Style::StyleIdentifier >(
                styleStyleIdentifierFromString(json["StyleIdentifier"].get< std::string >())
            );
        }
        if (json.contains("Name") && !json["Name"].is_null()) {
            this->m_Name = std::make_shared< std::wstring >(
                convertUtf8( json["Name"].get< std::string >() )
            );
        }
    }

    void Style::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Style::validate()
    {
        LinkElement::validate();
        if (this->m_BuiltIn == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property BuiltIn in Style is required.");
        }

        if (this->m_IsQuickStyle == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property IsQuickStyle in Style is required.");
        }

        if (this->m_Type == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Type in Style is required.");
        }

        if (this->m_IsHeading == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property IsHeading in Style is required.");
        }

        if (this->m_StyleIdentifier == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property StyleIdentifier in Style is required.");
        }


        if (this->m_Font != nullptr)
        {
            this->m_Font->validate();
        }











    }

    std::shared_ptr< aspose::words::cloud::models::Font > Style::getFont() const
    {
        return this->m_Font;
    }

    void Style::setFont(std::shared_ptr< aspose::words::cloud::models::Font > value)
    {
        this->m_Font = value;
    }


    std::shared_ptr< bool > Style::getBuiltIn() const
    {
        return this->m_BuiltIn;
    }

    void Style::setBuiltIn(std::shared_ptr< bool > value)
    {
        this->m_BuiltIn = value;
    }


    std::shared_ptr< std::wstring > Style::getNextParagraphStyleName() const
    {
        return this->m_NextParagraphStyleName;
    }

    void Style::setNextParagraphStyleName(std::shared_ptr< std::wstring > value)
    {
        this->m_NextParagraphStyleName = value;
    }


    std::shared_ptr< std::wstring > Style::getBaseStyleName() const
    {
        return this->m_BaseStyleName;
    }

    void Style::setBaseStyleName(std::shared_ptr< std::wstring > value)
    {
        this->m_BaseStyleName = value;
    }


    std::shared_ptr< bool > Style::getIsQuickStyle() const
    {
        return this->m_IsQuickStyle;
    }

    void Style::setIsQuickStyle(std::shared_ptr< bool > value)
    {
        this->m_IsQuickStyle = value;
    }


    std::shared_ptr< std::wstring > Style::getLinkedStyleName() const
    {
        return this->m_LinkedStyleName;
    }

    void Style::setLinkedStyleName(std::shared_ptr< std::wstring > value)
    {
        this->m_LinkedStyleName = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Style::Type > Style::getType() const
    {
        return this->m_Type;
    }

    void Style::setType(std::shared_ptr< aspose::words::cloud::models::Style::Type > value)
    {
        this->m_Type = value;
    }


    std::shared_ptr< bool > Style::getIsHeading() const
    {
        return this->m_IsHeading;
    }

    void Style::setIsHeading(std::shared_ptr< bool > value)
    {
        this->m_IsHeading = value;
    }


    std::shared_ptr< std::vector<std::shared_ptr<std::wstring>> > Style::getAliases() const
    {
        return this->m_Aliases;
    }

    void Style::setAliases(std::shared_ptr< std::vector<std::shared_ptr<std::wstring>> > value)
    {
        this->m_Aliases = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Style::StyleIdentifier > Style::getStyleIdentifier() const
    {
        return this->m_StyleIdentifier;
    }

    void Style::setStyleIdentifier(std::shared_ptr< aspose::words::cloud::models::Style::StyleIdentifier > value)
    {
        this->m_StyleIdentifier = value;
    }


    std::shared_ptr< std::wstring > Style::getName() const
    {
        return this->m_Name;
    }

    void Style::setName(std::shared_ptr< std::wstring > value)
    {
        this->m_Name = value;
    }



    /*
     * StyleApply implementation
     */
    void StyleApply::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_StyleName) {
            json["StyleName"] = convertUtf16(*(this->m_StyleName));
        }
    }

    void StyleApply::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("StyleName") && !json["StyleName"].is_null()) {
            this->m_StyleName = std::make_shared< std::wstring >(
                convertUtf8( json["StyleName"].get< std::string >() )
            );
        }
    }

    void StyleApply::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StyleApply::validate()
    {
        if (this->m_StyleName == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property StyleName in StyleApply is required.");
        }

    }

    std::shared_ptr< std::wstring > StyleApply::getStyleName() const
    {
        return this->m_StyleName;
    }

    void StyleApply::setStyleName(std::shared_ptr< std::wstring > value)
    {
        this->m_StyleName = value;
    }



    /*
     * StyleCopy implementation
     */
    void StyleCopy::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_StyleName) {
            json["StyleName"] = convertUtf16(*(this->m_StyleName));
        }
    }

    void StyleCopy::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("StyleName") && !json["StyleName"].is_null()) {
            this->m_StyleName = std::make_shared< std::wstring >(
                convertUtf8( json["StyleName"].get< std::string >() )
            );
        }
    }

    void StyleCopy::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StyleCopy::validate()
    {
        if (this->m_StyleName == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property StyleName in StyleCopy is required.");
        }

    }

    std::shared_ptr< std::wstring > StyleCopy::getStyleName() const
    {
        return this->m_StyleName;
    }

    void StyleCopy::setStyleName(std::shared_ptr< std::wstring > value)
    {
        this->m_StyleName = value;
    }



    /*
     * StyleInsert implementation
     */
    inline std::string styleInsertStyleTypeToString(aspose::words::cloud::models::StyleInsert::StyleType value)
    {
        if (value == aspose::words::cloud::models::StyleInsert::StyleType::PARAGRAPH) return "Paragraph";
        if (value == aspose::words::cloud::models::StyleInsert::StyleType::CHARACTER) return "Character";
        if (value == aspose::words::cloud::models::StyleInsert::StyleType::TABLE) return "Table";
        if (value == aspose::words::cloud::models::StyleInsert::StyleType::LIST) return "List";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::StyleInsert::StyleType styleInsertStyleTypeFromString(const std::string& value)
    {
        if (value == "Paragraph") return aspose::words::cloud::models::StyleInsert::StyleType::PARAGRAPH;
        if (value == "Character") return aspose::words::cloud::models::StyleInsert::StyleType::CHARACTER;
        if (value == "Table") return aspose::words::cloud::models::StyleInsert::StyleType::TABLE;
        if (value == "List") return aspose::words::cloud::models::StyleInsert::StyleType::LIST;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void StyleInsert::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_StyleName) {
            json["StyleName"] = convertUtf16(*(this->m_StyleName));
        }
        if (this->m_StyleType) {
            json["StyleType"] = styleInsertStyleTypeToString(*(this->m_StyleType));
        }
    }

    void StyleInsert::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("StyleName") && !json["StyleName"].is_null()) {
            this->m_StyleName = std::make_shared< std::wstring >(
                convertUtf8( json["StyleName"].get< std::string >() )
            );
        }
        if (json.contains("StyleType") && !json["StyleType"].is_null()) {
            this->m_StyleType = std::make_shared< aspose::words::cloud::models::StyleInsert::StyleType >(
                styleInsertStyleTypeFromString(json["StyleType"].get< std::string >())
            );
        }
    }

    void StyleInsert::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StyleInsert::validate()
    {
        if (this->m_StyleName == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property StyleName in StyleInsert is required.");
        }

        if (this->m_StyleType == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property StyleType in StyleInsert is required.");
        }

    }

    std::shared_ptr< std::wstring > StyleInsert::getStyleName() const
    {
        return this->m_StyleName;
    }

    void StyleInsert::setStyleName(std::shared_ptr< std::wstring > value)
    {
        this->m_StyleName = value;
    }


    std::shared_ptr< aspose::words::cloud::models::StyleInsert::StyleType > StyleInsert::getStyleType() const
    {
        return this->m_StyleType;
    }

    void StyleInsert::setStyleType(std::shared_ptr< aspose::words::cloud::models::StyleInsert::StyleType > value)
    {
        this->m_StyleType = value;
    }



    /*
     * StyleResponse implementation
     */
    void StyleResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Style) {
            this->m_Style->toJson(&json["Style"]);
        }
    }

    void StyleResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Style") && !json["Style"].is_null()) {
            this->m_Style = createModelInstance< aspose::words::cloud::models::Style >(L"Style, _", json["Style"]);
        }
    }

    void StyleResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StyleResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Style != nullptr)
        {
            this->m_Style->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Style > StyleResponse::getStyle() const
    {
        return this->m_Style;
    }

    void StyleResponse::setStyle(std::shared_ptr< aspose::words::cloud::models::Style > value)
    {
        this->m_Style = value;
    }



    /*
     * StylesResponse implementation
     */
    void StylesResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Styles) {
            json["Styles"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_Styles)) {
                element->toJson(&json["Styles"].emplace_back());
            }
        }
    }

    void StylesResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Styles") && !json["Styles"].is_null()) {
            this->m_Styles = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::Style>> >();
            for (auto& element : json["Styles"]) {
                this->m_Styles->emplace_back(createModelInstance< aspose::words::cloud::models::Style >(L"Style, _", element));
            }
        }
    }

    void StylesResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StylesResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Styles != nullptr)
        {
            for (auto& elementStyles : *(this->m_Styles))
            {
                if (elementStyles != nullptr)
                {
                    elementStyles->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Style>> > StylesResponse::getStyles() const
    {
        return this->m_Styles;
    }

    void StylesResponse::setStyles(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::Style>> > value)
    {
        this->m_Styles = value;
    }



    /*
     * StyleUpdate implementation
     */
    void StyleUpdate::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_NextParagraphStyleName) {
            json["NextParagraphStyleName"] = convertUtf16(*(this->m_NextParagraphStyleName));
        }
        if (this->m_BaseStyleName) {
            json["BaseStyleName"] = convertUtf16(*(this->m_BaseStyleName));
        }
        if (this->m_IsQuickStyle) {
            json["IsQuickStyle"] = *(this->m_IsQuickStyle);
        }
        if (this->m_Name) {
            json["Name"] = convertUtf16(*(this->m_Name));
        }
    }

    void StyleUpdate::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("NextParagraphStyleName") && !json["NextParagraphStyleName"].is_null()) {
            this->m_NextParagraphStyleName = std::make_shared< std::wstring >(
                convertUtf8( json["NextParagraphStyleName"].get< std::string >() )
            );
        }
        if (json.contains("BaseStyleName") && !json["BaseStyleName"].is_null()) {
            this->m_BaseStyleName = std::make_shared< std::wstring >(
                convertUtf8( json["BaseStyleName"].get< std::string >() )
            );
        }
        if (json.contains("IsQuickStyle") && !json["IsQuickStyle"].is_null()) {
            this->m_IsQuickStyle = std::make_shared< bool >(
                json["IsQuickStyle"].get< bool >()
            );
        }
        if (json.contains("Name") && !json["Name"].is_null()) {
            this->m_Name = std::make_shared< std::wstring >(
                convertUtf8( json["Name"].get< std::string >() )
            );
        }
    }

    void StyleUpdate::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void StyleUpdate::validate()
    {
    }

    std::shared_ptr< std::wstring > StyleUpdate::getNextParagraphStyleName() const
    {
        return this->m_NextParagraphStyleName;
    }

    void StyleUpdate::setNextParagraphStyleName(std::shared_ptr< std::wstring > value)
    {
        this->m_NextParagraphStyleName = value;
    }


    std::shared_ptr< std::wstring > StyleUpdate::getBaseStyleName() const
    {
        return this->m_BaseStyleName;
    }

    void StyleUpdate::setBaseStyleName(std::shared_ptr< std::wstring > value)
    {
        this->m_BaseStyleName = value;
    }


    std::shared_ptr< bool > StyleUpdate::getIsQuickStyle() const
    {
        return this->m_IsQuickStyle;
    }

    void StyleUpdate::setIsQuickStyle(std::shared_ptr< bool > value)
    {
        this->m_IsQuickStyle = value;
    }


    std::shared_ptr< std::wstring > StyleUpdate::getName() const
    {
        return this->m_Name;
    }

    void StyleUpdate::setName(std::shared_ptr< std::wstring > value)
    {
        this->m_Name = value;
    }



    /*
     * SvgSaveOptionsData implementation
     */
    inline std::string svgSaveOptionsDataTextOutputModeToString(aspose::words::cloud::models::SvgSaveOptionsData::TextOutputMode value)
    {
        if (value == aspose::words::cloud::models::SvgSaveOptionsData::TextOutputMode::USE_SVG_FONTS) return "UseSvgFonts";
        if (value == aspose::words::cloud::models::SvgSaveOptionsData::TextOutputMode::USE_TARGET_MACHINE_FONTS) return "UseTargetMachineFonts";
        if (value == aspose::words::cloud::models::SvgSaveOptionsData::TextOutputMode::USE_PLACED_GLYPHS) return "UsePlacedGlyphs";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::SvgSaveOptionsData::TextOutputMode svgSaveOptionsDataTextOutputModeFromString(const std::string& value)
    {
        if (value == "UseSvgFonts") return aspose::words::cloud::models::SvgSaveOptionsData::TextOutputMode::USE_SVG_FONTS;
        if (value == "UseTargetMachineFonts") return aspose::words::cloud::models::SvgSaveOptionsData::TextOutputMode::USE_TARGET_MACHINE_FONTS;
        if (value == "UsePlacedGlyphs") return aspose::words::cloud::models::SvgSaveOptionsData::TextOutputMode::USE_PLACED_GLYPHS;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void SvgSaveOptionsData::toJson(void* jsonIfc) const
    {
        FixedPageSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ExportEmbeddedImages) {
            json["ExportEmbeddedImages"] = *(this->m_ExportEmbeddedImages);
        }
        if (this->m_FitToViewPort) {
            json["FitToViewPort"] = *(this->m_FitToViewPort);
        }
        if (this->m_ResourcesFolder) {
            json["ResourcesFolder"] = convertUtf16(*(this->m_ResourcesFolder));
        }
        if (this->m_ResourcesFolderAlias) {
            json["ResourcesFolderAlias"] = convertUtf16(*(this->m_ResourcesFolderAlias));
        }
        if (this->m_ShowPageBorder) {
            json["ShowPageBorder"] = *(this->m_ShowPageBorder);
        }
        if (this->m_TextOutputMode) {
            json["TextOutputMode"] = svgSaveOptionsDataTextOutputModeToString(*(this->m_TextOutputMode));
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void SvgSaveOptionsData::fromJson(const void* jsonIfc)
    {
        FixedPageSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ExportEmbeddedImages") && !json["ExportEmbeddedImages"].is_null()) {
            this->m_ExportEmbeddedImages = std::make_shared< bool >(
                json["ExportEmbeddedImages"].get< bool >()
            );
        }
        if (json.contains("FitToViewPort") && !json["FitToViewPort"].is_null()) {
            this->m_FitToViewPort = std::make_shared< bool >(
                json["FitToViewPort"].get< bool >()
            );
        }
        if (json.contains("ResourcesFolder") && !json["ResourcesFolder"].is_null()) {
            this->m_ResourcesFolder = std::make_shared< std::wstring >(
                convertUtf8( json["ResourcesFolder"].get< std::string >() )
            );
        }
        if (json.contains("ResourcesFolderAlias") && !json["ResourcesFolderAlias"].is_null()) {
            this->m_ResourcesFolderAlias = std::make_shared< std::wstring >(
                convertUtf8( json["ResourcesFolderAlias"].get< std::string >() )
            );
        }
        if (json.contains("ShowPageBorder") && !json["ShowPageBorder"].is_null()) {
            this->m_ShowPageBorder = std::make_shared< bool >(
                json["ShowPageBorder"].get< bool >()
            );
        }
        if (json.contains("TextOutputMode") && !json["TextOutputMode"].is_null()) {
            this->m_TextOutputMode = std::make_shared< aspose::words::cloud::models::SvgSaveOptionsData::TextOutputMode >(
                svgSaveOptionsDataTextOutputModeFromString(json["TextOutputMode"].get< std::string >())
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void SvgSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void SvgSaveOptionsData::validate()
    {
        FixedPageSaveOptionsData::validate();
    }

    std::shared_ptr< bool > SvgSaveOptionsData::getExportEmbeddedImages() const
    {
        return this->m_ExportEmbeddedImages;
    }

    void SvgSaveOptionsData::setExportEmbeddedImages(std::shared_ptr< bool > value)
    {
        this->m_ExportEmbeddedImages = value;
    }


    std::shared_ptr< bool > SvgSaveOptionsData::getFitToViewPort() const
    {
        return this->m_FitToViewPort;
    }

    void SvgSaveOptionsData::setFitToViewPort(std::shared_ptr< bool > value)
    {
        this->m_FitToViewPort = value;
    }


    std::shared_ptr< std::wstring > SvgSaveOptionsData::getResourcesFolder() const
    {
        return this->m_ResourcesFolder;
    }

    void SvgSaveOptionsData::setResourcesFolder(std::shared_ptr< std::wstring > value)
    {
        this->m_ResourcesFolder = value;
    }


    std::shared_ptr< std::wstring > SvgSaveOptionsData::getResourcesFolderAlias() const
    {
        return this->m_ResourcesFolderAlias;
    }

    void SvgSaveOptionsData::setResourcesFolderAlias(std::shared_ptr< std::wstring > value)
    {
        this->m_ResourcesFolderAlias = value;
    }


    std::shared_ptr< bool > SvgSaveOptionsData::getShowPageBorder() const
    {
        return this->m_ShowPageBorder;
    }

    void SvgSaveOptionsData::setShowPageBorder(std::shared_ptr< bool > value)
    {
        this->m_ShowPageBorder = value;
    }


    std::shared_ptr< aspose::words::cloud::models::SvgSaveOptionsData::TextOutputMode > SvgSaveOptionsData::getTextOutputMode() const
    {
        return this->m_TextOutputMode;
    }

    void SvgSaveOptionsData::setTextOutputMode(std::shared_ptr< aspose::words::cloud::models::SvgSaveOptionsData::TextOutputMode > value)
    {
        this->m_TextOutputMode = value;
    }


    std::shared_ptr< std::wstring > SvgSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * Table implementation
     */
    void Table::toJson(void* jsonIfc) const
    {
        NodeLink::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_TableRowList) {
            json["TableRowList"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_TableRowList)) {
                element->toJson(&json["TableRowList"].emplace_back());
            }
        }
        if (this->m_TableProperties) {
            this->m_TableProperties->toJson(&json["TableProperties"]);
        }
    }

    void Table::fromJson(const void* jsonIfc)
    {
        NodeLink::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("TableRowList") && !json["TableRowList"].is_null()) {
            this->m_TableRowList = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::TableRow>> >();
            for (auto& element : json["TableRowList"]) {
                this->m_TableRowList->emplace_back(createModelInstance< aspose::words::cloud::models::TableRow >(L"TableRow, _", element));
            }
        }
        if (json.contains("TableProperties") && !json["TableProperties"].is_null()) {
            this->m_TableProperties = createModelInstance< aspose::words::cloud::models::TableProperties >(L"TableProperties, _", json["TableProperties"]);
        }
    }

    void Table::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void Table::validate()
    {
        NodeLink::validate();

        if (this->m_TableRowList != nullptr)
        {
            for (auto& elementTableRowList : *(this->m_TableRowList))
            {
                if (elementTableRowList != nullptr)
                {
                    elementTableRowList->validate();
                }
            }
        }



        if (this->m_TableProperties != nullptr)
        {
            this->m_TableProperties->validate();
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::TableRow>> > Table::getTableRowList() const
    {
        return this->m_TableRowList;
    }

    void Table::setTableRowList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::TableRow>> > value)
    {
        this->m_TableRowList = value;
    }


    std::shared_ptr< aspose::words::cloud::models::TableProperties > Table::getTableProperties() const
    {
        return this->m_TableProperties;
    }

    void Table::setTableProperties(std::shared_ptr< aspose::words::cloud::models::TableProperties > value)
    {
        this->m_TableProperties = value;
    }



    /*
     * TableCell implementation
     */
    void TableCell::toJson(void* jsonIfc) const
    {
        NodeLink::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ChildNodes) {
            json["ChildNodes"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_ChildNodes)) {
                element->toJson(&json["ChildNodes"].emplace_back());
            }
        }
    }

    void TableCell::fromJson(const void* jsonIfc)
    {
        NodeLink::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ChildNodes") && !json["ChildNodes"].is_null()) {
            this->m_ChildNodes = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::NodeLink>> >();
            for (auto& element : json["ChildNodes"]) {
                this->m_ChildNodes->emplace_back(createModelInstance< aspose::words::cloud::models::NodeLink >(L"NodeLink, _", element));
            }
        }
    }

    void TableCell::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TableCell::validate()
    {
        NodeLink::validate();

        if (this->m_ChildNodes != nullptr)
        {
            for (auto& elementChildNodes : *(this->m_ChildNodes))
            {
                if (elementChildNodes != nullptr)
                {
                    elementChildNodes->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::NodeLink>> > TableCell::getChildNodes() const
    {
        return this->m_ChildNodes;
    }

    void TableCell::setChildNodes(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::NodeLink>> > value)
    {
        this->m_ChildNodes = value;
    }



    /*
     * TableCellFormat implementation
     */
    inline std::string tableCellFormatHorizontalMergeToString(aspose::words::cloud::models::TableCellFormat::HorizontalMerge value)
    {
        if (value == aspose::words::cloud::models::TableCellFormat::HorizontalMerge::NONE) return "None";
        if (value == aspose::words::cloud::models::TableCellFormat::HorizontalMerge::FIRST) return "First";
        if (value == aspose::words::cloud::models::TableCellFormat::HorizontalMerge::PREVIOUS) return "Previous";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::TableCellFormat::HorizontalMerge tableCellFormatHorizontalMergeFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::TableCellFormat::HorizontalMerge::NONE;
        if (value == "First") return aspose::words::cloud::models::TableCellFormat::HorizontalMerge::FIRST;
        if (value == "Previous") return aspose::words::cloud::models::TableCellFormat::HorizontalMerge::PREVIOUS;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string tableCellFormatOrientationToString(aspose::words::cloud::models::TableCellFormat::Orientation value)
    {
        if (value == aspose::words::cloud::models::TableCellFormat::Orientation::HORIZONTAL) return "Horizontal";
        if (value == aspose::words::cloud::models::TableCellFormat::Orientation::DOWNWARD) return "Downward";
        if (value == aspose::words::cloud::models::TableCellFormat::Orientation::UPWARD) return "Upward";
        if (value == aspose::words::cloud::models::TableCellFormat::Orientation::HORIZONTAL_ROTATED_FAR_EAST) return "HorizontalRotatedFarEast";
        if (value == aspose::words::cloud::models::TableCellFormat::Orientation::VERTICAL_FAR_EAST) return "VerticalFarEast";
        if (value == aspose::words::cloud::models::TableCellFormat::Orientation::VERTICAL_ROTATED_FAR_EAST) return "VerticalRotatedFarEast";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::TableCellFormat::Orientation tableCellFormatOrientationFromString(const std::string& value)
    {
        if (value == "Horizontal") return aspose::words::cloud::models::TableCellFormat::Orientation::HORIZONTAL;
        if (value == "Downward") return aspose::words::cloud::models::TableCellFormat::Orientation::DOWNWARD;
        if (value == "Upward") return aspose::words::cloud::models::TableCellFormat::Orientation::UPWARD;
        if (value == "HorizontalRotatedFarEast") return aspose::words::cloud::models::TableCellFormat::Orientation::HORIZONTAL_ROTATED_FAR_EAST;
        if (value == "VerticalFarEast") return aspose::words::cloud::models::TableCellFormat::Orientation::VERTICAL_FAR_EAST;
        if (value == "VerticalRotatedFarEast") return aspose::words::cloud::models::TableCellFormat::Orientation::VERTICAL_ROTATED_FAR_EAST;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string tableCellFormatVerticalAlignmentToString(aspose::words::cloud::models::TableCellFormat::VerticalAlignment value)
    {
        if (value == aspose::words::cloud::models::TableCellFormat::VerticalAlignment::TOP) return "Top";
        if (value == aspose::words::cloud::models::TableCellFormat::VerticalAlignment::CENTER) return "Center";
        if (value == aspose::words::cloud::models::TableCellFormat::VerticalAlignment::BOTTOM) return "Bottom";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::TableCellFormat::VerticalAlignment tableCellFormatVerticalAlignmentFromString(const std::string& value)
    {
        if (value == "Top") return aspose::words::cloud::models::TableCellFormat::VerticalAlignment::TOP;
        if (value == "Center") return aspose::words::cloud::models::TableCellFormat::VerticalAlignment::CENTER;
        if (value == "Bottom") return aspose::words::cloud::models::TableCellFormat::VerticalAlignment::BOTTOM;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string tableCellFormatVerticalMergeToString(aspose::words::cloud::models::TableCellFormat::VerticalMerge value)
    {
        if (value == aspose::words::cloud::models::TableCellFormat::VerticalMerge::NONE) return "None";
        if (value == aspose::words::cloud::models::TableCellFormat::VerticalMerge::FIRST) return "First";
        if (value == aspose::words::cloud::models::TableCellFormat::VerticalMerge::PREVIOUS) return "Previous";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::TableCellFormat::VerticalMerge tableCellFormatVerticalMergeFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::TableCellFormat::VerticalMerge::NONE;
        if (value == "First") return aspose::words::cloud::models::TableCellFormat::VerticalMerge::FIRST;
        if (value == "Previous") return aspose::words::cloud::models::TableCellFormat::VerticalMerge::PREVIOUS;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void TableCellFormat::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_BottomPadding) {
            json["BottomPadding"] = *(this->m_BottomPadding);
        }
        if (this->m_FitText) {
            json["FitText"] = *(this->m_FitText);
        }
        if (this->m_HorizontalMerge) {
            json["HorizontalMerge"] = tableCellFormatHorizontalMergeToString(*(this->m_HorizontalMerge));
        }
        if (this->m_LeftPadding) {
            json["LeftPadding"] = *(this->m_LeftPadding);
        }
        if (this->m_Orientation) {
            json["Orientation"] = tableCellFormatOrientationToString(*(this->m_Orientation));
        }
        if (this->m_PreferredWidth) {
            this->m_PreferredWidth->toJson(&json["PreferredWidth"]);
        }
        if (this->m_RightPadding) {
            json["RightPadding"] = *(this->m_RightPadding);
        }
        if (this->m_TopPadding) {
            json["TopPadding"] = *(this->m_TopPadding);
        }
        if (this->m_VerticalAlignment) {
            json["VerticalAlignment"] = tableCellFormatVerticalAlignmentToString(*(this->m_VerticalAlignment));
        }
        if (this->m_VerticalMerge) {
            json["VerticalMerge"] = tableCellFormatVerticalMergeToString(*(this->m_VerticalMerge));
        }
        if (this->m_Width) {
            json["Width"] = *(this->m_Width);
        }
        if (this->m_WrapText) {
            json["WrapText"] = *(this->m_WrapText);
        }
    }

    void TableCellFormat::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("BottomPadding") && !json["BottomPadding"].is_null()) {
            this->m_BottomPadding = std::make_shared< double >(
                json["BottomPadding"].get< double >()
            );
        }
        if (json.contains("FitText") && !json["FitText"].is_null()) {
            this->m_FitText = std::make_shared< bool >(
                json["FitText"].get< bool >()
            );
        }
        if (json.contains("HorizontalMerge") && !json["HorizontalMerge"].is_null()) {
            this->m_HorizontalMerge = std::make_shared< aspose::words::cloud::models::TableCellFormat::HorizontalMerge >(
                tableCellFormatHorizontalMergeFromString(json["HorizontalMerge"].get< std::string >())
            );
        }
        if (json.contains("LeftPadding") && !json["LeftPadding"].is_null()) {
            this->m_LeftPadding = std::make_shared< double >(
                json["LeftPadding"].get< double >()
            );
        }
        if (json.contains("Orientation") && !json["Orientation"].is_null()) {
            this->m_Orientation = std::make_shared< aspose::words::cloud::models::TableCellFormat::Orientation >(
                tableCellFormatOrientationFromString(json["Orientation"].get< std::string >())
            );
        }
        if (json.contains("PreferredWidth") && !json["PreferredWidth"].is_null()) {
            this->m_PreferredWidth = createModelInstance< aspose::words::cloud::models::PreferredWidth >(L"PreferredWidth, _", json["PreferredWidth"]);
        }
        if (json.contains("RightPadding") && !json["RightPadding"].is_null()) {
            this->m_RightPadding = std::make_shared< double >(
                json["RightPadding"].get< double >()
            );
        }
        if (json.contains("TopPadding") && !json["TopPadding"].is_null()) {
            this->m_TopPadding = std::make_shared< double >(
                json["TopPadding"].get< double >()
            );
        }
        if (json.contains("VerticalAlignment") && !json["VerticalAlignment"].is_null()) {
            this->m_VerticalAlignment = std::make_shared< aspose::words::cloud::models::TableCellFormat::VerticalAlignment >(
                tableCellFormatVerticalAlignmentFromString(json["VerticalAlignment"].get< std::string >())
            );
        }
        if (json.contains("VerticalMerge") && !json["VerticalMerge"].is_null()) {
            this->m_VerticalMerge = std::make_shared< aspose::words::cloud::models::TableCellFormat::VerticalMerge >(
                tableCellFormatVerticalMergeFromString(json["VerticalMerge"].get< std::string >())
            );
        }
        if (json.contains("Width") && !json["Width"].is_null()) {
            this->m_Width = std::make_shared< double >(
                json["Width"].get< double >()
            );
        }
        if (json.contains("WrapText") && !json["WrapText"].is_null()) {
            this->m_WrapText = std::make_shared< bool >(
                json["WrapText"].get< bool >()
            );
        }
    }

    void TableCellFormat::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TableCellFormat::validate()
    {
        LinkElement::validate();

        if (this->m_PreferredWidth != nullptr)
        {
            this->m_PreferredWidth->validate();
        }







    }

    std::shared_ptr< double > TableCellFormat::getBottomPadding() const
    {
        return this->m_BottomPadding;
    }

    void TableCellFormat::setBottomPadding(std::shared_ptr< double > value)
    {
        this->m_BottomPadding = value;
    }


    std::shared_ptr< bool > TableCellFormat::getFitText() const
    {
        return this->m_FitText;
    }

    void TableCellFormat::setFitText(std::shared_ptr< bool > value)
    {
        this->m_FitText = value;
    }


    std::shared_ptr< aspose::words::cloud::models::TableCellFormat::HorizontalMerge > TableCellFormat::getHorizontalMerge() const
    {
        return this->m_HorizontalMerge;
    }

    void TableCellFormat::setHorizontalMerge(std::shared_ptr< aspose::words::cloud::models::TableCellFormat::HorizontalMerge > value)
    {
        this->m_HorizontalMerge = value;
    }


    std::shared_ptr< double > TableCellFormat::getLeftPadding() const
    {
        return this->m_LeftPadding;
    }

    void TableCellFormat::setLeftPadding(std::shared_ptr< double > value)
    {
        this->m_LeftPadding = value;
    }


    std::shared_ptr< aspose::words::cloud::models::TableCellFormat::Orientation > TableCellFormat::getOrientation() const
    {
        return this->m_Orientation;
    }

    void TableCellFormat::setOrientation(std::shared_ptr< aspose::words::cloud::models::TableCellFormat::Orientation > value)
    {
        this->m_Orientation = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PreferredWidth > TableCellFormat::getPreferredWidth() const
    {
        return this->m_PreferredWidth;
    }

    void TableCellFormat::setPreferredWidth(std::shared_ptr< aspose::words::cloud::models::PreferredWidth > value)
    {
        this->m_PreferredWidth = value;
    }


    std::shared_ptr< double > TableCellFormat::getRightPadding() const
    {
        return this->m_RightPadding;
    }

    void TableCellFormat::setRightPadding(std::shared_ptr< double > value)
    {
        this->m_RightPadding = value;
    }


    std::shared_ptr< double > TableCellFormat::getTopPadding() const
    {
        return this->m_TopPadding;
    }

    void TableCellFormat::setTopPadding(std::shared_ptr< double > value)
    {
        this->m_TopPadding = value;
    }


    std::shared_ptr< aspose::words::cloud::models::TableCellFormat::VerticalAlignment > TableCellFormat::getVerticalAlignment() const
    {
        return this->m_VerticalAlignment;
    }

    void TableCellFormat::setVerticalAlignment(std::shared_ptr< aspose::words::cloud::models::TableCellFormat::VerticalAlignment > value)
    {
        this->m_VerticalAlignment = value;
    }


    std::shared_ptr< aspose::words::cloud::models::TableCellFormat::VerticalMerge > TableCellFormat::getVerticalMerge() const
    {
        return this->m_VerticalMerge;
    }

    void TableCellFormat::setVerticalMerge(std::shared_ptr< aspose::words::cloud::models::TableCellFormat::VerticalMerge > value)
    {
        this->m_VerticalMerge = value;
    }


    std::shared_ptr< double > TableCellFormat::getWidth() const
    {
        return this->m_Width;
    }

    void TableCellFormat::setWidth(std::shared_ptr< double > value)
    {
        this->m_Width = value;
    }


    std::shared_ptr< bool > TableCellFormat::getWrapText() const
    {
        return this->m_WrapText;
    }

    void TableCellFormat::setWrapText(std::shared_ptr< bool > value)
    {
        this->m_WrapText = value;
    }



    /*
     * TableCellFormatResponse implementation
     */
    void TableCellFormatResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_CellFormat) {
            this->m_CellFormat->toJson(&json["CellFormat"]);
        }
    }

    void TableCellFormatResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("CellFormat") && !json["CellFormat"].is_null()) {
            this->m_CellFormat = createModelInstance< aspose::words::cloud::models::TableCellFormat >(L"TableCellFormat, _", json["CellFormat"]);
        }
    }

    void TableCellFormatResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TableCellFormatResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_CellFormat != nullptr)
        {
            this->m_CellFormat->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::TableCellFormat > TableCellFormatResponse::getCellFormat() const
    {
        return this->m_CellFormat;
    }

    void TableCellFormatResponse::setCellFormat(std::shared_ptr< aspose::words::cloud::models::TableCellFormat > value)
    {
        this->m_CellFormat = value;
    }



    /*
     * TableCellInsert implementation
     */
    void TableCellInsert::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ExistingCellPosition) {
            this->m_ExistingCellPosition->toJson(&json["ExistingCellPosition"]);
        }
        if (this->m_InsertAfter) {
            json["InsertAfter"] = *(this->m_InsertAfter);
        }
    }

    void TableCellInsert::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ExistingCellPosition") && !json["ExistingCellPosition"].is_null()) {
            this->m_ExistingCellPosition = createModelInstance< aspose::words::cloud::models::Position >(L"Position, _", json["ExistingCellPosition"]);
        }
        if (json.contains("InsertAfter") && !json["InsertAfter"].is_null()) {
            this->m_InsertAfter = std::make_shared< int32_t >(
                json["InsertAfter"].get< int32_t >()
            );
        }
    }

    void TableCellInsert::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TableCellInsert::validate()
    {

        if (this->m_ExistingCellPosition != nullptr)
        {
            this->m_ExistingCellPosition->validate();
        }


    }

    std::shared_ptr< aspose::words::cloud::models::Position > TableCellInsert::getExistingCellPosition() const
    {
        return this->m_ExistingCellPosition;
    }

    void TableCellInsert::setExistingCellPosition(std::shared_ptr< aspose::words::cloud::models::Position > value)
    {
        this->m_ExistingCellPosition = value;
    }


    std::shared_ptr< int32_t > TableCellInsert::getInsertAfter() const
    {
        return this->m_InsertAfter;
    }

    void TableCellInsert::setInsertAfter(std::shared_ptr< int32_t > value)
    {
        this->m_InsertAfter = value;
    }



    /*
     * TableCellResponse implementation
     */
    void TableCellResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Cell) {
            this->m_Cell->toJson(&json["Cell"]);
        }
    }

    void TableCellResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Cell") && !json["Cell"].is_null()) {
            this->m_Cell = createModelInstance< aspose::words::cloud::models::TableCell >(L"TableCell, _", json["Cell"]);
        }
    }

    void TableCellResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TableCellResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Cell != nullptr)
        {
            this->m_Cell->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::TableCell > TableCellResponse::getCell() const
    {
        return this->m_Cell;
    }

    void TableCellResponse::setCell(std::shared_ptr< aspose::words::cloud::models::TableCell > value)
    {
        this->m_Cell = value;
    }



    /*
     * TableInsert implementation
     */
    void TableInsert::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ColumnsCount) {
            json["ColumnsCount"] = *(this->m_ColumnsCount);
        }
        if (this->m_Position) {
            this->m_Position->toJson(&json["Position"]);
        }
        if (this->m_RowsCount) {
            json["RowsCount"] = *(this->m_RowsCount);
        }
    }

    void TableInsert::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ColumnsCount") && !json["ColumnsCount"].is_null()) {
            this->m_ColumnsCount = std::make_shared< int32_t >(
                json["ColumnsCount"].get< int32_t >()
            );
        }
        if (json.contains("Position") && !json["Position"].is_null()) {
            this->m_Position = createModelInstance< aspose::words::cloud::models::Position >(L"Position, _", json["Position"]);
        }
        if (json.contains("RowsCount") && !json["RowsCount"].is_null()) {
            this->m_RowsCount = std::make_shared< int32_t >(
                json["RowsCount"].get< int32_t >()
            );
        }
    }

    void TableInsert::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TableInsert::validate()
    {
        if (this->m_ColumnsCount == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property ColumnsCount in TableInsert is required.");
        }

        if (this->m_RowsCount == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property RowsCount in TableInsert is required.");
        }


        if (this->m_Position != nullptr)
        {
            this->m_Position->validate();
        }


    }

    std::shared_ptr< int32_t > TableInsert::getColumnsCount() const
    {
        return this->m_ColumnsCount;
    }

    void TableInsert::setColumnsCount(std::shared_ptr< int32_t > value)
    {
        this->m_ColumnsCount = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Position > TableInsert::getPosition() const
    {
        return this->m_Position;
    }

    void TableInsert::setPosition(std::shared_ptr< aspose::words::cloud::models::Position > value)
    {
        this->m_Position = value;
    }


    std::shared_ptr< int32_t > TableInsert::getRowsCount() const
    {
        return this->m_RowsCount;
    }

    void TableInsert::setRowsCount(std::shared_ptr< int32_t > value)
    {
        this->m_RowsCount = value;
    }



    /*
     * TableLink implementation
     */
    void TableLink::toJson(void* jsonIfc) const
    {
        NodeLink::toJson(jsonIfc);
    }

    void TableLink::fromJson(const void* jsonIfc)
    {
        NodeLink::fromJson(jsonIfc);
    }

    void TableLink::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TableLink::validate()
    {
        NodeLink::validate();
    }




    /*
     * TableLinkCollection implementation
     */
    void TableLinkCollection::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_TableLinkList) {
            json["TableLinkList"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_TableLinkList)) {
                element->toJson(&json["TableLinkList"].emplace_back());
            }
        }
    }

    void TableLinkCollection::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("TableLinkList") && !json["TableLinkList"].is_null()) {
            this->m_TableLinkList = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::TableLink>> >();
            for (auto& element : json["TableLinkList"]) {
                this->m_TableLinkList->emplace_back(createModelInstance< aspose::words::cloud::models::TableLink >(L"TableLink, _", element));
            }
        }
    }

    void TableLinkCollection::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TableLinkCollection::validate()
    {
        LinkElement::validate();

        if (this->m_TableLinkList != nullptr)
        {
            for (auto& elementTableLinkList : *(this->m_TableLinkList))
            {
                if (elementTableLinkList != nullptr)
                {
                    elementTableLinkList->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::TableLink>> > TableLinkCollection::getTableLinkList() const
    {
        return this->m_TableLinkList;
    }

    void TableLinkCollection::setTableLinkList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::TableLink>> > value)
    {
        this->m_TableLinkList = value;
    }



    /*
     * TableLinkCollectionResponse implementation
     */
    void TableLinkCollectionResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Tables) {
            this->m_Tables->toJson(&json["Tables"]);
        }
    }

    void TableLinkCollectionResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Tables") && !json["Tables"].is_null()) {
            this->m_Tables = createModelInstance< aspose::words::cloud::models::TableLinkCollection >(L"TableLinkCollection, _", json["Tables"]);
        }
    }

    void TableLinkCollectionResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TableLinkCollectionResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Tables != nullptr)
        {
            this->m_Tables->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::TableLinkCollection > TableLinkCollectionResponse::getTables() const
    {
        return this->m_Tables;
    }

    void TableLinkCollectionResponse::setTables(std::shared_ptr< aspose::words::cloud::models::TableLinkCollection > value)
    {
        this->m_Tables = value;
    }



    /*
     * TableProperties implementation
     */
    inline std::string tablePropertiesAlignmentToString(aspose::words::cloud::models::TableProperties::Alignment value)
    {
        if (value == aspose::words::cloud::models::TableProperties::Alignment::LEFT) return "Left";
        if (value == aspose::words::cloud::models::TableProperties::Alignment::CENTER) return "Center";
        if (value == aspose::words::cloud::models::TableProperties::Alignment::RIGHT) return "Right";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::TableProperties::Alignment tablePropertiesAlignmentFromString(const std::string& value)
    {
        if (value == "Left") return aspose::words::cloud::models::TableProperties::Alignment::LEFT;
        if (value == "Center") return aspose::words::cloud::models::TableProperties::Alignment::CENTER;
        if (value == "Right") return aspose::words::cloud::models::TableProperties::Alignment::RIGHT;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string tablePropertiesStyleIdentifierToString(aspose::words::cloud::models::TableProperties::StyleIdentifier value)
    {
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::NORMAL) return "Normal";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING1) return "Heading1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING2) return "Heading2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING3) return "Heading3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING4) return "Heading4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING5) return "Heading5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING6) return "Heading6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING7) return "Heading7";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING8) return "Heading8";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING9) return "Heading9";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX1) return "Index1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX2) return "Index2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX3) return "Index3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX4) return "Index4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX5) return "Index5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX6) return "Index6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX7) return "Index7";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX8) return "Index8";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX9) return "Index9";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC1) return "Toc1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC2) return "Toc2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC3) return "Toc3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC4) return "Toc4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC5) return "Toc5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC6) return "Toc6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC7) return "Toc7";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC8) return "Toc8";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC9) return "Toc9";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::NORMAL_INDENT) return "NormalIndent";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::FOOTNOTE_TEXT) return "FootnoteText";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COMMENT_TEXT) return "CommentText";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADER) return "Header";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::FOOTER) return "Footer";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX_HEADING) return "IndexHeading";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::CAPTION) return "Caption";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_OF_FIGURES) return "TableOfFigures";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::ENVELOPE_ADDRESS) return "EnvelopeAddress";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::ENVELOPE_RETURN) return "EnvelopeReturn";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::FOOTNOTE_REFERENCE) return "FootnoteReference";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COMMENT_REFERENCE) return "CommentReference";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LINE_NUMBER) return "LineNumber";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::PAGE_NUMBER) return "PageNumber";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::ENDNOTE_REFERENCE) return "EndnoteReference";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::ENDNOTE_TEXT) return "EndnoteText";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_OF_AUTHORITIES) return "TableOfAuthorities";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MACRO) return "Macro";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TOA_HEADING) return "ToaHeading";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST) return "List";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_BULLET) return "ListBullet";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_NUMBER) return "ListNumber";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST2) return "List2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST3) return "List3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST4) return "List4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST5) return "List5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_BULLET2) return "ListBullet2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_BULLET3) return "ListBullet3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_BULLET4) return "ListBullet4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_BULLET5) return "ListBullet5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_NUMBER2) return "ListNumber2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_NUMBER3) return "ListNumber3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_NUMBER4) return "ListNumber4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_NUMBER5) return "ListNumber5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TITLE) return "Title";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::CLOSING) return "Closing";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::SIGNATURE) return "Signature";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::DEFAULT_PARAGRAPH_FONT) return "DefaultParagraphFont";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::BODY_TEXT) return "BodyText";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::BODY_TEXT_IND) return "BodyTextInd";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_CONTINUE) return "ListContinue";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_CONTINUE2) return "ListContinue2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_CONTINUE3) return "ListContinue3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_CONTINUE4) return "ListContinue4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_CONTINUE5) return "ListContinue5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MESSAGE_HEADER) return "MessageHeader";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::SUBTITLE) return "Subtitle";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::SALUTATION) return "Salutation";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::DATE) return "Date";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::BODY_TEXT1_I) return "BodyText1I";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::BODY_TEXT1_I2) return "BodyText1I2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::NOTE_HEADING) return "NoteHeading";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::BODY_TEXT2) return "BodyText2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::BODY_TEXT3) return "BodyText3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::BODY_TEXT_IND2) return "BodyTextInd2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::BODY_TEXT_IND3) return "BodyTextInd3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::BLOCK_TEXT) return "BlockText";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HYPERLINK) return "Hyperlink";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::FOLLOWED_HYPERLINK) return "FollowedHyperlink";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::STRONG) return "Strong";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::EMPHASIS) return "Emphasis";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::DOCUMENT_MAP) return "DocumentMap";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::PLAIN_TEXT) return "PlainText";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::EMAIL_SIGNATURE) return "EmailSignature";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_TOP_OF_FORM) return "HtmlTopOfForm";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_BOTTOM_OF_FORM) return "HtmlBottomOfForm";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::NORMAL_WEB) return "NormalWeb";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_ACRONYM) return "HtmlAcronym";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_ADDRESS) return "HtmlAddress";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_CITE) return "HtmlCite";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_CODE) return "HtmlCode";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_DEFINITION) return "HtmlDefinition";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_KEYBOARD) return "HtmlKeyboard";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_PREFORMATTED) return "HtmlPreformatted";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_SAMPLE) return "HtmlSample";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_TYPEWRITER) return "HtmlTypewriter";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_VARIABLE) return "HtmlVariable";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_NORMAL) return "TableNormal";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COMMENT_SUBJECT) return "CommentSubject";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::NO_LIST) return "NoList";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::OUTLINE_LIST1) return "OutlineList1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::OUTLINE_LIST2) return "OutlineList2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::OUTLINE_LIST3) return "OutlineList3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_SIMPLE1) return "TableSimple1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_SIMPLE2) return "TableSimple2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_SIMPLE3) return "TableSimple3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_CLASSIC1) return "TableClassic1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_CLASSIC2) return "TableClassic2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_CLASSIC3) return "TableClassic3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_CLASSIC4) return "TableClassic4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_COLORFUL1) return "TableColorful1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_COLORFUL2) return "TableColorful2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_COLORFUL3) return "TableColorful3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_COLUMNS1) return "TableColumns1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_COLUMNS2) return "TableColumns2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_COLUMNS3) return "TableColumns3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_COLUMNS4) return "TableColumns4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_COLUMNS5) return "TableColumns5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID1) return "TableGrid1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID2) return "TableGrid2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID3) return "TableGrid3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID4) return "TableGrid4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID5) return "TableGrid5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID6) return "TableGrid6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID7) return "TableGrid7";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID8) return "TableGrid8";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_LIST1) return "TableList1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_LIST2) return "TableList2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_LIST3) return "TableList3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_LIST4) return "TableList4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_LIST5) return "TableList5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_LIST6) return "TableList6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_LIST7) return "TableList7";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_LIST8) return "TableList8";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE3_D_EFFECTS1) return "Table3DEffects1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE3_D_EFFECTS2) return "Table3DEffects2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE3_D_EFFECTS3) return "Table3DEffects3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_CONTEMPORARY) return "TableContemporary";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_ELEGANT) return "TableElegant";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_PROFESSIONAL) return "TableProfessional";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_SUBTLE1) return "TableSubtle1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_SUBTLE2) return "TableSubtle2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_WEB1) return "TableWeb1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_WEB2) return "TableWeb2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_WEB3) return "TableWeb3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::BALLOON_TEXT) return "BalloonText";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID) return "TableGrid";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_THEME) return "TableTheme";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::PLACEHOLDER_TEXT) return "PlaceholderText";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::NO_SPACING) return "NoSpacing";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_SHADING) return "LightShading";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_LIST) return "LightList";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_GRID) return "LightGrid";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING1) return "MediumShading1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING2) return "MediumShading2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST1) return "MediumList1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST2) return "MediumList2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID1) return "MediumGrid1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID2) return "MediumGrid2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID3) return "MediumGrid3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::DARK_LIST) return "DarkList";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_SHADING) return "ColorfulShading";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_LIST) return "ColorfulList";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_GRID) return "ColorfulGrid";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_SHADING_ACCENT1) return "LightShadingAccent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_LIST_ACCENT1) return "LightListAccent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_GRID_ACCENT1) return "LightGridAccent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING1_ACCENT1) return "MediumShading1Accent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING2_ACCENT1) return "MediumShading2Accent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST1_ACCENT1) return "MediumList1Accent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::REVISION) return "Revision";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_PARAGRAPH) return "ListParagraph";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::QUOTE) return "Quote";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::INTENSE_QUOTE) return "IntenseQuote";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST2_ACCENT1) return "MediumList2Accent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID1_ACCENT1) return "MediumGrid1Accent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID2_ACCENT1) return "MediumGrid2Accent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID3_ACCENT1) return "MediumGrid3Accent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::DARK_LIST_ACCENT1) return "DarkListAccent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_SHADING_ACCENT1) return "ColorfulShadingAccent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_LIST_ACCENT1) return "ColorfulListAccent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_GRID_ACCENT1) return "ColorfulGridAccent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_SHADING_ACCENT2) return "LightShadingAccent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_LIST_ACCENT2) return "LightListAccent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_GRID_ACCENT2) return "LightGridAccent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING1_ACCENT2) return "MediumShading1Accent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING2_ACCENT2) return "MediumShading2Accent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST1_ACCENT2) return "MediumList1Accent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST2_ACCENT2) return "MediumList2Accent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID1_ACCENT2) return "MediumGrid1Accent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID2_ACCENT2) return "MediumGrid2Accent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID3_ACCENT2) return "MediumGrid3Accent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::DARK_LIST_ACCENT2) return "DarkListAccent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_SHADING_ACCENT2) return "ColorfulShadingAccent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_LIST_ACCENT2) return "ColorfulListAccent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_GRID_ACCENT2) return "ColorfulGridAccent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_SHADING_ACCENT3) return "LightShadingAccent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_LIST_ACCENT3) return "LightListAccent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_GRID_ACCENT3) return "LightGridAccent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING1_ACCENT3) return "MediumShading1Accent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING2_ACCENT3) return "MediumShading2Accent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST1_ACCENT3) return "MediumList1Accent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST2_ACCENT3) return "MediumList2Accent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID1_ACCENT3) return "MediumGrid1Accent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID2_ACCENT3) return "MediumGrid2Accent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID3_ACCENT3) return "MediumGrid3Accent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::DARK_LIST_ACCENT3) return "DarkListAccent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_SHADING_ACCENT3) return "ColorfulShadingAccent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_LIST_ACCENT3) return "ColorfulListAccent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_GRID_ACCENT3) return "ColorfulGridAccent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_SHADING_ACCENT4) return "LightShadingAccent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_LIST_ACCENT4) return "LightListAccent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_GRID_ACCENT4) return "LightGridAccent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING1_ACCENT4) return "MediumShading1Accent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING2_ACCENT4) return "MediumShading2Accent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST1_ACCENT4) return "MediumList1Accent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST2_ACCENT4) return "MediumList2Accent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID1_ACCENT4) return "MediumGrid1Accent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID2_ACCENT4) return "MediumGrid2Accent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID3_ACCENT4) return "MediumGrid3Accent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::DARK_LIST_ACCENT4) return "DarkListAccent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_SHADING_ACCENT4) return "ColorfulShadingAccent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_LIST_ACCENT4) return "ColorfulListAccent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_GRID_ACCENT4) return "ColorfulGridAccent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_SHADING_ACCENT5) return "LightShadingAccent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_LIST_ACCENT5) return "LightListAccent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_GRID_ACCENT5) return "LightGridAccent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING1_ACCENT5) return "MediumShading1Accent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING2_ACCENT5) return "MediumShading2Accent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST1_ACCENT5) return "MediumList1Accent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST2_ACCENT5) return "MediumList2Accent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID1_ACCENT5) return "MediumGrid1Accent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID2_ACCENT5) return "MediumGrid2Accent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID3_ACCENT5) return "MediumGrid3Accent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::DARK_LIST_ACCENT5) return "DarkListAccent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_SHADING_ACCENT5) return "ColorfulShadingAccent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_LIST_ACCENT5) return "ColorfulListAccent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_GRID_ACCENT5) return "ColorfulGridAccent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_SHADING_ACCENT6) return "LightShadingAccent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_LIST_ACCENT6) return "LightListAccent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_GRID_ACCENT6) return "LightGridAccent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING1_ACCENT6) return "MediumShading1Accent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING2_ACCENT6) return "MediumShading2Accent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST1_ACCENT6) return "MediumList1Accent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST2_ACCENT6) return "MediumList2Accent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID1_ACCENT6) return "MediumGrid1Accent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID2_ACCENT6) return "MediumGrid2Accent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID3_ACCENT6) return "MediumGrid3Accent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::DARK_LIST_ACCENT6) return "DarkListAccent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_SHADING_ACCENT6) return "ColorfulShadingAccent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_LIST_ACCENT6) return "ColorfulListAccent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_GRID_ACCENT6) return "ColorfulGridAccent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::SUBTLE_EMPHASIS) return "SubtleEmphasis";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::INTENSE_EMPHASIS) return "IntenseEmphasis";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::SUBTLE_REFERENCE) return "SubtleReference";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::INTENSE_REFERENCE) return "IntenseReference";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::BOOK_TITLE) return "BookTitle";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::BIBLIOGRAPHY) return "Bibliography";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC_HEADING) return "TocHeading";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::PLAIN_TABLE1) return "PlainTable1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::PLAIN_TABLE2) return "PlainTable2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::PLAIN_TABLE3) return "PlainTable3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::PLAIN_TABLE4) return "PlainTable4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::PLAIN_TABLE5) return "PlainTable5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID_LIGHT) return "TableGridLight";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE1_LIGHT) return "GridTable1Light";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE2) return "GridTable2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE3) return "GridTable3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE4) return "GridTable4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE5_DARK) return "GridTable5Dark";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE6_COLORFUL) return "GridTable6Colorful";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE7_COLORFUL) return "GridTable7Colorful";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT1) return "GridTable1LightAccent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE2_ACCENT1) return "GridTable2Accent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE3_ACCENT1) return "GridTable3Accent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE4_ACCENT1) return "GridTable4Accent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE5_DARK_ACCENT1) return "GridTable5DarkAccent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT1) return "GridTable6ColorfulAccent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT1) return "GridTable7ColorfulAccent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT2) return "GridTable1LightAccent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE2_ACCENT2) return "GridTable2Accent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE3_ACCENT2) return "GridTable3Accent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE4_ACCENT2) return "GridTable4Accent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE5_DARK_ACCENT2) return "GridTable5DarkAccent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT2) return "GridTable6ColorfulAccent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT2) return "GridTable7ColorfulAccent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT3) return "GridTable1LightAccent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE2_ACCENT3) return "GridTable2Accent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE3_ACCENT3) return "GridTable3Accent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE4_ACCENT3) return "GridTable4Accent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE5_DARK_ACCENT3) return "GridTable5DarkAccent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT3) return "GridTable6ColorfulAccent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT3) return "GridTable7ColorfulAccent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT4) return "GridTable1LightAccent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE2_ACCENT4) return "GridTable2Accent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE3_ACCENT4) return "GridTable3Accent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE4_ACCENT4) return "GridTable4Accent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE5_DARK_ACCENT4) return "GridTable5DarkAccent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT4) return "GridTable6ColorfulAccent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT4) return "GridTable7ColorfulAccent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT5) return "GridTable1LightAccent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE2_ACCENT5) return "GridTable2Accent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE3_ACCENT5) return "GridTable3Accent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE4_ACCENT5) return "GridTable4Accent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE5_DARK_ACCENT5) return "GridTable5DarkAccent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT5) return "GridTable6ColorfulAccent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT5) return "GridTable7ColorfulAccent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT6) return "GridTable1LightAccent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE2_ACCENT6) return "GridTable2Accent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE3_ACCENT6) return "GridTable3Accent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE4_ACCENT6) return "GridTable4Accent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE5_DARK_ACCENT6) return "GridTable5DarkAccent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT6) return "GridTable6ColorfulAccent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT6) return "GridTable7ColorfulAccent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE1_LIGHT) return "ListTable1Light";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE2) return "ListTable2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE3) return "ListTable3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE4) return "ListTable4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE5_DARK) return "ListTable5Dark";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE6_COLORFUL) return "ListTable6Colorful";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE7_COLORFUL) return "ListTable7Colorful";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT1) return "ListTable1LightAccent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE2_ACCENT1) return "ListTable2Accent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE3_ACCENT1) return "ListTable3Accent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE4_ACCENT1) return "ListTable4Accent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE5_DARK_ACCENT1) return "ListTable5DarkAccent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT1) return "ListTable6ColorfulAccent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT1) return "ListTable7ColorfulAccent1";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT2) return "ListTable1LightAccent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE2_ACCENT2) return "ListTable2Accent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE3_ACCENT2) return "ListTable3Accent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE4_ACCENT2) return "ListTable4Accent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE5_DARK_ACCENT2) return "ListTable5DarkAccent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT2) return "ListTable6ColorfulAccent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT2) return "ListTable7ColorfulAccent2";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT3) return "ListTable1LightAccent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE2_ACCENT3) return "ListTable2Accent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE3_ACCENT3) return "ListTable3Accent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE4_ACCENT3) return "ListTable4Accent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE5_DARK_ACCENT3) return "ListTable5DarkAccent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT3) return "ListTable6ColorfulAccent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT3) return "ListTable7ColorfulAccent3";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT4) return "ListTable1LightAccent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE2_ACCENT4) return "ListTable2Accent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE3_ACCENT4) return "ListTable3Accent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE4_ACCENT4) return "ListTable4Accent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE5_DARK_ACCENT4) return "ListTable5DarkAccent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT4) return "ListTable6ColorfulAccent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT4) return "ListTable7ColorfulAccent4";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT5) return "ListTable1LightAccent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE2_ACCENT5) return "ListTable2Accent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE3_ACCENT5) return "ListTable3Accent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE4_ACCENT5) return "ListTable4Accent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE5_DARK_ACCENT5) return "ListTable5DarkAccent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT5) return "ListTable6ColorfulAccent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT5) return "ListTable7ColorfulAccent5";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT6) return "ListTable1LightAccent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE2_ACCENT6) return "ListTable2Accent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE3_ACCENT6) return "ListTable3Accent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE4_ACCENT6) return "ListTable4Accent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE5_DARK_ACCENT6) return "ListTable5DarkAccent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT6) return "ListTable6ColorfulAccent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT6) return "ListTable7ColorfulAccent6";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::SMART_LINK) return "SmartLink";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::MENTION) return "Mention";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::SMART_HYPERLINK) return "SmartHyperlink";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::HASHTAG) return "Hashtag";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::UNRESOLVED_MENTION) return "UnresolvedMention";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::USER) return "User";
        if (value == aspose::words::cloud::models::TableProperties::StyleIdentifier::NIL) return "Nil";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::TableProperties::StyleIdentifier tablePropertiesStyleIdentifierFromString(const std::string& value)
    {
        if (value == "Normal") return aspose::words::cloud::models::TableProperties::StyleIdentifier::NORMAL;
        if (value == "Heading1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING1;
        if (value == "Heading2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING2;
        if (value == "Heading3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING3;
        if (value == "Heading4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING4;
        if (value == "Heading5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING5;
        if (value == "Heading6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING6;
        if (value == "Heading7") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING7;
        if (value == "Heading8") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING8;
        if (value == "Heading9") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADING9;
        if (value == "Index1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX1;
        if (value == "Index2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX2;
        if (value == "Index3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX3;
        if (value == "Index4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX4;
        if (value == "Index5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX5;
        if (value == "Index6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX6;
        if (value == "Index7") return aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX7;
        if (value == "Index8") return aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX8;
        if (value == "Index9") return aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX9;
        if (value == "Toc1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC1;
        if (value == "Toc2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC2;
        if (value == "Toc3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC3;
        if (value == "Toc4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC4;
        if (value == "Toc5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC5;
        if (value == "Toc6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC6;
        if (value == "Toc7") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC7;
        if (value == "Toc8") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC8;
        if (value == "Toc9") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC9;
        if (value == "NormalIndent") return aspose::words::cloud::models::TableProperties::StyleIdentifier::NORMAL_INDENT;
        if (value == "FootnoteText") return aspose::words::cloud::models::TableProperties::StyleIdentifier::FOOTNOTE_TEXT;
        if (value == "CommentText") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COMMENT_TEXT;
        if (value == "Header") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HEADER;
        if (value == "Footer") return aspose::words::cloud::models::TableProperties::StyleIdentifier::FOOTER;
        if (value == "IndexHeading") return aspose::words::cloud::models::TableProperties::StyleIdentifier::INDEX_HEADING;
        if (value == "Caption") return aspose::words::cloud::models::TableProperties::StyleIdentifier::CAPTION;
        if (value == "TableOfFigures") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_OF_FIGURES;
        if (value == "EnvelopeAddress") return aspose::words::cloud::models::TableProperties::StyleIdentifier::ENVELOPE_ADDRESS;
        if (value == "EnvelopeReturn") return aspose::words::cloud::models::TableProperties::StyleIdentifier::ENVELOPE_RETURN;
        if (value == "FootnoteReference") return aspose::words::cloud::models::TableProperties::StyleIdentifier::FOOTNOTE_REFERENCE;
        if (value == "CommentReference") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COMMENT_REFERENCE;
        if (value == "LineNumber") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LINE_NUMBER;
        if (value == "PageNumber") return aspose::words::cloud::models::TableProperties::StyleIdentifier::PAGE_NUMBER;
        if (value == "EndnoteReference") return aspose::words::cloud::models::TableProperties::StyleIdentifier::ENDNOTE_REFERENCE;
        if (value == "EndnoteText") return aspose::words::cloud::models::TableProperties::StyleIdentifier::ENDNOTE_TEXT;
        if (value == "TableOfAuthorities") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_OF_AUTHORITIES;
        if (value == "Macro") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MACRO;
        if (value == "ToaHeading") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TOA_HEADING;
        if (value == "List") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST;
        if (value == "ListBullet") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_BULLET;
        if (value == "ListNumber") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_NUMBER;
        if (value == "List2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST2;
        if (value == "List3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST3;
        if (value == "List4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST4;
        if (value == "List5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST5;
        if (value == "ListBullet2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_BULLET2;
        if (value == "ListBullet3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_BULLET3;
        if (value == "ListBullet4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_BULLET4;
        if (value == "ListBullet5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_BULLET5;
        if (value == "ListNumber2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_NUMBER2;
        if (value == "ListNumber3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_NUMBER3;
        if (value == "ListNumber4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_NUMBER4;
        if (value == "ListNumber5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_NUMBER5;
        if (value == "Title") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TITLE;
        if (value == "Closing") return aspose::words::cloud::models::TableProperties::StyleIdentifier::CLOSING;
        if (value == "Signature") return aspose::words::cloud::models::TableProperties::StyleIdentifier::SIGNATURE;
        if (value == "DefaultParagraphFont") return aspose::words::cloud::models::TableProperties::StyleIdentifier::DEFAULT_PARAGRAPH_FONT;
        if (value == "BodyText") return aspose::words::cloud::models::TableProperties::StyleIdentifier::BODY_TEXT;
        if (value == "BodyTextInd") return aspose::words::cloud::models::TableProperties::StyleIdentifier::BODY_TEXT_IND;
        if (value == "ListContinue") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_CONTINUE;
        if (value == "ListContinue2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_CONTINUE2;
        if (value == "ListContinue3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_CONTINUE3;
        if (value == "ListContinue4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_CONTINUE4;
        if (value == "ListContinue5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_CONTINUE5;
        if (value == "MessageHeader") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MESSAGE_HEADER;
        if (value == "Subtitle") return aspose::words::cloud::models::TableProperties::StyleIdentifier::SUBTITLE;
        if (value == "Salutation") return aspose::words::cloud::models::TableProperties::StyleIdentifier::SALUTATION;
        if (value == "Date") return aspose::words::cloud::models::TableProperties::StyleIdentifier::DATE;
        if (value == "BodyText1I") return aspose::words::cloud::models::TableProperties::StyleIdentifier::BODY_TEXT1_I;
        if (value == "BodyText1I2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::BODY_TEXT1_I2;
        if (value == "NoteHeading") return aspose::words::cloud::models::TableProperties::StyleIdentifier::NOTE_HEADING;
        if (value == "BodyText2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::BODY_TEXT2;
        if (value == "BodyText3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::BODY_TEXT3;
        if (value == "BodyTextInd2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::BODY_TEXT_IND2;
        if (value == "BodyTextInd3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::BODY_TEXT_IND3;
        if (value == "BlockText") return aspose::words::cloud::models::TableProperties::StyleIdentifier::BLOCK_TEXT;
        if (value == "Hyperlink") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HYPERLINK;
        if (value == "FollowedHyperlink") return aspose::words::cloud::models::TableProperties::StyleIdentifier::FOLLOWED_HYPERLINK;
        if (value == "Strong") return aspose::words::cloud::models::TableProperties::StyleIdentifier::STRONG;
        if (value == "Emphasis") return aspose::words::cloud::models::TableProperties::StyleIdentifier::EMPHASIS;
        if (value == "DocumentMap") return aspose::words::cloud::models::TableProperties::StyleIdentifier::DOCUMENT_MAP;
        if (value == "PlainText") return aspose::words::cloud::models::TableProperties::StyleIdentifier::PLAIN_TEXT;
        if (value == "EmailSignature") return aspose::words::cloud::models::TableProperties::StyleIdentifier::EMAIL_SIGNATURE;
        if (value == "HtmlTopOfForm") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_TOP_OF_FORM;
        if (value == "HtmlBottomOfForm") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_BOTTOM_OF_FORM;
        if (value == "NormalWeb") return aspose::words::cloud::models::TableProperties::StyleIdentifier::NORMAL_WEB;
        if (value == "HtmlAcronym") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_ACRONYM;
        if (value == "HtmlAddress") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_ADDRESS;
        if (value == "HtmlCite") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_CITE;
        if (value == "HtmlCode") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_CODE;
        if (value == "HtmlDefinition") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_DEFINITION;
        if (value == "HtmlKeyboard") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_KEYBOARD;
        if (value == "HtmlPreformatted") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_PREFORMATTED;
        if (value == "HtmlSample") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_SAMPLE;
        if (value == "HtmlTypewriter") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_TYPEWRITER;
        if (value == "HtmlVariable") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HTML_VARIABLE;
        if (value == "TableNormal") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_NORMAL;
        if (value == "CommentSubject") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COMMENT_SUBJECT;
        if (value == "NoList") return aspose::words::cloud::models::TableProperties::StyleIdentifier::NO_LIST;
        if (value == "OutlineList1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::OUTLINE_LIST1;
        if (value == "OutlineList2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::OUTLINE_LIST2;
        if (value == "OutlineList3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::OUTLINE_LIST3;
        if (value == "TableSimple1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_SIMPLE1;
        if (value == "TableSimple2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_SIMPLE2;
        if (value == "TableSimple3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_SIMPLE3;
        if (value == "TableClassic1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_CLASSIC1;
        if (value == "TableClassic2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_CLASSIC2;
        if (value == "TableClassic3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_CLASSIC3;
        if (value == "TableClassic4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_CLASSIC4;
        if (value == "TableColorful1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_COLORFUL1;
        if (value == "TableColorful2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_COLORFUL2;
        if (value == "TableColorful3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_COLORFUL3;
        if (value == "TableColumns1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_COLUMNS1;
        if (value == "TableColumns2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_COLUMNS2;
        if (value == "TableColumns3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_COLUMNS3;
        if (value == "TableColumns4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_COLUMNS4;
        if (value == "TableColumns5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_COLUMNS5;
        if (value == "TableGrid1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID1;
        if (value == "TableGrid2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID2;
        if (value == "TableGrid3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID3;
        if (value == "TableGrid4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID4;
        if (value == "TableGrid5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID5;
        if (value == "TableGrid6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID6;
        if (value == "TableGrid7") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID7;
        if (value == "TableGrid8") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID8;
        if (value == "TableList1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_LIST1;
        if (value == "TableList2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_LIST2;
        if (value == "TableList3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_LIST3;
        if (value == "TableList4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_LIST4;
        if (value == "TableList5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_LIST5;
        if (value == "TableList6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_LIST6;
        if (value == "TableList7") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_LIST7;
        if (value == "TableList8") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_LIST8;
        if (value == "Table3DEffects1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE3_D_EFFECTS1;
        if (value == "Table3DEffects2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE3_D_EFFECTS2;
        if (value == "Table3DEffects3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE3_D_EFFECTS3;
        if (value == "TableContemporary") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_CONTEMPORARY;
        if (value == "TableElegant") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_ELEGANT;
        if (value == "TableProfessional") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_PROFESSIONAL;
        if (value == "TableSubtle1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_SUBTLE1;
        if (value == "TableSubtle2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_SUBTLE2;
        if (value == "TableWeb1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_WEB1;
        if (value == "TableWeb2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_WEB2;
        if (value == "TableWeb3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_WEB3;
        if (value == "BalloonText") return aspose::words::cloud::models::TableProperties::StyleIdentifier::BALLOON_TEXT;
        if (value == "TableGrid") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID;
        if (value == "TableTheme") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_THEME;
        if (value == "PlaceholderText") return aspose::words::cloud::models::TableProperties::StyleIdentifier::PLACEHOLDER_TEXT;
        if (value == "NoSpacing") return aspose::words::cloud::models::TableProperties::StyleIdentifier::NO_SPACING;
        if (value == "LightShading") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_SHADING;
        if (value == "LightList") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_LIST;
        if (value == "LightGrid") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_GRID;
        if (value == "MediumShading1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING1;
        if (value == "MediumShading2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING2;
        if (value == "MediumList1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST1;
        if (value == "MediumList2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST2;
        if (value == "MediumGrid1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID1;
        if (value == "MediumGrid2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID2;
        if (value == "MediumGrid3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID3;
        if (value == "DarkList") return aspose::words::cloud::models::TableProperties::StyleIdentifier::DARK_LIST;
        if (value == "ColorfulShading") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_SHADING;
        if (value == "ColorfulList") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_LIST;
        if (value == "ColorfulGrid") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_GRID;
        if (value == "LightShadingAccent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_SHADING_ACCENT1;
        if (value == "LightListAccent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_LIST_ACCENT1;
        if (value == "LightGridAccent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_GRID_ACCENT1;
        if (value == "MediumShading1Accent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING1_ACCENT1;
        if (value == "MediumShading2Accent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING2_ACCENT1;
        if (value == "MediumList1Accent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST1_ACCENT1;
        if (value == "Revision") return aspose::words::cloud::models::TableProperties::StyleIdentifier::REVISION;
        if (value == "ListParagraph") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_PARAGRAPH;
        if (value == "Quote") return aspose::words::cloud::models::TableProperties::StyleIdentifier::QUOTE;
        if (value == "IntenseQuote") return aspose::words::cloud::models::TableProperties::StyleIdentifier::INTENSE_QUOTE;
        if (value == "MediumList2Accent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST2_ACCENT1;
        if (value == "MediumGrid1Accent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID1_ACCENT1;
        if (value == "MediumGrid2Accent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID2_ACCENT1;
        if (value == "MediumGrid3Accent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID3_ACCENT1;
        if (value == "DarkListAccent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::DARK_LIST_ACCENT1;
        if (value == "ColorfulShadingAccent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_SHADING_ACCENT1;
        if (value == "ColorfulListAccent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_LIST_ACCENT1;
        if (value == "ColorfulGridAccent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_GRID_ACCENT1;
        if (value == "LightShadingAccent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_SHADING_ACCENT2;
        if (value == "LightListAccent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_LIST_ACCENT2;
        if (value == "LightGridAccent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_GRID_ACCENT2;
        if (value == "MediumShading1Accent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING1_ACCENT2;
        if (value == "MediumShading2Accent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING2_ACCENT2;
        if (value == "MediumList1Accent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST1_ACCENT2;
        if (value == "MediumList2Accent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST2_ACCENT2;
        if (value == "MediumGrid1Accent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID1_ACCENT2;
        if (value == "MediumGrid2Accent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID2_ACCENT2;
        if (value == "MediumGrid3Accent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID3_ACCENT2;
        if (value == "DarkListAccent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::DARK_LIST_ACCENT2;
        if (value == "ColorfulShadingAccent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_SHADING_ACCENT2;
        if (value == "ColorfulListAccent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_LIST_ACCENT2;
        if (value == "ColorfulGridAccent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_GRID_ACCENT2;
        if (value == "LightShadingAccent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_SHADING_ACCENT3;
        if (value == "LightListAccent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_LIST_ACCENT3;
        if (value == "LightGridAccent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_GRID_ACCENT3;
        if (value == "MediumShading1Accent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING1_ACCENT3;
        if (value == "MediumShading2Accent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING2_ACCENT3;
        if (value == "MediumList1Accent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST1_ACCENT3;
        if (value == "MediumList2Accent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST2_ACCENT3;
        if (value == "MediumGrid1Accent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID1_ACCENT3;
        if (value == "MediumGrid2Accent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID2_ACCENT3;
        if (value == "MediumGrid3Accent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID3_ACCENT3;
        if (value == "DarkListAccent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::DARK_LIST_ACCENT3;
        if (value == "ColorfulShadingAccent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_SHADING_ACCENT3;
        if (value == "ColorfulListAccent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_LIST_ACCENT3;
        if (value == "ColorfulGridAccent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_GRID_ACCENT3;
        if (value == "LightShadingAccent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_SHADING_ACCENT4;
        if (value == "LightListAccent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_LIST_ACCENT4;
        if (value == "LightGridAccent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_GRID_ACCENT4;
        if (value == "MediumShading1Accent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING1_ACCENT4;
        if (value == "MediumShading2Accent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING2_ACCENT4;
        if (value == "MediumList1Accent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST1_ACCENT4;
        if (value == "MediumList2Accent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST2_ACCENT4;
        if (value == "MediumGrid1Accent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID1_ACCENT4;
        if (value == "MediumGrid2Accent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID2_ACCENT4;
        if (value == "MediumGrid3Accent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID3_ACCENT4;
        if (value == "DarkListAccent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::DARK_LIST_ACCENT4;
        if (value == "ColorfulShadingAccent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_SHADING_ACCENT4;
        if (value == "ColorfulListAccent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_LIST_ACCENT4;
        if (value == "ColorfulGridAccent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_GRID_ACCENT4;
        if (value == "LightShadingAccent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_SHADING_ACCENT5;
        if (value == "LightListAccent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_LIST_ACCENT5;
        if (value == "LightGridAccent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_GRID_ACCENT5;
        if (value == "MediumShading1Accent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING1_ACCENT5;
        if (value == "MediumShading2Accent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING2_ACCENT5;
        if (value == "MediumList1Accent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST1_ACCENT5;
        if (value == "MediumList2Accent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST2_ACCENT5;
        if (value == "MediumGrid1Accent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID1_ACCENT5;
        if (value == "MediumGrid2Accent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID2_ACCENT5;
        if (value == "MediumGrid3Accent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID3_ACCENT5;
        if (value == "DarkListAccent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::DARK_LIST_ACCENT5;
        if (value == "ColorfulShadingAccent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_SHADING_ACCENT5;
        if (value == "ColorfulListAccent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_LIST_ACCENT5;
        if (value == "ColorfulGridAccent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_GRID_ACCENT5;
        if (value == "LightShadingAccent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_SHADING_ACCENT6;
        if (value == "LightListAccent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_LIST_ACCENT6;
        if (value == "LightGridAccent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIGHT_GRID_ACCENT6;
        if (value == "MediumShading1Accent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING1_ACCENT6;
        if (value == "MediumShading2Accent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_SHADING2_ACCENT6;
        if (value == "MediumList1Accent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST1_ACCENT6;
        if (value == "MediumList2Accent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_LIST2_ACCENT6;
        if (value == "MediumGrid1Accent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID1_ACCENT6;
        if (value == "MediumGrid2Accent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID2_ACCENT6;
        if (value == "MediumGrid3Accent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MEDIUM_GRID3_ACCENT6;
        if (value == "DarkListAccent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::DARK_LIST_ACCENT6;
        if (value == "ColorfulShadingAccent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_SHADING_ACCENT6;
        if (value == "ColorfulListAccent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_LIST_ACCENT6;
        if (value == "ColorfulGridAccent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::COLORFUL_GRID_ACCENT6;
        if (value == "SubtleEmphasis") return aspose::words::cloud::models::TableProperties::StyleIdentifier::SUBTLE_EMPHASIS;
        if (value == "IntenseEmphasis") return aspose::words::cloud::models::TableProperties::StyleIdentifier::INTENSE_EMPHASIS;
        if (value == "SubtleReference") return aspose::words::cloud::models::TableProperties::StyleIdentifier::SUBTLE_REFERENCE;
        if (value == "IntenseReference") return aspose::words::cloud::models::TableProperties::StyleIdentifier::INTENSE_REFERENCE;
        if (value == "BookTitle") return aspose::words::cloud::models::TableProperties::StyleIdentifier::BOOK_TITLE;
        if (value == "Bibliography") return aspose::words::cloud::models::TableProperties::StyleIdentifier::BIBLIOGRAPHY;
        if (value == "TocHeading") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TOC_HEADING;
        if (value == "PlainTable1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::PLAIN_TABLE1;
        if (value == "PlainTable2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::PLAIN_TABLE2;
        if (value == "PlainTable3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::PLAIN_TABLE3;
        if (value == "PlainTable4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::PLAIN_TABLE4;
        if (value == "PlainTable5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::PLAIN_TABLE5;
        if (value == "TableGridLight") return aspose::words::cloud::models::TableProperties::StyleIdentifier::TABLE_GRID_LIGHT;
        if (value == "GridTable1Light") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE1_LIGHT;
        if (value == "GridTable2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE2;
        if (value == "GridTable3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE3;
        if (value == "GridTable4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE4;
        if (value == "GridTable5Dark") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE5_DARK;
        if (value == "GridTable6Colorful") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE6_COLORFUL;
        if (value == "GridTable7Colorful") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE7_COLORFUL;
        if (value == "GridTable1LightAccent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT1;
        if (value == "GridTable2Accent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE2_ACCENT1;
        if (value == "GridTable3Accent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE3_ACCENT1;
        if (value == "GridTable4Accent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE4_ACCENT1;
        if (value == "GridTable5DarkAccent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE5_DARK_ACCENT1;
        if (value == "GridTable6ColorfulAccent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT1;
        if (value == "GridTable7ColorfulAccent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT1;
        if (value == "GridTable1LightAccent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT2;
        if (value == "GridTable2Accent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE2_ACCENT2;
        if (value == "GridTable3Accent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE3_ACCENT2;
        if (value == "GridTable4Accent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE4_ACCENT2;
        if (value == "GridTable5DarkAccent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE5_DARK_ACCENT2;
        if (value == "GridTable6ColorfulAccent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT2;
        if (value == "GridTable7ColorfulAccent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT2;
        if (value == "GridTable1LightAccent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT3;
        if (value == "GridTable2Accent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE2_ACCENT3;
        if (value == "GridTable3Accent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE3_ACCENT3;
        if (value == "GridTable4Accent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE4_ACCENT3;
        if (value == "GridTable5DarkAccent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE5_DARK_ACCENT3;
        if (value == "GridTable6ColorfulAccent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT3;
        if (value == "GridTable7ColorfulAccent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT3;
        if (value == "GridTable1LightAccent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT4;
        if (value == "GridTable2Accent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE2_ACCENT4;
        if (value == "GridTable3Accent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE3_ACCENT4;
        if (value == "GridTable4Accent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE4_ACCENT4;
        if (value == "GridTable5DarkAccent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE5_DARK_ACCENT4;
        if (value == "GridTable6ColorfulAccent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT4;
        if (value == "GridTable7ColorfulAccent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT4;
        if (value == "GridTable1LightAccent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT5;
        if (value == "GridTable2Accent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE2_ACCENT5;
        if (value == "GridTable3Accent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE3_ACCENT5;
        if (value == "GridTable4Accent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE4_ACCENT5;
        if (value == "GridTable5DarkAccent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE5_DARK_ACCENT5;
        if (value == "GridTable6ColorfulAccent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT5;
        if (value == "GridTable7ColorfulAccent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT5;
        if (value == "GridTable1LightAccent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE1_LIGHT_ACCENT6;
        if (value == "GridTable2Accent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE2_ACCENT6;
        if (value == "GridTable3Accent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE3_ACCENT6;
        if (value == "GridTable4Accent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE4_ACCENT6;
        if (value == "GridTable5DarkAccent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE5_DARK_ACCENT6;
        if (value == "GridTable6ColorfulAccent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE6_COLORFUL_ACCENT6;
        if (value == "GridTable7ColorfulAccent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::GRID_TABLE7_COLORFUL_ACCENT6;
        if (value == "ListTable1Light") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE1_LIGHT;
        if (value == "ListTable2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE2;
        if (value == "ListTable3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE3;
        if (value == "ListTable4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE4;
        if (value == "ListTable5Dark") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE5_DARK;
        if (value == "ListTable6Colorful") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE6_COLORFUL;
        if (value == "ListTable7Colorful") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE7_COLORFUL;
        if (value == "ListTable1LightAccent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT1;
        if (value == "ListTable2Accent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE2_ACCENT1;
        if (value == "ListTable3Accent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE3_ACCENT1;
        if (value == "ListTable4Accent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE4_ACCENT1;
        if (value == "ListTable5DarkAccent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE5_DARK_ACCENT1;
        if (value == "ListTable6ColorfulAccent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT1;
        if (value == "ListTable7ColorfulAccent1") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT1;
        if (value == "ListTable1LightAccent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT2;
        if (value == "ListTable2Accent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE2_ACCENT2;
        if (value == "ListTable3Accent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE3_ACCENT2;
        if (value == "ListTable4Accent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE4_ACCENT2;
        if (value == "ListTable5DarkAccent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE5_DARK_ACCENT2;
        if (value == "ListTable6ColorfulAccent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT2;
        if (value == "ListTable7ColorfulAccent2") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT2;
        if (value == "ListTable1LightAccent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT3;
        if (value == "ListTable2Accent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE2_ACCENT3;
        if (value == "ListTable3Accent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE3_ACCENT3;
        if (value == "ListTable4Accent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE4_ACCENT3;
        if (value == "ListTable5DarkAccent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE5_DARK_ACCENT3;
        if (value == "ListTable6ColorfulAccent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT3;
        if (value == "ListTable7ColorfulAccent3") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT3;
        if (value == "ListTable1LightAccent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT4;
        if (value == "ListTable2Accent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE2_ACCENT4;
        if (value == "ListTable3Accent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE3_ACCENT4;
        if (value == "ListTable4Accent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE4_ACCENT4;
        if (value == "ListTable5DarkAccent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE5_DARK_ACCENT4;
        if (value == "ListTable6ColorfulAccent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT4;
        if (value == "ListTable7ColorfulAccent4") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT4;
        if (value == "ListTable1LightAccent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT5;
        if (value == "ListTable2Accent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE2_ACCENT5;
        if (value == "ListTable3Accent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE3_ACCENT5;
        if (value == "ListTable4Accent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE4_ACCENT5;
        if (value == "ListTable5DarkAccent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE5_DARK_ACCENT5;
        if (value == "ListTable6ColorfulAccent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT5;
        if (value == "ListTable7ColorfulAccent5") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT5;
        if (value == "ListTable1LightAccent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE1_LIGHT_ACCENT6;
        if (value == "ListTable2Accent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE2_ACCENT6;
        if (value == "ListTable3Accent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE3_ACCENT6;
        if (value == "ListTable4Accent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE4_ACCENT6;
        if (value == "ListTable5DarkAccent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE5_DARK_ACCENT6;
        if (value == "ListTable6ColorfulAccent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE6_COLORFUL_ACCENT6;
        if (value == "ListTable7ColorfulAccent6") return aspose::words::cloud::models::TableProperties::StyleIdentifier::LIST_TABLE7_COLORFUL_ACCENT6;
        if (value == "SmartLink") return aspose::words::cloud::models::TableProperties::StyleIdentifier::SMART_LINK;
        if (value == "Mention") return aspose::words::cloud::models::TableProperties::StyleIdentifier::MENTION;
        if (value == "SmartHyperlink") return aspose::words::cloud::models::TableProperties::StyleIdentifier::SMART_HYPERLINK;
        if (value == "Hashtag") return aspose::words::cloud::models::TableProperties::StyleIdentifier::HASHTAG;
        if (value == "UnresolvedMention") return aspose::words::cloud::models::TableProperties::StyleIdentifier::UNRESOLVED_MENTION;
        if (value == "User") return aspose::words::cloud::models::TableProperties::StyleIdentifier::USER;
        if (value == "Nil") return aspose::words::cloud::models::TableProperties::StyleIdentifier::NIL;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string tablePropertiesStyleOptionsToString(aspose::words::cloud::models::TableProperties::StyleOptions value)
    {
        if (value == aspose::words::cloud::models::TableProperties::StyleOptions::NONE) return "None";
        if (value == aspose::words::cloud::models::TableProperties::StyleOptions::FIRST_ROW) return "FirstRow";
        if (value == aspose::words::cloud::models::TableProperties::StyleOptions::LAST_ROW) return "LastRow";
        if (value == aspose::words::cloud::models::TableProperties::StyleOptions::FIRST_COLUMN) return "FirstColumn";
        if (value == aspose::words::cloud::models::TableProperties::StyleOptions::LAST_COLUMN) return "LastColumn";
        if (value == aspose::words::cloud::models::TableProperties::StyleOptions::ROW_BANDS) return "RowBands";
        if (value == aspose::words::cloud::models::TableProperties::StyleOptions::DEFAULT) return "Default";
        if (value == aspose::words::cloud::models::TableProperties::StyleOptions::COLUMN_BANDS) return "ColumnBands";
        if (value == aspose::words::cloud::models::TableProperties::StyleOptions::DEFAULT2003) return "Default2003";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::TableProperties::StyleOptions tablePropertiesStyleOptionsFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::TableProperties::StyleOptions::NONE;
        if (value == "FirstRow") return aspose::words::cloud::models::TableProperties::StyleOptions::FIRST_ROW;
        if (value == "LastRow") return aspose::words::cloud::models::TableProperties::StyleOptions::LAST_ROW;
        if (value == "FirstColumn") return aspose::words::cloud::models::TableProperties::StyleOptions::FIRST_COLUMN;
        if (value == "LastColumn") return aspose::words::cloud::models::TableProperties::StyleOptions::LAST_COLUMN;
        if (value == "RowBands") return aspose::words::cloud::models::TableProperties::StyleOptions::ROW_BANDS;
        if (value == "Default") return aspose::words::cloud::models::TableProperties::StyleOptions::DEFAULT;
        if (value == "ColumnBands") return aspose::words::cloud::models::TableProperties::StyleOptions::COLUMN_BANDS;
        if (value == "Default2003") return aspose::words::cloud::models::TableProperties::StyleOptions::DEFAULT2003;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string tablePropertiesTextWrappingToString(aspose::words::cloud::models::TableProperties::TextWrapping value)
    {
        if (value == aspose::words::cloud::models::TableProperties::TextWrapping::NONE) return "None";
        if (value == aspose::words::cloud::models::TableProperties::TextWrapping::DEFAULT) return "Default";
        if (value == aspose::words::cloud::models::TableProperties::TextWrapping::AROUND) return "Around";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::TableProperties::TextWrapping tablePropertiesTextWrappingFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::TableProperties::TextWrapping::NONE;
        if (value == "Default") return aspose::words::cloud::models::TableProperties::TextWrapping::DEFAULT;
        if (value == "Around") return aspose::words::cloud::models::TableProperties::TextWrapping::AROUND;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void TableProperties::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Alignment) {
            json["Alignment"] = tablePropertiesAlignmentToString(*(this->m_Alignment));
        }
        if (this->m_AllowAutoFit) {
            json["AllowAutoFit"] = *(this->m_AllowAutoFit);
        }
        if (this->m_Bidi) {
            json["Bidi"] = *(this->m_Bidi);
        }
        if (this->m_BottomPadding) {
            json["BottomPadding"] = *(this->m_BottomPadding);
        }
        if (this->m_CellSpacing) {
            json["CellSpacing"] = *(this->m_CellSpacing);
        }
        if (this->m_LeftIndent) {
            json["LeftIndent"] = *(this->m_LeftIndent);
        }
        if (this->m_LeftPadding) {
            json["LeftPadding"] = *(this->m_LeftPadding);
        }
        if (this->m_PreferredWidth) {
            this->m_PreferredWidth->toJson(&json["PreferredWidth"]);
        }
        if (this->m_RightPadding) {
            json["RightPadding"] = *(this->m_RightPadding);
        }
        if (this->m_StyleIdentifier) {
            json["StyleIdentifier"] = tablePropertiesStyleIdentifierToString(*(this->m_StyleIdentifier));
        }
        if (this->m_StyleName) {
            json["StyleName"] = convertUtf16(*(this->m_StyleName));
        }
        if (this->m_StyleOptions) {
            json["StyleOptions"] = tablePropertiesStyleOptionsToString(*(this->m_StyleOptions));
        }
        if (this->m_TextWrapping) {
            json["TextWrapping"] = tablePropertiesTextWrappingToString(*(this->m_TextWrapping));
        }
        if (this->m_TopPadding) {
            json["TopPadding"] = *(this->m_TopPadding);
        }
    }

    void TableProperties::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Alignment") && !json["Alignment"].is_null()) {
            this->m_Alignment = std::make_shared< aspose::words::cloud::models::TableProperties::Alignment >(
                tablePropertiesAlignmentFromString(json["Alignment"].get< std::string >())
            );
        }
        if (json.contains("AllowAutoFit") && !json["AllowAutoFit"].is_null()) {
            this->m_AllowAutoFit = std::make_shared< bool >(
                json["AllowAutoFit"].get< bool >()
            );
        }
        if (json.contains("Bidi") && !json["Bidi"].is_null()) {
            this->m_Bidi = std::make_shared< bool >(
                json["Bidi"].get< bool >()
            );
        }
        if (json.contains("BottomPadding") && !json["BottomPadding"].is_null()) {
            this->m_BottomPadding = std::make_shared< double >(
                json["BottomPadding"].get< double >()
            );
        }
        if (json.contains("CellSpacing") && !json["CellSpacing"].is_null()) {
            this->m_CellSpacing = std::make_shared< double >(
                json["CellSpacing"].get< double >()
            );
        }
        if (json.contains("LeftIndent") && !json["LeftIndent"].is_null()) {
            this->m_LeftIndent = std::make_shared< double >(
                json["LeftIndent"].get< double >()
            );
        }
        if (json.contains("LeftPadding") && !json["LeftPadding"].is_null()) {
            this->m_LeftPadding = std::make_shared< double >(
                json["LeftPadding"].get< double >()
            );
        }
        if (json.contains("PreferredWidth") && !json["PreferredWidth"].is_null()) {
            this->m_PreferredWidth = createModelInstance< aspose::words::cloud::models::PreferredWidth >(L"PreferredWidth, _", json["PreferredWidth"]);
        }
        if (json.contains("RightPadding") && !json["RightPadding"].is_null()) {
            this->m_RightPadding = std::make_shared< double >(
                json["RightPadding"].get< double >()
            );
        }
        if (json.contains("StyleIdentifier") && !json["StyleIdentifier"].is_null()) {
            this->m_StyleIdentifier = std::make_shared< aspose::words::cloud::models::TableProperties::StyleIdentifier >(
                tablePropertiesStyleIdentifierFromString(json["StyleIdentifier"].get< std::string >())
            );
        }
        if (json.contains("StyleName") && !json["StyleName"].is_null()) {
            this->m_StyleName = std::make_shared< std::wstring >(
                convertUtf8( json["StyleName"].get< std::string >() )
            );
        }
        if (json.contains("StyleOptions") && !json["StyleOptions"].is_null()) {
            this->m_StyleOptions = std::make_shared< aspose::words::cloud::models::TableProperties::StyleOptions >(
                tablePropertiesStyleOptionsFromString(json["StyleOptions"].get< std::string >())
            );
        }
        if (json.contains("TextWrapping") && !json["TextWrapping"].is_null()) {
            this->m_TextWrapping = std::make_shared< aspose::words::cloud::models::TableProperties::TextWrapping >(
                tablePropertiesTextWrappingFromString(json["TextWrapping"].get< std::string >())
            );
        }
        if (json.contains("TopPadding") && !json["TopPadding"].is_null()) {
            this->m_TopPadding = std::make_shared< double >(
                json["TopPadding"].get< double >()
            );
        }
    }

    void TableProperties::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TableProperties::validate()
    {
        LinkElement::validate();

        if (this->m_PreferredWidth != nullptr)
        {
            this->m_PreferredWidth->validate();
        }







    }

    std::shared_ptr< aspose::words::cloud::models::TableProperties::Alignment > TableProperties::getAlignment() const
    {
        return this->m_Alignment;
    }

    void TableProperties::setAlignment(std::shared_ptr< aspose::words::cloud::models::TableProperties::Alignment > value)
    {
        this->m_Alignment = value;
    }


    std::shared_ptr< bool > TableProperties::getAllowAutoFit() const
    {
        return this->m_AllowAutoFit;
    }

    void TableProperties::setAllowAutoFit(std::shared_ptr< bool > value)
    {
        this->m_AllowAutoFit = value;
    }


    std::shared_ptr< bool > TableProperties::getBidi() const
    {
        return this->m_Bidi;
    }

    void TableProperties::setBidi(std::shared_ptr< bool > value)
    {
        this->m_Bidi = value;
    }


    std::shared_ptr< double > TableProperties::getBottomPadding() const
    {
        return this->m_BottomPadding;
    }

    void TableProperties::setBottomPadding(std::shared_ptr< double > value)
    {
        this->m_BottomPadding = value;
    }


    std::shared_ptr< double > TableProperties::getCellSpacing() const
    {
        return this->m_CellSpacing;
    }

    void TableProperties::setCellSpacing(std::shared_ptr< double > value)
    {
        this->m_CellSpacing = value;
    }


    std::shared_ptr< double > TableProperties::getLeftIndent() const
    {
        return this->m_LeftIndent;
    }

    void TableProperties::setLeftIndent(std::shared_ptr< double > value)
    {
        this->m_LeftIndent = value;
    }


    std::shared_ptr< double > TableProperties::getLeftPadding() const
    {
        return this->m_LeftPadding;
    }

    void TableProperties::setLeftPadding(std::shared_ptr< double > value)
    {
        this->m_LeftPadding = value;
    }


    std::shared_ptr< aspose::words::cloud::models::PreferredWidth > TableProperties::getPreferredWidth() const
    {
        return this->m_PreferredWidth;
    }

    void TableProperties::setPreferredWidth(std::shared_ptr< aspose::words::cloud::models::PreferredWidth > value)
    {
        this->m_PreferredWidth = value;
    }


    std::shared_ptr< double > TableProperties::getRightPadding() const
    {
        return this->m_RightPadding;
    }

    void TableProperties::setRightPadding(std::shared_ptr< double > value)
    {
        this->m_RightPadding = value;
    }


    std::shared_ptr< aspose::words::cloud::models::TableProperties::StyleIdentifier > TableProperties::getStyleIdentifier() const
    {
        return this->m_StyleIdentifier;
    }

    void TableProperties::setStyleIdentifier(std::shared_ptr< aspose::words::cloud::models::TableProperties::StyleIdentifier > value)
    {
        this->m_StyleIdentifier = value;
    }


    std::shared_ptr< std::wstring > TableProperties::getStyleName() const
    {
        return this->m_StyleName;
    }

    void TableProperties::setStyleName(std::shared_ptr< std::wstring > value)
    {
        this->m_StyleName = value;
    }


    std::shared_ptr< aspose::words::cloud::models::TableProperties::StyleOptions > TableProperties::getStyleOptions() const
    {
        return this->m_StyleOptions;
    }

    void TableProperties::setStyleOptions(std::shared_ptr< aspose::words::cloud::models::TableProperties::StyleOptions > value)
    {
        this->m_StyleOptions = value;
    }


    std::shared_ptr< aspose::words::cloud::models::TableProperties::TextWrapping > TableProperties::getTextWrapping() const
    {
        return this->m_TextWrapping;
    }

    void TableProperties::setTextWrapping(std::shared_ptr< aspose::words::cloud::models::TableProperties::TextWrapping > value)
    {
        this->m_TextWrapping = value;
    }


    std::shared_ptr< double > TableProperties::getTopPadding() const
    {
        return this->m_TopPadding;
    }

    void TableProperties::setTopPadding(std::shared_ptr< double > value)
    {
        this->m_TopPadding = value;
    }



    /*
     * TablePropertiesResponse implementation
     */
    void TablePropertiesResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Properties) {
            this->m_Properties->toJson(&json["Properties"]);
        }
    }

    void TablePropertiesResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Properties") && !json["Properties"].is_null()) {
            this->m_Properties = createModelInstance< aspose::words::cloud::models::TableProperties >(L"TableProperties, _", json["Properties"]);
        }
    }

    void TablePropertiesResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TablePropertiesResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Properties != nullptr)
        {
            this->m_Properties->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::TableProperties > TablePropertiesResponse::getProperties() const
    {
        return this->m_Properties;
    }

    void TablePropertiesResponse::setProperties(std::shared_ptr< aspose::words::cloud::models::TableProperties > value)
    {
        this->m_Properties = value;
    }



    /*
     * TableResponse implementation
     */
    void TableResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Table) {
            this->m_Table->toJson(&json["Table"]);
        }
    }

    void TableResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Table") && !json["Table"].is_null()) {
            this->m_Table = createModelInstance< aspose::words::cloud::models::Table >(L"Table, _", json["Table"]);
        }
    }

    void TableResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TableResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Table != nullptr)
        {
            this->m_Table->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::Table > TableResponse::getTable() const
    {
        return this->m_Table;
    }

    void TableResponse::setTable(std::shared_ptr< aspose::words::cloud::models::Table > value)
    {
        this->m_Table = value;
    }



    /*
     * TableRow implementation
     */
    void TableRow::toJson(void* jsonIfc) const
    {
        NodeLink::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_TableCellList) {
            json["TableCellList"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_TableCellList)) {
                element->toJson(&json["TableCellList"].emplace_back());
            }
        }
        if (this->m_RowFormat) {
            this->m_RowFormat->toJson(&json["RowFormat"]);
        }
    }

    void TableRow::fromJson(const void* jsonIfc)
    {
        NodeLink::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("TableCellList") && !json["TableCellList"].is_null()) {
            this->m_TableCellList = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::TableCell>> >();
            for (auto& element : json["TableCellList"]) {
                this->m_TableCellList->emplace_back(createModelInstance< aspose::words::cloud::models::TableCell >(L"TableCell, _", element));
            }
        }
        if (json.contains("RowFormat") && !json["RowFormat"].is_null()) {
            this->m_RowFormat = createModelInstance< aspose::words::cloud::models::TableRowFormat >(L"TableRowFormat, _", json["RowFormat"]);
        }
    }

    void TableRow::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TableRow::validate()
    {
        NodeLink::validate();

        if (this->m_TableCellList != nullptr)
        {
            for (auto& elementTableCellList : *(this->m_TableCellList))
            {
                if (elementTableCellList != nullptr)
                {
                    elementTableCellList->validate();
                }
            }
        }



        if (this->m_RowFormat != nullptr)
        {
            this->m_RowFormat->validate();
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::TableCell>> > TableRow::getTableCellList() const
    {
        return this->m_TableCellList;
    }

    void TableRow::setTableCellList(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::TableCell>> > value)
    {
        this->m_TableCellList = value;
    }


    std::shared_ptr< aspose::words::cloud::models::TableRowFormat > TableRow::getRowFormat() const
    {
        return this->m_RowFormat;
    }

    void TableRow::setRowFormat(std::shared_ptr< aspose::words::cloud::models::TableRowFormat > value)
    {
        this->m_RowFormat = value;
    }



    /*
     * TableRowFormat implementation
     */
    inline std::string tableRowFormatHeightRuleToString(aspose::words::cloud::models::TableRowFormat::HeightRule value)
    {
        if (value == aspose::words::cloud::models::TableRowFormat::HeightRule::AT_LEAST) return "AtLeast";
        if (value == aspose::words::cloud::models::TableRowFormat::HeightRule::EXACTLY) return "Exactly";
        if (value == aspose::words::cloud::models::TableRowFormat::HeightRule::AUTO) return "Auto";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::TableRowFormat::HeightRule tableRowFormatHeightRuleFromString(const std::string& value)
    {
        if (value == "AtLeast") return aspose::words::cloud::models::TableRowFormat::HeightRule::AT_LEAST;
        if (value == "Exactly") return aspose::words::cloud::models::TableRowFormat::HeightRule::EXACTLY;
        if (value == "Auto") return aspose::words::cloud::models::TableRowFormat::HeightRule::AUTO;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void TableRowFormat::toJson(void* jsonIfc) const
    {
        LinkElement::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Height) {
            json["Height"] = *(this->m_Height);
        }
        if (this->m_HeightRule) {
            json["HeightRule"] = tableRowFormatHeightRuleToString(*(this->m_HeightRule));
        }
        if (this->m_AllowBreakAcrossPages) {
            json["AllowBreakAcrossPages"] = *(this->m_AllowBreakAcrossPages);
        }
        if (this->m_HeadingFormat) {
            json["HeadingFormat"] = *(this->m_HeadingFormat);
        }
    }

    void TableRowFormat::fromJson(const void* jsonIfc)
    {
        LinkElement::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Height") && !json["Height"].is_null()) {
            this->m_Height = std::make_shared< double >(
                json["Height"].get< double >()
            );
        }
        if (json.contains("HeightRule") && !json["HeightRule"].is_null()) {
            this->m_HeightRule = std::make_shared< aspose::words::cloud::models::TableRowFormat::HeightRule >(
                tableRowFormatHeightRuleFromString(json["HeightRule"].get< std::string >())
            );
        }
        if (json.contains("AllowBreakAcrossPages") && !json["AllowBreakAcrossPages"].is_null()) {
            this->m_AllowBreakAcrossPages = std::make_shared< bool >(
                json["AllowBreakAcrossPages"].get< bool >()
            );
        }
        if (json.contains("HeadingFormat") && !json["HeadingFormat"].is_null()) {
            this->m_HeadingFormat = std::make_shared< bool >(
                json["HeadingFormat"].get< bool >()
            );
        }
    }

    void TableRowFormat::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TableRowFormat::validate()
    {
        LinkElement::validate();
    }

    std::shared_ptr< double > TableRowFormat::getHeight() const
    {
        return this->m_Height;
    }

    void TableRowFormat::setHeight(std::shared_ptr< double > value)
    {
        this->m_Height = value;
    }


    std::shared_ptr< aspose::words::cloud::models::TableRowFormat::HeightRule > TableRowFormat::getHeightRule() const
    {
        return this->m_HeightRule;
    }

    void TableRowFormat::setHeightRule(std::shared_ptr< aspose::words::cloud::models::TableRowFormat::HeightRule > value)
    {
        this->m_HeightRule = value;
    }


    std::shared_ptr< bool > TableRowFormat::getAllowBreakAcrossPages() const
    {
        return this->m_AllowBreakAcrossPages;
    }

    void TableRowFormat::setAllowBreakAcrossPages(std::shared_ptr< bool > value)
    {
        this->m_AllowBreakAcrossPages = value;
    }


    std::shared_ptr< bool > TableRowFormat::getHeadingFormat() const
    {
        return this->m_HeadingFormat;
    }

    void TableRowFormat::setHeadingFormat(std::shared_ptr< bool > value)
    {
        this->m_HeadingFormat = value;
    }



    /*
     * TableRowFormatResponse implementation
     */
    void TableRowFormatResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_RowFormat) {
            this->m_RowFormat->toJson(&json["RowFormat"]);
        }
    }

    void TableRowFormatResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("RowFormat") && !json["RowFormat"].is_null()) {
            this->m_RowFormat = createModelInstance< aspose::words::cloud::models::TableRowFormat >(L"TableRowFormat, _", json["RowFormat"]);
        }
    }

    void TableRowFormatResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TableRowFormatResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_RowFormat != nullptr)
        {
            this->m_RowFormat->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::TableRowFormat > TableRowFormatResponse::getRowFormat() const
    {
        return this->m_RowFormat;
    }

    void TableRowFormatResponse::setRowFormat(std::shared_ptr< aspose::words::cloud::models::TableRowFormat > value)
    {
        this->m_RowFormat = value;
    }



    /*
     * TableRowInsert implementation
     */
    void TableRowInsert::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ColumnsCount) {
            json["ColumnsCount"] = *(this->m_ColumnsCount);
        }
        if (this->m_ExistingRowPosition) {
            this->m_ExistingRowPosition->toJson(&json["ExistingRowPosition"]);
        }
        if (this->m_InsertAfter) {
            json["InsertAfter"] = *(this->m_InsertAfter);
        }
    }

    void TableRowInsert::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ColumnsCount") && !json["ColumnsCount"].is_null()) {
            this->m_ColumnsCount = std::make_shared< int32_t >(
                json["ColumnsCount"].get< int32_t >()
            );
        }
        if (json.contains("ExistingRowPosition") && !json["ExistingRowPosition"].is_null()) {
            this->m_ExistingRowPosition = createModelInstance< aspose::words::cloud::models::Position >(L"Position, _", json["ExistingRowPosition"]);
        }
        if (json.contains("InsertAfter") && !json["InsertAfter"].is_null()) {
            this->m_InsertAfter = std::make_shared< int32_t >(
                json["InsertAfter"].get< int32_t >()
            );
        }
    }

    void TableRowInsert::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TableRowInsert::validate()
    {
        if (this->m_ColumnsCount == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property ColumnsCount in TableRowInsert is required.");
        }


        if (this->m_ExistingRowPosition != nullptr)
        {
            this->m_ExistingRowPosition->validate();
        }


    }

    std::shared_ptr< int32_t > TableRowInsert::getColumnsCount() const
    {
        return this->m_ColumnsCount;
    }

    void TableRowInsert::setColumnsCount(std::shared_ptr< int32_t > value)
    {
        this->m_ColumnsCount = value;
    }


    std::shared_ptr< aspose::words::cloud::models::Position > TableRowInsert::getExistingRowPosition() const
    {
        return this->m_ExistingRowPosition;
    }

    void TableRowInsert::setExistingRowPosition(std::shared_ptr< aspose::words::cloud::models::Position > value)
    {
        this->m_ExistingRowPosition = value;
    }


    std::shared_ptr< int32_t > TableRowInsert::getInsertAfter() const
    {
        return this->m_InsertAfter;
    }

    void TableRowInsert::setInsertAfter(std::shared_ptr< int32_t > value)
    {
        this->m_InsertAfter = value;
    }



    /*
     * TableRowResponse implementation
     */
    void TableRowResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Row) {
            this->m_Row->toJson(&json["Row"]);
        }
    }

    void TableRowResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Row") && !json["Row"].is_null()) {
            this->m_Row = createModelInstance< aspose::words::cloud::models::TableRow >(L"TableRow, _", json["Row"]);
        }
    }

    void TableRowResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TableRowResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Row != nullptr)
        {
            this->m_Row->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::TableRow > TableRowResponse::getRow() const
    {
        return this->m_Row;
    }

    void TableRowResponse::setRow(std::shared_ptr< aspose::words::cloud::models::TableRow > value)
    {
        this->m_Row = value;
    }



    /*
     * TabStop implementation
     */
    void TabStop::toJson(void* jsonIfc) const
    {
        TabStopBase::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_IsClear) {
            json["IsClear"] = *(this->m_IsClear);
        }
    }

    void TabStop::fromJson(const void* jsonIfc)
    {
        TabStopBase::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("IsClear") && !json["IsClear"].is_null()) {
            this->m_IsClear = std::make_shared< bool >(
                json["IsClear"].get< bool >()
            );
        }
    }

    void TabStop::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TabStop::validate()
    {
        TabStopBase::validate();
        if (this->m_IsClear == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property IsClear in TabStop is required.");
        }

    }

    std::shared_ptr< bool > TabStop::getIsClear() const
    {
        return this->m_IsClear;
    }

    void TabStop::setIsClear(std::shared_ptr< bool > value)
    {
        this->m_IsClear = value;
    }



    /*
     * TabStopBase implementation
     */
    inline std::string tabStopBaseAlignmentToString(aspose::words::cloud::models::TabStopBase::Alignment value)
    {
        if (value == aspose::words::cloud::models::TabStopBase::Alignment::LEFT) return "Left";
        if (value == aspose::words::cloud::models::TabStopBase::Alignment::CENTER) return "Center";
        if (value == aspose::words::cloud::models::TabStopBase::Alignment::RIGHT) return "Right";
        if (value == aspose::words::cloud::models::TabStopBase::Alignment::DECIMAL) return "Decimal";
        if (value == aspose::words::cloud::models::TabStopBase::Alignment::BAR) return "Bar";
        if (value == aspose::words::cloud::models::TabStopBase::Alignment::LIST) return "List";
        if (value == aspose::words::cloud::models::TabStopBase::Alignment::CLEAR) return "Clear";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::TabStopBase::Alignment tabStopBaseAlignmentFromString(const std::string& value)
    {
        if (value == "Left") return aspose::words::cloud::models::TabStopBase::Alignment::LEFT;
        if (value == "Center") return aspose::words::cloud::models::TabStopBase::Alignment::CENTER;
        if (value == "Right") return aspose::words::cloud::models::TabStopBase::Alignment::RIGHT;
        if (value == "Decimal") return aspose::words::cloud::models::TabStopBase::Alignment::DECIMAL;
        if (value == "Bar") return aspose::words::cloud::models::TabStopBase::Alignment::BAR;
        if (value == "List") return aspose::words::cloud::models::TabStopBase::Alignment::LIST;
        if (value == "Clear") return aspose::words::cloud::models::TabStopBase::Alignment::CLEAR;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string tabStopBaseLeaderToString(aspose::words::cloud::models::TabStopBase::Leader value)
    {
        if (value == aspose::words::cloud::models::TabStopBase::Leader::NONE) return "None";
        if (value == aspose::words::cloud::models::TabStopBase::Leader::DOTS) return "Dots";
        if (value == aspose::words::cloud::models::TabStopBase::Leader::DASHES) return "Dashes";
        if (value == aspose::words::cloud::models::TabStopBase::Leader::LINE) return "Line";
        if (value == aspose::words::cloud::models::TabStopBase::Leader::HEAVY) return "Heavy";
        if (value == aspose::words::cloud::models::TabStopBase::Leader::MIDDLE_DOT) return "MiddleDot";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::TabStopBase::Leader tabStopBaseLeaderFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::TabStopBase::Leader::NONE;
        if (value == "Dots") return aspose::words::cloud::models::TabStopBase::Leader::DOTS;
        if (value == "Dashes") return aspose::words::cloud::models::TabStopBase::Leader::DASHES;
        if (value == "Line") return aspose::words::cloud::models::TabStopBase::Leader::LINE;
        if (value == "Heavy") return aspose::words::cloud::models::TabStopBase::Leader::HEAVY;
        if (value == "MiddleDot") return aspose::words::cloud::models::TabStopBase::Leader::MIDDLE_DOT;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void TabStopBase::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Alignment) {
            json["Alignment"] = tabStopBaseAlignmentToString(*(this->m_Alignment));
        }
        if (this->m_Leader) {
            json["Leader"] = tabStopBaseLeaderToString(*(this->m_Leader));
        }
        if (this->m_Position) {
            json["Position"] = *(this->m_Position);
        }
    }

    void TabStopBase::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Alignment") && !json["Alignment"].is_null()) {
            this->m_Alignment = std::make_shared< aspose::words::cloud::models::TabStopBase::Alignment >(
                tabStopBaseAlignmentFromString(json["Alignment"].get< std::string >())
            );
        }
        if (json.contains("Leader") && !json["Leader"].is_null()) {
            this->m_Leader = std::make_shared< aspose::words::cloud::models::TabStopBase::Leader >(
                tabStopBaseLeaderFromString(json["Leader"].get< std::string >())
            );
        }
        if (json.contains("Position") && !json["Position"].is_null()) {
            this->m_Position = std::make_shared< double >(
                json["Position"].get< double >()
            );
        }
    }

    void TabStopBase::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TabStopBase::validate()
    {
        if (this->m_Alignment == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Alignment in TabStopBase is required.");
        }

        if (this->m_Leader == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Leader in TabStopBase is required.");
        }

        if (this->m_Position == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Position in TabStopBase is required.");
        }

    }

    std::shared_ptr< aspose::words::cloud::models::TabStopBase::Alignment > TabStopBase::getAlignment() const
    {
        return this->m_Alignment;
    }

    void TabStopBase::setAlignment(std::shared_ptr< aspose::words::cloud::models::TabStopBase::Alignment > value)
    {
        this->m_Alignment = value;
    }


    std::shared_ptr< aspose::words::cloud::models::TabStopBase::Leader > TabStopBase::getLeader() const
    {
        return this->m_Leader;
    }

    void TabStopBase::setLeader(std::shared_ptr< aspose::words::cloud::models::TabStopBase::Leader > value)
    {
        this->m_Leader = value;
    }


    std::shared_ptr< double > TabStopBase::getPosition() const
    {
        return this->m_Position;
    }

    void TabStopBase::setPosition(std::shared_ptr< double > value)
    {
        this->m_Position = value;
    }



    /*
     * TabStopInsert implementation
     */
    void TabStopInsert::toJson(void* jsonIfc) const
    {
        TabStopBase::toJson(jsonIfc);
    }

    void TabStopInsert::fromJson(const void* jsonIfc)
    {
        TabStopBase::fromJson(jsonIfc);
    }

    void TabStopInsert::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TabStopInsert::validate()
    {
        TabStopBase::validate();
    }




    /*
     * TabStopsResponse implementation
     */
    void TabStopsResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_TabStops) {
            json["TabStops"] = ::nlohmann::json::array();
            for (auto& element : *(this->m_TabStops)) {
                element->toJson(&json["TabStops"].emplace_back());
            }
        }
    }

    void TabStopsResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("TabStops") && !json["TabStops"].is_null()) {
            this->m_TabStops = std::make_shared< std::vector<std::shared_ptr<aspose::words::cloud::models::TabStop>> >();
            for (auto& element : json["TabStops"]) {
                this->m_TabStops->emplace_back(createModelInstance< aspose::words::cloud::models::TabStop >(L"TabStop, _", element));
            }
        }
    }

    void TabStopsResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TabStopsResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_TabStops != nullptr)
        {
            for (auto& elementTabStops : *(this->m_TabStops))
            {
                if (elementTabStops != nullptr)
                {
                    elementTabStops->validate();
                }
            }
        }

    }

    std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::TabStop>> > TabStopsResponse::getTabStops() const
    {
        return this->m_TabStops;
    }

    void TabStopsResponse::setTabStops(std::shared_ptr< std::vector<std::shared_ptr<aspose::words::cloud::models::TabStop>> > value)
    {
        this->m_TabStops = value;
    }



    /*
     * TextSaveOptionsData implementation
     */
    void TextSaveOptionsData::toJson(void* jsonIfc) const
    {
        TxtSaveOptionsBaseData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_AddBidiMarks) {
            json["AddBidiMarks"] = *(this->m_AddBidiMarks);
        }
        if (this->m_MaxCharactersPerLine) {
            json["MaxCharactersPerLine"] = *(this->m_MaxCharactersPerLine);
        }
        if (this->m_PreserveTableLayout) {
            json["PreserveTableLayout"] = *(this->m_PreserveTableLayout);
        }
        if (this->m_SimplifyListLabels) {
            json["SimplifyListLabels"] = *(this->m_SimplifyListLabels);
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void TextSaveOptionsData::fromJson(const void* jsonIfc)
    {
        TxtSaveOptionsBaseData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("AddBidiMarks") && !json["AddBidiMarks"].is_null()) {
            this->m_AddBidiMarks = std::make_shared< bool >(
                json["AddBidiMarks"].get< bool >()
            );
        }
        if (json.contains("MaxCharactersPerLine") && !json["MaxCharactersPerLine"].is_null()) {
            this->m_MaxCharactersPerLine = std::make_shared< int32_t >(
                json["MaxCharactersPerLine"].get< int32_t >()
            );
        }
        if (json.contains("PreserveTableLayout") && !json["PreserveTableLayout"].is_null()) {
            this->m_PreserveTableLayout = std::make_shared< bool >(
                json["PreserveTableLayout"].get< bool >()
            );
        }
        if (json.contains("SimplifyListLabels") && !json["SimplifyListLabels"].is_null()) {
            this->m_SimplifyListLabels = std::make_shared< bool >(
                json["SimplifyListLabels"].get< bool >()
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void TextSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TextSaveOptionsData::validate()
    {
        TxtSaveOptionsBaseData::validate();
        if (this->m_MaxCharactersPerLine == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property MaxCharactersPerLine in TextSaveOptionsData is required.");
        }

    }

    std::shared_ptr< bool > TextSaveOptionsData::getAddBidiMarks() const
    {
        return this->m_AddBidiMarks;
    }

    void TextSaveOptionsData::setAddBidiMarks(std::shared_ptr< bool > value)
    {
        this->m_AddBidiMarks = value;
    }


    std::shared_ptr< int32_t > TextSaveOptionsData::getMaxCharactersPerLine() const
    {
        return this->m_MaxCharactersPerLine;
    }

    void TextSaveOptionsData::setMaxCharactersPerLine(std::shared_ptr< int32_t > value)
    {
        this->m_MaxCharactersPerLine = value;
    }


    std::shared_ptr< bool > TextSaveOptionsData::getPreserveTableLayout() const
    {
        return this->m_PreserveTableLayout;
    }

    void TextSaveOptionsData::setPreserveTableLayout(std::shared_ptr< bool > value)
    {
        this->m_PreserveTableLayout = value;
    }


    std::shared_ptr< bool > TextSaveOptionsData::getSimplifyListLabels() const
    {
        return this->m_SimplifyListLabels;
    }

    void TextSaveOptionsData::setSimplifyListLabels(std::shared_ptr< bool > value)
    {
        this->m_SimplifyListLabels = value;
    }


    std::shared_ptr< std::wstring > TextSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * TiffSaveOptionsData implementation
     */
    inline std::string tiffSaveOptionsDataTiffBinarizationMethodToString(aspose::words::cloud::models::TiffSaveOptionsData::TiffBinarizationMethod value)
    {
        if (value == aspose::words::cloud::models::TiffSaveOptionsData::TiffBinarizationMethod::THRESHOLD) return "Threshold";
        if (value == aspose::words::cloud::models::TiffSaveOptionsData::TiffBinarizationMethod::FLOYD_STEINBERG_DITHERING) return "FloydSteinbergDithering";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::TiffSaveOptionsData::TiffBinarizationMethod tiffSaveOptionsDataTiffBinarizationMethodFromString(const std::string& value)
    {
        if (value == "Threshold") return aspose::words::cloud::models::TiffSaveOptionsData::TiffBinarizationMethod::THRESHOLD;
        if (value == "FloydSteinbergDithering") return aspose::words::cloud::models::TiffSaveOptionsData::TiffBinarizationMethod::FLOYD_STEINBERG_DITHERING;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline std::string tiffSaveOptionsDataTiffCompressionToString(aspose::words::cloud::models::TiffSaveOptionsData::TiffCompression value)
    {
        if (value == aspose::words::cloud::models::TiffSaveOptionsData::TiffCompression::NONE) return "None";
        if (value == aspose::words::cloud::models::TiffSaveOptionsData::TiffCompression::RLE) return "Rle";
        if (value == aspose::words::cloud::models::TiffSaveOptionsData::TiffCompression::LZW) return "Lzw";
        if (value == aspose::words::cloud::models::TiffSaveOptionsData::TiffCompression::CCITT3) return "Ccitt3";
        if (value == aspose::words::cloud::models::TiffSaveOptionsData::TiffCompression::CCITT4) return "Ccitt4";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::TiffSaveOptionsData::TiffCompression tiffSaveOptionsDataTiffCompressionFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::TiffSaveOptionsData::TiffCompression::NONE;
        if (value == "Rle") return aspose::words::cloud::models::TiffSaveOptionsData::TiffCompression::RLE;
        if (value == "Lzw") return aspose::words::cloud::models::TiffSaveOptionsData::TiffCompression::LZW;
        if (value == "Ccitt3") return aspose::words::cloud::models::TiffSaveOptionsData::TiffCompression::CCITT3;
        if (value == "Ccitt4") return aspose::words::cloud::models::TiffSaveOptionsData::TiffCompression::CCITT4;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void TiffSaveOptionsData::toJson(void* jsonIfc) const
    {
        ImageSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ThresholdForFloydSteinbergDithering) {
            json["ThresholdForFloydSteinbergDithering"] = *(this->m_ThresholdForFloydSteinbergDithering);
        }
        if (this->m_TiffBinarizationMethod) {
            json["TiffBinarizationMethod"] = tiffSaveOptionsDataTiffBinarizationMethodToString(*(this->m_TiffBinarizationMethod));
        }
        if (this->m_TiffCompression) {
            json["TiffCompression"] = tiffSaveOptionsDataTiffCompressionToString(*(this->m_TiffCompression));
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void TiffSaveOptionsData::fromJson(const void* jsonIfc)
    {
        ImageSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ThresholdForFloydSteinbergDithering") && !json["ThresholdForFloydSteinbergDithering"].is_null()) {
            this->m_ThresholdForFloydSteinbergDithering = std::make_shared< int32_t >(
                json["ThresholdForFloydSteinbergDithering"].get< int32_t >()
            );
        }
        if (json.contains("TiffBinarizationMethod") && !json["TiffBinarizationMethod"].is_null()) {
            this->m_TiffBinarizationMethod = std::make_shared< aspose::words::cloud::models::TiffSaveOptionsData::TiffBinarizationMethod >(
                tiffSaveOptionsDataTiffBinarizationMethodFromString(json["TiffBinarizationMethod"].get< std::string >())
            );
        }
        if (json.contains("TiffCompression") && !json["TiffCompression"].is_null()) {
            this->m_TiffCompression = std::make_shared< aspose::words::cloud::models::TiffSaveOptionsData::TiffCompression >(
                tiffSaveOptionsDataTiffCompressionFromString(json["TiffCompression"].get< std::string >())
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void TiffSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TiffSaveOptionsData::validate()
    {
        ImageSaveOptionsData::validate();
    }

    std::shared_ptr< int32_t > TiffSaveOptionsData::getThresholdForFloydSteinbergDithering() const
    {
        return this->m_ThresholdForFloydSteinbergDithering;
    }

    void TiffSaveOptionsData::setThresholdForFloydSteinbergDithering(std::shared_ptr< int32_t > value)
    {
        this->m_ThresholdForFloydSteinbergDithering = value;
    }


    std::shared_ptr< aspose::words::cloud::models::TiffSaveOptionsData::TiffBinarizationMethod > TiffSaveOptionsData::getTiffBinarizationMethod() const
    {
        return this->m_TiffBinarizationMethod;
    }

    void TiffSaveOptionsData::setTiffBinarizationMethod(std::shared_ptr< aspose::words::cloud::models::TiffSaveOptionsData::TiffBinarizationMethod > value)
    {
        this->m_TiffBinarizationMethod = value;
    }


    std::shared_ptr< aspose::words::cloud::models::TiffSaveOptionsData::TiffCompression > TiffSaveOptionsData::getTiffCompression() const
    {
        return this->m_TiffCompression;
    }

    void TiffSaveOptionsData::setTiffCompression(std::shared_ptr< aspose::words::cloud::models::TiffSaveOptionsData::TiffCompression > value)
    {
        this->m_TiffCompression = value;
    }


    std::shared_ptr< std::wstring > TiffSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * TimeZoneInfoData implementation
     */
    void TimeZoneInfoData::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_BaseUtcOffset) {
            json["BaseUtcOffset"] = convertUtf16(*(this->m_BaseUtcOffset));
        }
        if (this->m_DisplayName) {
            json["DisplayName"] = convertUtf16(*(this->m_DisplayName));
        }
        if (this->m_Id) {
            json["Id"] = convertUtf16(*(this->m_Id));
        }
        if (this->m_StandardDisplayName) {
            json["StandardDisplayName"] = convertUtf16(*(this->m_StandardDisplayName));
        }
    }

    void TimeZoneInfoData::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("BaseUtcOffset") && !json["BaseUtcOffset"].is_null()) {
            this->m_BaseUtcOffset = std::make_shared< std::wstring >(
                convertUtf8( json["BaseUtcOffset"].get< std::string >() )
            );
        }
        if (json.contains("DisplayName") && !json["DisplayName"].is_null()) {
            this->m_DisplayName = std::make_shared< std::wstring >(
                convertUtf8( json["DisplayName"].get< std::string >() )
            );
        }
        if (json.contains("Id") && !json["Id"].is_null()) {
            this->m_Id = std::make_shared< std::wstring >(
                convertUtf8( json["Id"].get< std::string >() )
            );
        }
        if (json.contains("StandardDisplayName") && !json["StandardDisplayName"].is_null()) {
            this->m_StandardDisplayName = std::make_shared< std::wstring >(
                convertUtf8( json["StandardDisplayName"].get< std::string >() )
            );
        }
    }

    void TimeZoneInfoData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TimeZoneInfoData::validate()
    {
    }

    std::shared_ptr< std::wstring > TimeZoneInfoData::getBaseUtcOffset() const
    {
        return this->m_BaseUtcOffset;
    }

    void TimeZoneInfoData::setBaseUtcOffset(std::shared_ptr< std::wstring > value)
    {
        this->m_BaseUtcOffset = value;
    }


    std::shared_ptr< std::wstring > TimeZoneInfoData::getDisplayName() const
    {
        return this->m_DisplayName;
    }

    void TimeZoneInfoData::setDisplayName(std::shared_ptr< std::wstring > value)
    {
        this->m_DisplayName = value;
    }


    std::shared_ptr< std::wstring > TimeZoneInfoData::getId() const
    {
        return this->m_Id;
    }

    void TimeZoneInfoData::setId(std::shared_ptr< std::wstring > value)
    {
        this->m_Id = value;
    }


    std::shared_ptr< std::wstring > TimeZoneInfoData::getStandardDisplayName() const
    {
        return this->m_StandardDisplayName;
    }

    void TimeZoneInfoData::setStandardDisplayName(std::shared_ptr< std::wstring > value)
    {
        this->m_StandardDisplayName = value;
    }



    /*
     * TranslateNodeIdResponse implementation
     */
    void TranslateNodeIdResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Path) {
            json["Path"] = convertUtf16(*(this->m_Path));
        }
    }

    void TranslateNodeIdResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Path") && !json["Path"].is_null()) {
            this->m_Path = std::make_shared< std::wstring >(
                convertUtf8( json["Path"].get< std::string >() )
            );
        }
    }

    void TranslateNodeIdResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TranslateNodeIdResponse::validate()
    {
        WordsResponse::validate();
    }

    std::shared_ptr< std::wstring > TranslateNodeIdResponse::getPath() const
    {
        return this->m_Path;
    }

    void TranslateNodeIdResponse::setPath(std::shared_ptr< std::wstring > value)
    {
        this->m_Path = value;
    }



    /*
     * TxtSaveOptionsBaseData implementation
     */
    inline std::string txtSaveOptionsBaseDataExportHeadersFootersModeToString(aspose::words::cloud::models::TxtSaveOptionsBaseData::ExportHeadersFootersMode value)
    {
        if (value == aspose::words::cloud::models::TxtSaveOptionsBaseData::ExportHeadersFootersMode::NONE) return "None";
        if (value == aspose::words::cloud::models::TxtSaveOptionsBaseData::ExportHeadersFootersMode::PRIMARY_ONLY) return "PrimaryOnly";
        if (value == aspose::words::cloud::models::TxtSaveOptionsBaseData::ExportHeadersFootersMode::ALL_AT_END) return "AllAtEnd";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::TxtSaveOptionsBaseData::ExportHeadersFootersMode txtSaveOptionsBaseDataExportHeadersFootersModeFromString(const std::string& value)
    {
        if (value == "None") return aspose::words::cloud::models::TxtSaveOptionsBaseData::ExportHeadersFootersMode::NONE;
        if (value == "PrimaryOnly") return aspose::words::cloud::models::TxtSaveOptionsBaseData::ExportHeadersFootersMode::PRIMARY_ONLY;
        if (value == "AllAtEnd") return aspose::words::cloud::models::TxtSaveOptionsBaseData::ExportHeadersFootersMode::ALL_AT_END;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void TxtSaveOptionsBaseData::toJson(void* jsonIfc) const
    {
        SaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Encoding) {
            json["Encoding"] = convertUtf16(*(this->m_Encoding));
        }
        if (this->m_ExportHeadersFootersMode) {
            json["ExportHeadersFootersMode"] = txtSaveOptionsBaseDataExportHeadersFootersModeToString(*(this->m_ExportHeadersFootersMode));
        }
        if (this->m_ForcePageBreaks) {
            json["ForcePageBreaks"] = *(this->m_ForcePageBreaks);
        }
        if (this->m_ParagraphBreak) {
            json["ParagraphBreak"] = convertUtf16(*(this->m_ParagraphBreak));
        }
    }

    void TxtSaveOptionsBaseData::fromJson(const void* jsonIfc)
    {
        SaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Encoding") && !json["Encoding"].is_null()) {
            this->m_Encoding = std::make_shared< std::wstring >(
                convertUtf8( json["Encoding"].get< std::string >() )
            );
        }
        if (json.contains("ExportHeadersFootersMode") && !json["ExportHeadersFootersMode"].is_null()) {
            this->m_ExportHeadersFootersMode = std::make_shared< aspose::words::cloud::models::TxtSaveOptionsBaseData::ExportHeadersFootersMode >(
                txtSaveOptionsBaseDataExportHeadersFootersModeFromString(json["ExportHeadersFootersMode"].get< std::string >())
            );
        }
        if (json.contains("ForcePageBreaks") && !json["ForcePageBreaks"].is_null()) {
            this->m_ForcePageBreaks = std::make_shared< bool >(
                json["ForcePageBreaks"].get< bool >()
            );
        }
        if (json.contains("ParagraphBreak") && !json["ParagraphBreak"].is_null()) {
            this->m_ParagraphBreak = std::make_shared< std::wstring >(
                convertUtf8( json["ParagraphBreak"].get< std::string >() )
            );
        }
    }

    void TxtSaveOptionsBaseData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void TxtSaveOptionsBaseData::validate()
    {
        SaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > TxtSaveOptionsBaseData::getEncoding() const
    {
        return this->m_Encoding;
    }

    void TxtSaveOptionsBaseData::setEncoding(std::shared_ptr< std::wstring > value)
    {
        this->m_Encoding = value;
    }


    std::shared_ptr< aspose::words::cloud::models::TxtSaveOptionsBaseData::ExportHeadersFootersMode > TxtSaveOptionsBaseData::getExportHeadersFootersMode() const
    {
        return this->m_ExportHeadersFootersMode;
    }

    void TxtSaveOptionsBaseData::setExportHeadersFootersMode(std::shared_ptr< aspose::words::cloud::models::TxtSaveOptionsBaseData::ExportHeadersFootersMode > value)
    {
        this->m_ExportHeadersFootersMode = value;
    }


    std::shared_ptr< bool > TxtSaveOptionsBaseData::getForcePageBreaks() const
    {
        return this->m_ForcePageBreaks;
    }

    void TxtSaveOptionsBaseData::setForcePageBreaks(std::shared_ptr< bool > value)
    {
        this->m_ForcePageBreaks = value;
    }


    std::shared_ptr< std::wstring > TxtSaveOptionsBaseData::getParagraphBreak() const
    {
        return this->m_ParagraphBreak;
    }

    void TxtSaveOptionsBaseData::setParagraphBreak(std::shared_ptr< std::wstring > value)
    {
        this->m_ParagraphBreak = value;
    }



    /*
     * UserInformation implementation
     */
    void UserInformation::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Address) {
            json["Address"] = convertUtf16(*(this->m_Address));
        }
        if (this->m_Initials) {
            json["Initials"] = convertUtf16(*(this->m_Initials));
        }
        if (this->m_Name) {
            json["Name"] = convertUtf16(*(this->m_Name));
        }
    }

    void UserInformation::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Address") && !json["Address"].is_null()) {
            this->m_Address = std::make_shared< std::wstring >(
                convertUtf8( json["Address"].get< std::string >() )
            );
        }
        if (json.contains("Initials") && !json["Initials"].is_null()) {
            this->m_Initials = std::make_shared< std::wstring >(
                convertUtf8( json["Initials"].get< std::string >() )
            );
        }
        if (json.contains("Name") && !json["Name"].is_null()) {
            this->m_Name = std::make_shared< std::wstring >(
                convertUtf8( json["Name"].get< std::string >() )
            );
        }
    }

    void UserInformation::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void UserInformation::validate()
    {
    }

    std::shared_ptr< std::wstring > UserInformation::getAddress() const
    {
        return this->m_Address;
    }

    void UserInformation::setAddress(std::shared_ptr< std::wstring > value)
    {
        this->m_Address = value;
    }


    std::shared_ptr< std::wstring > UserInformation::getInitials() const
    {
        return this->m_Initials;
    }

    void UserInformation::setInitials(std::shared_ptr< std::wstring > value)
    {
        this->m_Initials = value;
    }


    std::shared_ptr< std::wstring > UserInformation::getName() const
    {
        return this->m_Name;
    }

    void UserInformation::setName(std::shared_ptr< std::wstring > value)
    {
        this->m_Name = value;
    }



    /*
     * WatermarkDataBase implementation
     */
    void WatermarkDataBase::toJson(void* jsonIfc) const
    {
    }

    void WatermarkDataBase::fromJson(const void* jsonIfc)
    {
    }

    void WatermarkDataBase::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void WatermarkDataBase::validate()
    {
    }




    /*
     * WatermarkDataImage implementation
     */
    void WatermarkDataImage::toJson(void* jsonIfc) const
    {
        WatermarkDataBase::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Image) {
            this->m_Image->toJson(&json["Image"]);
        }
        if (this->m_IsWashout) {
            json["IsWashout"] = *(this->m_IsWashout);
        }
        if (this->m_Scale) {
            json["Scale"] = *(this->m_Scale);
        }
    }

    void WatermarkDataImage::fromJson(const void* jsonIfc)
    {
        WatermarkDataBase::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Image") && !json["Image"].is_null()) {
            this->m_Image = createModelInstance< aspose::words::cloud::models::FileReference >(L"FileReference, _", json["Image"]);
        }
        if (json.contains("IsWashout") && !json["IsWashout"].is_null()) {
            this->m_IsWashout = std::make_shared< bool >(
                json["IsWashout"].get< bool >()
            );
        }
        if (json.contains("Scale") && !json["Scale"].is_null()) {
            this->m_Scale = std::make_shared< double >(
                json["Scale"].get< double >()
            );
        }
    }

    void WatermarkDataImage::getFileReferences(std::vector< FileReference* >& result)
    {
        WatermarkDataBase::getFileReferences(result);
        if (getImage() != nullptr)
        {
            getImage()->getFileReferences(result);
        }



    }

    void WatermarkDataImage::validate()
    {
        WatermarkDataBase::validate();
        if (this->m_Image == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Image in WatermarkDataImage is required.");
        }

        this->m_Image->validate();


        if (this->m_Image != nullptr)
        {
            this->m_Image->validate();
        }



    }

    std::shared_ptr< aspose::words::cloud::models::FileReference > WatermarkDataImage::getImage() const
    {
        return this->m_Image;
    }

    void WatermarkDataImage::setImage(std::shared_ptr< aspose::words::cloud::models::FileReference > value)
    {
        this->m_Image = value;
    }


    std::shared_ptr< bool > WatermarkDataImage::getIsWashout() const
    {
        return this->m_IsWashout;
    }

    void WatermarkDataImage::setIsWashout(std::shared_ptr< bool > value)
    {
        this->m_IsWashout = value;
    }


    std::shared_ptr< double > WatermarkDataImage::getScale() const
    {
        return this->m_Scale;
    }

    void WatermarkDataImage::setScale(std::shared_ptr< double > value)
    {
        this->m_Scale = value;
    }



    /*
     * WatermarkDataText implementation
     */
    inline std::string watermarkDataTextLayoutToString(aspose::words::cloud::models::WatermarkDataText::Layout value)
    {
        if (value == aspose::words::cloud::models::WatermarkDataText::Layout::HORIZONTAL) return "Horizontal";
        if (value == aspose::words::cloud::models::WatermarkDataText::Layout::DIAGONAL) return "Diagonal";
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }

    inline aspose::words::cloud::models::WatermarkDataText::Layout watermarkDataTextLayoutFromString(const std::string& value)
    {
        if (value == "Horizontal") return aspose::words::cloud::models::WatermarkDataText::Layout::HORIZONTAL;
        if (value == "Diagonal") return aspose::words::cloud::models::WatermarkDataText::Layout::DIAGONAL;
        throw aspose::words::cloud::ApiException(400, L"Invalid enum value");
    }
    void WatermarkDataText::toJson(void* jsonIfc) const
    {
        WatermarkDataBase::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Color) {
            this->m_Color->toJson(&json["Color"]);
        }
        if (this->m_FontFamily) {
            json["FontFamily"] = convertUtf16(*(this->m_FontFamily));
        }
        if (this->m_FontSize) {
            json["FontSize"] = *(this->m_FontSize);
        }
        if (this->m_IsSemitrasparent) {
            json["IsSemitrasparent"] = *(this->m_IsSemitrasparent);
        }
        if (this->m_Layout) {
            json["Layout"] = watermarkDataTextLayoutToString(*(this->m_Layout));
        }
        if (this->m_Text) {
            json["Text"] = convertUtf16(*(this->m_Text));
        }
    }

    void WatermarkDataText::fromJson(const void* jsonIfc)
    {
        WatermarkDataBase::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Color") && !json["Color"].is_null()) {
            this->m_Color = createModelInstance< aspose::words::cloud::models::XmlColor >(L"XmlColor, _", json["Color"]);
        }
        if (json.contains("FontFamily") && !json["FontFamily"].is_null()) {
            this->m_FontFamily = std::make_shared< std::wstring >(
                convertUtf8( json["FontFamily"].get< std::string >() )
            );
        }
        if (json.contains("FontSize") && !json["FontSize"].is_null()) {
            this->m_FontSize = std::make_shared< double >(
                json["FontSize"].get< double >()
            );
        }
        if (json.contains("IsSemitrasparent") && !json["IsSemitrasparent"].is_null()) {
            this->m_IsSemitrasparent = std::make_shared< bool >(
                json["IsSemitrasparent"].get< bool >()
            );
        }
        if (json.contains("Layout") && !json["Layout"].is_null()) {
            this->m_Layout = std::make_shared< aspose::words::cloud::models::WatermarkDataText::Layout >(
                watermarkDataTextLayoutFromString(json["Layout"].get< std::string >())
            );
        }
        if (json.contains("Text") && !json["Text"].is_null()) {
            this->m_Text = std::make_shared< std::wstring >(
                convertUtf8( json["Text"].get< std::string >() )
            );
        }
    }

    void WatermarkDataText::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void WatermarkDataText::validate()
    {
        WatermarkDataBase::validate();
        if (this->m_Text == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Text in WatermarkDataText is required.");
        }


        if (this->m_Color != nullptr)
        {
            this->m_Color->validate();
        }






    }

    std::shared_ptr< aspose::words::cloud::models::XmlColor > WatermarkDataText::getColor() const
    {
        return this->m_Color;
    }

    void WatermarkDataText::setColor(std::shared_ptr< aspose::words::cloud::models::XmlColor > value)
    {
        this->m_Color = value;
    }


    std::shared_ptr< std::wstring > WatermarkDataText::getFontFamily() const
    {
        return this->m_FontFamily;
    }

    void WatermarkDataText::setFontFamily(std::shared_ptr< std::wstring > value)
    {
        this->m_FontFamily = value;
    }


    std::shared_ptr< double > WatermarkDataText::getFontSize() const
    {
        return this->m_FontSize;
    }

    void WatermarkDataText::setFontSize(std::shared_ptr< double > value)
    {
        this->m_FontSize = value;
    }


    std::shared_ptr< bool > WatermarkDataText::getIsSemitrasparent() const
    {
        return this->m_IsSemitrasparent;
    }

    void WatermarkDataText::setIsSemitrasparent(std::shared_ptr< bool > value)
    {
        this->m_IsSemitrasparent = value;
    }


    std::shared_ptr< aspose::words::cloud::models::WatermarkDataText::Layout > WatermarkDataText::getLayout() const
    {
        return this->m_Layout;
    }

    void WatermarkDataText::setLayout(std::shared_ptr< aspose::words::cloud::models::WatermarkDataText::Layout > value)
    {
        this->m_Layout = value;
    }


    std::shared_ptr< std::wstring > WatermarkDataText::getText() const
    {
        return this->m_Text;
    }

    void WatermarkDataText::setText(std::shared_ptr< std::wstring > value)
    {
        this->m_Text = value;
    }



    /*
     * WatermarkText implementation
     */
    void WatermarkText::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_RotationAngle) {
            json["RotationAngle"] = *(this->m_RotationAngle);
        }
        if (this->m_Text) {
            json["Text"] = convertUtf16(*(this->m_Text));
        }
    }

    void WatermarkText::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("RotationAngle") && !json["RotationAngle"].is_null()) {
            this->m_RotationAngle = std::make_shared< double >(
                json["RotationAngle"].get< double >()
            );
        }
        if (json.contains("Text") && !json["Text"].is_null()) {
            this->m_Text = std::make_shared< std::wstring >(
                convertUtf8( json["Text"].get< std::string >() )
            );
        }
    }

    void WatermarkText::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void WatermarkText::validate()
    {
        if (this->m_RotationAngle == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property RotationAngle in WatermarkText is required.");
        }

        if (this->m_Text == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property Text in WatermarkText is required.");
        }

    }

    std::shared_ptr< double > WatermarkText::getRotationAngle() const
    {
        return this->m_RotationAngle;
    }

    void WatermarkText::setRotationAngle(std::shared_ptr< double > value)
    {
        this->m_RotationAngle = value;
    }


    std::shared_ptr< std::wstring > WatermarkText::getText() const
    {
        return this->m_Text;
    }

    void WatermarkText::setText(std::shared_ptr< std::wstring > value)
    {
        this->m_Text = value;
    }



    /*
     * WordMLSaveOptionsData implementation
     */
    void WordMLSaveOptionsData::toJson(void* jsonIfc) const
    {
        SaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_PrettyFormat) {
            json["PrettyFormat"] = *(this->m_PrettyFormat);
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void WordMLSaveOptionsData::fromJson(const void* jsonIfc)
    {
        SaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("PrettyFormat") && !json["PrettyFormat"].is_null()) {
            this->m_PrettyFormat = std::make_shared< bool >(
                json["PrettyFormat"].get< bool >()
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void WordMLSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void WordMLSaveOptionsData::validate()
    {
        SaveOptionsData::validate();
    }

    std::shared_ptr< bool > WordMLSaveOptionsData::getPrettyFormat() const
    {
        return this->m_PrettyFormat;
    }

    void WordMLSaveOptionsData::setPrettyFormat(std::shared_ptr< bool > value)
    {
        this->m_PrettyFormat = value;
    }


    std::shared_ptr< std::wstring > WordMLSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * WordsApiErrorResponse implementation
     */
    void WordsApiErrorResponse::toJson(void* jsonIfc) const
    {
        WordsResponse::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Error) {
            this->m_Error->toJson(&json["Error"]);
        }
    }

    void WordsApiErrorResponse::fromJson(const void* jsonIfc)
    {
        WordsResponse::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Error") && !json["Error"].is_null()) {
            this->m_Error = createModelInstance< aspose::words::cloud::models::ApiError >(L"ApiError, _", json["Error"]);
        }
    }

    void WordsApiErrorResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void WordsApiErrorResponse::validate()
    {
        WordsResponse::validate();

        if (this->m_Error != nullptr)
        {
            this->m_Error->validate();
        }

    }

    std::shared_ptr< aspose::words::cloud::models::ApiError > WordsApiErrorResponse::getError() const
    {
        return this->m_Error;
    }

    void WordsApiErrorResponse::setError(std::shared_ptr< aspose::words::cloud::models::ApiError > value)
    {
        this->m_Error = value;
    }



    /*
     * WordsApiLink implementation
     */
    void WordsApiLink::toJson(void* jsonIfc) const
    {
        Link::toJson(jsonIfc);
    }

    void WordsApiLink::fromJson(const void* jsonIfc)
    {
        Link::fromJson(jsonIfc);
    }

    void WordsApiLink::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void WordsApiLink::validate()
    {
        Link::validate();
    }




    /*
     * WordsResponse implementation
     */
    void WordsResponse::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_RequestId) {
            json["RequestId"] = convertUtf16(*(this->m_RequestId));
        }
    }

    void WordsResponse::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("RequestId") && !json["RequestId"].is_null()) {
            this->m_RequestId = std::make_shared< std::wstring >(
                convertUtf8( json["RequestId"].get< std::string >() )
            );
        }
    }

    void WordsResponse::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void WordsResponse::validate()
    {
    }

    std::shared_ptr< std::wstring > WordsResponse::getRequestId() const
    {
        return this->m_RequestId;
    }

    void WordsResponse::setRequestId(std::shared_ptr< std::wstring > value)
    {
        this->m_RequestId = value;
    }



    /*
     * XamlFixedSaveOptionsData implementation
     */
    void XamlFixedSaveOptionsData::toJson(void* jsonIfc) const
    {
        FixedPageSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ResourcesFolder) {
            json["ResourcesFolder"] = convertUtf16(*(this->m_ResourcesFolder));
        }
        if (this->m_ResourcesFolderAlias) {
            json["ResourcesFolderAlias"] = convertUtf16(*(this->m_ResourcesFolderAlias));
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void XamlFixedSaveOptionsData::fromJson(const void* jsonIfc)
    {
        FixedPageSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ResourcesFolder") && !json["ResourcesFolder"].is_null()) {
            this->m_ResourcesFolder = std::make_shared< std::wstring >(
                convertUtf8( json["ResourcesFolder"].get< std::string >() )
            );
        }
        if (json.contains("ResourcesFolderAlias") && !json["ResourcesFolderAlias"].is_null()) {
            this->m_ResourcesFolderAlias = std::make_shared< std::wstring >(
                convertUtf8( json["ResourcesFolderAlias"].get< std::string >() )
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void XamlFixedSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void XamlFixedSaveOptionsData::validate()
    {
        FixedPageSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > XamlFixedSaveOptionsData::getResourcesFolder() const
    {
        return this->m_ResourcesFolder;
    }

    void XamlFixedSaveOptionsData::setResourcesFolder(std::shared_ptr< std::wstring > value)
    {
        this->m_ResourcesFolder = value;
    }


    std::shared_ptr< std::wstring > XamlFixedSaveOptionsData::getResourcesFolderAlias() const
    {
        return this->m_ResourcesFolderAlias;
    }

    void XamlFixedSaveOptionsData::setResourcesFolderAlias(std::shared_ptr< std::wstring > value)
    {
        this->m_ResourcesFolderAlias = value;
    }


    std::shared_ptr< std::wstring > XamlFixedSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * XamlFlowPackSaveOptionsData implementation
     */
    void XamlFlowPackSaveOptionsData::toJson(void* jsonIfc) const
    {
        XamlFlowSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void XamlFlowPackSaveOptionsData::fromJson(const void* jsonIfc)
    {
        XamlFlowSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void XamlFlowPackSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void XamlFlowPackSaveOptionsData::validate()
    {
        XamlFlowSaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > XamlFlowPackSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * XamlFlowSaveOptionsData implementation
     */
    void XamlFlowSaveOptionsData::toJson(void* jsonIfc) const
    {
        SaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_ImagesFolder) {
            json["ImagesFolder"] = convertUtf16(*(this->m_ImagesFolder));
        }
        if (this->m_ImagesFolderAlias) {
            json["ImagesFolderAlias"] = convertUtf16(*(this->m_ImagesFolderAlias));
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void XamlFlowSaveOptionsData::fromJson(const void* jsonIfc)
    {
        SaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("ImagesFolder") && !json["ImagesFolder"].is_null()) {
            this->m_ImagesFolder = std::make_shared< std::wstring >(
                convertUtf8( json["ImagesFolder"].get< std::string >() )
            );
        }
        if (json.contains("ImagesFolderAlias") && !json["ImagesFolderAlias"].is_null()) {
            this->m_ImagesFolderAlias = std::make_shared< std::wstring >(
                convertUtf8( json["ImagesFolderAlias"].get< std::string >() )
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void XamlFlowSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void XamlFlowSaveOptionsData::validate()
    {
        SaveOptionsData::validate();
    }

    std::shared_ptr< std::wstring > XamlFlowSaveOptionsData::getImagesFolder() const
    {
        return this->m_ImagesFolder;
    }

    void XamlFlowSaveOptionsData::setImagesFolder(std::shared_ptr< std::wstring > value)
    {
        this->m_ImagesFolder = value;
    }


    std::shared_ptr< std::wstring > XamlFlowSaveOptionsData::getImagesFolderAlias() const
    {
        return this->m_ImagesFolderAlias;
    }

    void XamlFlowSaveOptionsData::setImagesFolderAlias(std::shared_ptr< std::wstring > value)
    {
        this->m_ImagesFolderAlias = value;
    }


    std::shared_ptr< std::wstring > XamlFlowSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




    /*
     * XmlColor implementation
     */
    void XmlColor::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_Alpha) {
            json["Alpha"] = *(this->m_Alpha);
        }
        if (this->m_Web) {
            json["Web"] = convertUtf16(*(this->m_Web));
        }
    }

    void XmlColor::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("Alpha") && !json["Alpha"].is_null()) {
            this->m_Alpha = std::make_shared< int32_t >(
                json["Alpha"].get< int32_t >()
            );
        }
        if (json.contains("Web") && !json["Web"].is_null()) {
            this->m_Web = std::make_shared< std::wstring >(
                convertUtf8( json["Web"].get< std::string >() )
            );
        }
    }

    void XmlColor::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void XmlColor::validate()
    {
    }

    std::shared_ptr< int32_t > XmlColor::getAlpha() const
    {
        return this->m_Alpha;
    }

    void XmlColor::setAlpha(std::shared_ptr< int32_t > value)
    {
        this->m_Alpha = value;
    }


    std::shared_ptr< std::wstring > XmlColor::getWeb() const
    {
        return this->m_Web;
    }

    void XmlColor::setWeb(std::shared_ptr< std::wstring > value)
    {
        this->m_Web = value;
    }



    /*
     * XmlDataLoadOptions implementation
     */
    void XmlDataLoadOptions::toJson(void* jsonIfc) const
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_AlwaysGenerateRootObject) {
            json["AlwaysGenerateRootObject"] = *(this->m_AlwaysGenerateRootObject);
        }
    }

    void XmlDataLoadOptions::fromJson(const void* jsonIfc)
    {
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("AlwaysGenerateRootObject") && !json["AlwaysGenerateRootObject"].is_null()) {
            this->m_AlwaysGenerateRootObject = std::make_shared< bool >(
                json["AlwaysGenerateRootObject"].get< bool >()
            );
        }
    }

    void XmlDataLoadOptions::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void XmlDataLoadOptions::validate()
    {
        if (this->m_AlwaysGenerateRootObject == nullptr)
        {
            throw aspose::words::cloud::ApiException(400, L"Property AlwaysGenerateRootObject in XmlDataLoadOptions is required.");
        }

    }

    std::shared_ptr< bool > XmlDataLoadOptions::getAlwaysGenerateRootObject() const
    {
        return this->m_AlwaysGenerateRootObject;
    }

    void XmlDataLoadOptions::setAlwaysGenerateRootObject(std::shared_ptr< bool > value)
    {
        this->m_AlwaysGenerateRootObject = value;
    }



    /*
     * XpsSaveOptionsData implementation
     */
    void XpsSaveOptionsData::toJson(void* jsonIfc) const
    {
        FixedPageSaveOptionsData::toJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (this->m_BookmarksOutlineLevel) {
            json["BookmarksOutlineLevel"] = *(this->m_BookmarksOutlineLevel);
        }
        if (this->m_HeadingsOutlineLevels) {
            json["HeadingsOutlineLevels"] = *(this->m_HeadingsOutlineLevels);
        }
        if (this->m_OutlineOptions) {
            this->m_OutlineOptions->toJson(&json["OutlineOptions"]);
        }
        if (this->m_UseBookFoldPrintingSettings) {
            json["UseBookFoldPrintingSettings"] = *(this->m_UseBookFoldPrintingSettings);
        }
        if (this->m_SaveFormat) {
            json["SaveFormat"] = convertUtf16(*(this->m_SaveFormat));
        }
    }

    void XpsSaveOptionsData::fromJson(const void* jsonIfc)
    {
        FixedPageSaveOptionsData::fromJson(jsonIfc);
        ::nlohmann::json& json = *((::nlohmann::json*)jsonIfc);
        if (json.contains("BookmarksOutlineLevel") && !json["BookmarksOutlineLevel"].is_null()) {
            this->m_BookmarksOutlineLevel = std::make_shared< int32_t >(
                json["BookmarksOutlineLevel"].get< int32_t >()
            );
        }
        if (json.contains("HeadingsOutlineLevels") && !json["HeadingsOutlineLevels"].is_null()) {
            this->m_HeadingsOutlineLevels = std::make_shared< int32_t >(
                json["HeadingsOutlineLevels"].get< int32_t >()
            );
        }
        if (json.contains("OutlineOptions") && !json["OutlineOptions"].is_null()) {
            this->m_OutlineOptions = createModelInstance< aspose::words::cloud::models::OutlineOptionsData >(L"OutlineOptionsData, _", json["OutlineOptions"]);
        }
        if (json.contains("UseBookFoldPrintingSettings") && !json["UseBookFoldPrintingSettings"].is_null()) {
            this->m_UseBookFoldPrintingSettings = std::make_shared< bool >(
                json["UseBookFoldPrintingSettings"].get< bool >()
            );
        }
        if (json.contains("SaveFormat") && !json["SaveFormat"].is_null()) {
            this->m_SaveFormat = std::make_shared< std::wstring >(
                convertUtf8( json["SaveFormat"].get< std::string >() )
            );
        }
    }

    void XpsSaveOptionsData::getFileReferences(std::vector< FileReference* >& result)
    {
    }

    void XpsSaveOptionsData::validate()
    {
        FixedPageSaveOptionsData::validate();

        if (this->m_OutlineOptions != nullptr)
        {
            this->m_OutlineOptions->validate();
        }



    }

    std::shared_ptr< int32_t > XpsSaveOptionsData::getBookmarksOutlineLevel() const
    {
        return this->m_BookmarksOutlineLevel;
    }

    void XpsSaveOptionsData::setBookmarksOutlineLevel(std::shared_ptr< int32_t > value)
    {
        this->m_BookmarksOutlineLevel = value;
    }


    std::shared_ptr< int32_t > XpsSaveOptionsData::getHeadingsOutlineLevels() const
    {
        return this->m_HeadingsOutlineLevels;
    }

    void XpsSaveOptionsData::setHeadingsOutlineLevels(std::shared_ptr< int32_t > value)
    {
        this->m_HeadingsOutlineLevels = value;
    }


    std::shared_ptr< aspose::words::cloud::models::OutlineOptionsData > XpsSaveOptionsData::getOutlineOptions() const
    {
        return this->m_OutlineOptions;
    }

    void XpsSaveOptionsData::setOutlineOptions(std::shared_ptr< aspose::words::cloud::models::OutlineOptionsData > value)
    {
        this->m_OutlineOptions = value;
    }


    std::shared_ptr< bool > XpsSaveOptionsData::getUseBookFoldPrintingSettings() const
    {
        return this->m_UseBookFoldPrintingSettings;
    }

    void XpsSaveOptionsData::setUseBookFoldPrintingSettings(std::shared_ptr< bool > value)
    {
        this->m_UseBookFoldPrintingSettings = value;
    }


    std::shared_ptr< std::wstring > XpsSaveOptionsData::getSaveFormat() const
    {
        return this->m_SaveFormat;
    }




}